[
  {
    "question_text": "In the context of operating system security and malware, what does SMM stand for?",
    "correct_answer": "System Management Mode",
    "distractors": [
      {
        "question_text": "Security Management Module",
        "misconception": "Targets word substitution: &#39;Security&#39; and &#39;Module&#39; are common security terms but incorrect for this specific CPU mode."
      },
      {
        "question_text": "System Memory Management",
        "misconception": "Targets functional confusion: SMM does manage memory, but &#39;Management Mode&#39; is the precise term for the CPU operating mode."
      },
      {
        "question_text": "Secure Mode Management",
        "misconception": "Targets similar-sounding terms: &#39;Secure&#39; is a common prefix in security, but &#39;System&#39; is the correct first word."
      }
    ],
    "detailed_explanation": {
      "core_logic": "System Management Mode (SMM) is a special operating mode in x86 microprocessors that handles system-wide functions like power management, hardware control, and error handling. It operates at a higher privilege level than the operating system kernel (Ring 0), making it a prime target for advanced persistent threats like bootkits and rootkits to maintain stealth and control.",
      "distractor_analysis": "The distractors are designed to test precise recall. &#39;Security Management Module&#39; uses common security terminology but misidentifies the &#39;S&#39; and &#39;M&#39; in SMM. &#39;System Memory Management&#39; correctly identifies &#39;System&#39; but focuses on a function (memory management) rather than the mode itself. &#39;Secure Mode Management&#39; uses &#39;Secure&#39; which is plausible in a security context but incorrect for the &#39;S&#39; in SMM.",
      "analogy": "Think of SMM as the CPU&#39;s &#39;janitor closet&#39; â€“ it has access to everything in the building (the system) to perform maintenance tasks, even when the main offices (the OS) are running. If a malicious actor gains access to this closet, they can tamper with anything without being seen by the regular occupants."
    },
    "code_snippets": [],
    "difficulty": "advanced",
    "question_type": "definition",
    "prerequisites": [
      "ATTACK_EXPLOIT",
      "OS_INTERNALS",
      "LOW_LEVEL_SECURITY"
    ]
  },
  {
    "question_text": "In the context of Windows memory forensics, what does the acronym &#39;DTB&#39; refer to?",
    "correct_answer": "Directory Table Base",
    "distractors": [
      {
        "question_text": "Data Transfer Buffer",
        "misconception": "Targets similar-sounding technical terms: &#39;Data Transfer Buffer&#39; is a common computing term but unrelated to memory management structures."
      },
      {
        "question_text": "Dynamic Translation Block",
        "misconception": "Targets plausible but incorrect technical jargon: &#39;Dynamic Translation Block&#39; sounds like a memory management concept but is not the correct expansion for DTB in this context."
      },
      {
        "question_text": "Device Type Base",
        "misconception": "Targets word substitution: &#39;Device Type Base&#39; substitutes &#39;Directory&#39; with &#39;Device&#39;, which is a related but incorrect concept in memory structures."
      }
    ],
    "detailed_explanation": {
      "core_logic": "In Windows memory management, the Directory Table Base (DTB) is a crucial register that holds the physical address of the Page Directory Base (PDBR) for the currently active process. It&#39;s essential for the Memory Management Unit (MMU) to translate virtual addresses to physical addresses.",
      "distractor_analysis": "The distractors are designed to sound technically plausible within a computing or memory context but are incorrect. &#39;Data Transfer Buffer&#39; is a generic term, &#39;Dynamic Translation Block&#39; is a fabricated but convincing term, and &#39;Device Type Base&#39; incorrectly substitutes a key word, testing precise recall of the acronym&#39;s meaning in the specific domain of Windows internals.",
      "analogy": "Think of the DTB as the &#39;master map&#39; register for a process. When the CPU needs to find data in memory for a specific process, it first looks at the DTB to find where that process&#39;s specific memory map (page directory) begins."
    },
    "code_snippets": [
      {
        "language": "bash",
        "code": "Current context: process System, pid=4, ppid=0 DTB=0x187000",
        "context": "The output from a memory forensics tool like Volatility often displays the DTB value for the current process context, indicating the base address of its page directory."
      }
    ],
    "difficulty": "advanced",
    "question_type": "definition",
    "prerequisites": [
      "OS_INTERNALS",
      "MEMORY_FORENSICS"
    ]
  },
  {
    "question_text": "What does DPC stand for in the context of kernel timers and operating systems?",
    "correct_answer": "Deferred Procedure Call",
    "distractors": [
      {
        "question_text": "Direct Process Control",
        "misconception": "Targets similar-sounding terms: &#39;Direct&#39; and &#39;Process&#39; are common computing terms, but incorrect here. &#39;Control&#39; implies a different functional role."
      },
      {
        "question_text": "Dynamic Program Counter",
        "misconception": "Targets concept confusion: &#39;Program Counter&#39; is a CPU register, and &#39;Dynamic&#39; is a common modifier, leading to a plausible but incorrect technical term."
      },
      {
        "question_text": "Device Priority Channel",
        "misconception": "Targets domain confusion: &#39;Device&#39; and &#39;Channel&#39; relate to hardware/I/O, which is a different aspect of kernel operations than procedure scheduling."
      }
    ],
    "detailed_explanation": {
      "core_logic": "A Deferred Procedure Call (DPC) is a mechanism in operating system kernels (especially Windows) for scheduling high-priority tasks to be executed at a lower interrupt request level (IRQL) than the interrupt that triggered them. This allows the system to quickly dismiss the interrupt and handle the bulk of the work later, improving system responsiveness. In the context of kernel timers, a DPC routine is the function that the system calls when a timer expires.",
      "distractor_analysis": "The distractors are designed to sound technically plausible by using common computing and kernel-related terms. &#39;Direct Process Control&#39; misrepresents the &#39;P&#39; and &#39;C&#39; with terms that imply direct manipulation rather than a scheduled callback. &#39;Dynamic Program Counter&#39; conflates DPC with CPU architecture concepts. &#39;Device Priority Channel&#39; shifts the focus to hardware communication rather than software procedure scheduling.",
      "analogy": "Think of a DPC as a &#39;post-it note&#39; for the CPU. When something urgent happens (like a timer expiring), the CPU quickly writes down &#39;do this task later&#39; (the DPC) and gets back to its high-priority work. Then, when things calm down, it picks up the post-it note and executes the task."
    },
    "code_snippets": [],
    "difficulty": "advanced",
    "question_type": "definition",
    "prerequisites": [
      "OS_KERNELS",
      "MEMORY_FORENSICS"
    ]
  },
  {
    "question_text": "What does GOT stand for in the context of Linux memory forensics and rootkit detection?",
    "correct_answer": "Global Offset Table",
    "distractors": [
      {
        "question_text": "General Object Table",
        "misconception": "Targets similar-sounding terms: &#39;General&#39; and &#39;Global&#39; sound alike, but &#39;Global&#39; is specific to the linking mechanism."
      },
      {
        "question_text": "Global Operation Table",
        "misconception": "Targets word substitution: &#39;Operation&#39; is a plausible term in computing but incorrect for this specific table&#39;s function."
      },
      {
        "question_text": "Guard Offset Table",
        "misconception": "Targets concept conflation: &#39;Guard&#39; relates to memory protection, which is a different aspect of memory management."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The Global Offset Table (GOT) is a section in an executable or shared library that holds addresses of functions. When a program calls a function from a shared library, it looks up the function&#39;s address in the GOT. This mechanism allows shared libraries to be loaded at different memory addresses without recompiling the main program. Rootkits can &#39;overwrite GOT entries&#39; to redirect legitimate function calls to malicious code.",
      "distractor_analysis": "Distractors are designed to test precise recall. &#39;General Object Table&#39; uses a common synonym for &#39;Global&#39;. &#39;Global Operation Table&#39; substitutes &#39;Offset&#39; with &#39;Operation&#39;, which is a plausible but incorrect term. &#39;Guard Offset Table&#39; introduces a security-related term (&#39;Guard&#39;) that is not part of the correct acronym, conflating different memory protection concepts.",
      "analogy": "Think of the GOT as a phone book for shared library functions. When your program wants to call a function, it looks up the number (address) in the GOT. A rootkit overwriting a GOT entry is like someone changing a phone number in that book to redirect your call to a different, malicious party."
    },
    "code_snippets": [
      {
        "language": "c",
        "code": "extern void some_library_function();\n\nint main() {\n    some_library_function(); // This call will resolve via GOT\n    return 0;\n}",
        "context": "In C, calls to external library functions (like `some_library_function()`) are resolved at runtime using the Global Offset Table (GOT) to find the actual memory address of the function."
      }
    ],
    "difficulty": "advanced",
    "question_type": "definition",
    "prerequisites": [
      "ATTACK_EXPLOIT",
      "OS_LINUX",
      "DEFENSE_DETECT"
    ]
  },
  {
    "question_text": "What does LC_SYMTAB stand for in the context of Mach-O executable command structures?",
    "correct_answer": "Load Command Symbol Table",
    "distractors": [
      {
        "question_text": "Linker Command Symbol Table",
        "misconception": "Targets similar-sounding terms: &#39;Linker&#39; is related to executable processing but &#39;Load&#39; is the correct prefix for these commands."
      },
      {
        "question_text": "Local Command Symbol Table",
        "misconception": "Targets common abbreviation confusion: &#39;Local&#39; is a common meaning for &#39;LC&#39; but incorrect in this specific technical context."
      },
      {
        "question_text": "Library Command Symbol Table",
        "misconception": "Targets functional association: While symbol tables relate to libraries, &#39;Load Command&#39; is the precise expansion for &#39;LC&#39; here."
      }
    ],
    "detailed_explanation": {
      "core_logic": "In Mach-O executable formats, &#39;LC&#39; stands for &#39;Load Command&#39;. LC_SYMTAB specifically refers to the Load Command Symbol Table, which contains static symbols (functions, global variables) within an application. This information is crucial for memory forensics to detect code injection and data structure manipulation.",
      "distractor_analysis": "The distractors leverage common misinterpretations of &#39;LC&#39; (Linker Command, Local Command, Library Command) which are plausible given the context of executable files and their components, but &#39;Load Command&#39; is the precise and correct expansion for this specific structure.",
      "analogy": "Think of LC_SYMTAB as the executable&#39;s internal directory. Just as a library&#39;s catalog helps you find books, the symbol table helps forensic analysts find specific functions or variables within a running program."
    },
    "code_snippets": [],
    "difficulty": "advanced",
    "question_type": "definition",
    "prerequisites": [
      "OS_INTERNALS",
      "MALWARE_ANALYSIS",
      "DIGITAL_FORENSICS"
    ]
  }
]