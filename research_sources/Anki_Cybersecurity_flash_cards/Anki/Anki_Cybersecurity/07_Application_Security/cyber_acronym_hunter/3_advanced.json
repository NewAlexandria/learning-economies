[
  {
    "question_text": "In the context of program analysis and reverse engineering, what does the acronym &#39;AI&#39; refer to when discussing formalizing approximations of concrete behaviors?",
    "correct_answer": "Abstract Interpretation",
    "distractors": [
      {
        "question_text": "Artificial Intelligence",
        "misconception": "Targets common acronym confusion: AI is widely known as Artificial Intelligence, but in this specific context, it refers to a different concept."
      },
      {
        "question_text": "Automated Inference",
        "misconception": "Targets similar-sounding and related concepts: Automated Inference is a plausible technique in program analysis but not the precise term for formalizing approximations."
      },
      {
        "question_text": "Algorithmic Implementation",
        "misconception": "Targets general computing terms: Algorithmic Implementation is a generic term that doesn&#39;t capture the specific theoretical framework of approximation in program semantics."
      }
    ],
    "detailed_explanation": {
      "core_logic": "In program analysis, &#39;Abstract Interpretation&#39; is a theoretical framework for approximating the concrete semantics of computer programs. It allows for the static analysis of programs to determine properties that are generally undecidable, by creating a decidable approximation of the program&#39;s behavior.",
      "distractor_analysis": "The primary distractor leverages the extremely common &#39;Artificial Intelligence&#39; acronym, which is a strong lure for those with general tech knowledge but not specific to program analysis theory. &#39;Automated Inference&#39; is plausible as it relates to automated reasoning, but it&#39;s not the formal framework. &#39;Algorithmic Implementation&#39; is too generic and doesn&#39;t refer to the specific theoretical concept.",
      "analogy": "Think of Abstract Interpretation like creating a simplified, high-level map of a complex city. You can&#39;t see every street or building (concrete semantics), but you can still determine if a path from point A to point B is generally possible or if certain areas are off-limits (decidable approximation of properties)."
    },
    "code_snippets": [],
    "difficulty": "advanced",
    "question_type": "definition",
    "prerequisites": [
      "RE_FUNDAMENTALS",
      "PROGRAM_ANALYSIS"
    ]
  },
  {
    "question_text": "What does SMT stand for in the context of constraint solving for symbolic execution?",
    "correct_answer": "Satisfiability Modulo Theories",
    "distractors": [
      {
        "question_text": "Symbolic Model Testing",
        "misconception": "Targets similar-sounding terms: &#39;Symbolic&#39; and &#39;Testing&#39; are related to the context but not part of the exact expansion."
      },
      {
        "question_text": "Satisfiability Management Tool",
        "misconception": "Targets word substitution: &#39;Management&#39; and &#39;Tool&#39; are plausible but incorrect replacements for &#39;Modulo Theories&#39;."
      },
      {
        "question_text": "Systematic Model Transformation",
        "misconception": "Targets acronym letter confusion: &#39;Systematic&#39; and &#39;Transformation&#39; are plausible but incorrect interpretations of SMT letters."
      }
    ],
    "detailed_explanation": {
      "core_logic": "SMT solvers are used in symbolic execution to determine if a path constraint (a logical formula representing conditions for a program path) is satisfiable. They extend SAT (Satisfiability) solvers by adding support for theories like arithmetic, arrays, and bit-vectors, which are common in program analysis.",
      "distractor_analysis": "The distractors leverage terms that are conceptually related to symbolic execution (Symbolic, Testing, Management, Tool, Systematic, Transformation) but do not form the precise expansion of SMT, testing the student&#39;s exact recall of the acronym.",
      "analogy": "Think of an SMT solver as a super-powered logic puzzle solver. While a basic SAT solver can tell you if a set of true/false statements can all be true, an SMT solver can handle more complex puzzles involving numbers, lists, and other data types, which is essential for analyzing program logic."
    },
    "code_snippets": [
      {
        "language": "python",
        "code": "from z3 import *\n\ns = Solver()\nx = Int(&#39;x&#39;)\ny = Int(&#39;y&#39;)\n\ns.add(x &gt; 0, y &gt; 0, x + y == 5)\n\nif s.check() == sat:\n    m = s.model()\n    print(f&quot;x = {m[x]}, y = {m[y]}&quot;)\nelse:\n    print(&quot;No solution&quot;)",
        "context": "This Python snippet uses the Z3 SMT solver to find integer values for x and y that satisfy the given constraints, demonstrating a basic use case for SMT in program analysis."
      }
    ],
    "difficulty": "advanced",
    "question_type": "definition",
    "prerequisites": [
      "ATTACK_EXPLOIT",
      "RE_BASICS"
    ]
  }
]