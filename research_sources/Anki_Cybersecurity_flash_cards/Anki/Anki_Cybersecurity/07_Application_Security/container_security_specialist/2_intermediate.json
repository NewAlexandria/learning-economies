[
  {
    "question_text": "A Kubernetes application is found to be vulnerable to a Host header injection attack, allowing an attacker to manipulate internal routing. Which NetworkPolicy configuration would best mitigate this specific attack vector by restricting egress traffic based on the intended destination?",
    "correct_answer": "Egress NetworkPolicy allowing traffic only to specific internal service IPs or DNS names, and blocking external Host header manipulation attempts.",
    "distractors": [
      {
        "question_text": "Ingress NetworkPolicy denying all traffic from untrusted sources to the application pod.",
        "misconception": "Targets scope confusion: Students confuse ingress (inbound) with egress (outbound) traffic. Host header injection exploits how the application processes its *own* outbound requests or internal routing, not inbound access control."
      },
      {
        "question_text": "Egress NetworkPolicy allowing all traffic to the internet but blocking specific malicious IP addresses.",
        "misconception": "Targets incomplete mitigation: Students might think blocking known bad IPs is sufficient, but Host header injection often targets legitimate internal services or proxies. Allowing all internet egress is too permissive and doesn&#39;t address the internal routing manipulation."
      },
      {
        "question_text": "Pod Security Standard (PSS) Restricted profile applied to the application pod.",
        "misconception": "Targets control plane confusion: Students conflate application-layer vulnerabilities with pod security context settings. PSS focuses on container runtime security (e.g., capabilities, root user), not network traffic flow or HTTP header validation."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Host header injection typically involves an application making an outbound request or routing internally based on a manipulated Host header. An Egress NetworkPolicy is crucial here because it controls the *outbound* traffic from the vulnerable pod. By explicitly allowing egress only to known, legitimate internal service IPs or DNS names, and implicitly denying all other outbound connections, the policy prevents the application from being tricked into sending traffic to an attacker-controlled destination or an unintended internal service.",
      "distractor_analysis": "An Ingress NetworkPolicy controls incoming traffic to the pod, which is not directly relevant to mitigating an attack that leverages the application&#39;s *outbound* behavior based on a manipulated Host header. Allowing all internet egress, even with blacklisting, is too broad and doesn&#39;t prevent redirection to other internal services or proxies. The Pod Security Standard (PSS) Restricted profile focuses on container runtime security (e.g., preventing root execution, dropping capabilities) and does not directly address network traffic flow or HTTP header vulnerabilities.",
      "analogy": "Imagine a delivery driver (the application) who is given an address (Host header). If the address is manipulated, the driver might deliver a package to the wrong house. An Egress NetworkPolicy is like giving the driver a pre-approved list of houses they are allowed to deliver to, regardless of what address is written on the package. If the address isn&#39;t on the list, the delivery is blocked."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: restrict-egress-to-internal-services\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: vulnerable-app\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - ipBlock:\n            cidr: 10.0.0.0/8 # Example: Allow traffic to internal cluster network\n        - namespaceSelector: {}\n          podSelector:\n            matchLabels:\n              app: internal-api # Example: Allow traffic to specific internal API\n      ports:\n        - protocol: TCP\n          port: 80\n        - protocol: TCP\n          port: 443",
        "context": "Egress NetworkPolicy example restricting outbound traffic to specific internal IPs and services, preventing external Host header manipulation."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORKING",
      "NETWORK_POLICY_CONCEPTS",
      "HOST_HEADER_ATTACKS"
    ]
  },
  {
    "question_text": "A containerized application is found to be vulnerable to SQL injection due to improper input sanitization in its API. Which image scanning technique is most likely to detect this type of vulnerability?",
    "correct_answer": "Static Application Security Testing (SAST)",
    "distractors": [
      {
        "question_text": "Dynamic Application Security Testing (DAST)",
        "misconception": "Targets DAST vs. SAST confusion: Students might think DAST is better for all application vulnerabilities, but DAST requires a running application and active exploitation attempts, which is less direct for code-level flaws."
      },
      {
        "question_text": "Software Composition Analysis (SCA)",
        "misconception": "Targets SCA scope misunderstanding: Students might confuse application code vulnerabilities with third-party library vulnerabilities, which SCA focuses on."
      },
      {
        "question_text": "Container image vulnerability scanning (CVE scanning)",
        "misconception": "Targets general vulnerability scanning vs. application-specific: Students might think any image scanner will find it, but typical CVE scanners focus on OS packages and known library vulnerabilities, not custom application code flaws."
      }
    ],
    "detailed_explanation": {
      "core_logic": "SQL injection is a code-level vulnerability that arises from improper input sanitization within the application&#39;s source code. Static Application Security Testing (SAST) tools analyze the application&#39;s source code, bytecode, or binary code without executing it, specifically looking for patterns and constructs that indicate security flaws like SQL injection, cross-site scripting (XSS), and insecure direct object references (IDOR). This makes SAST the most effective technique for detecting such vulnerabilities early in the development lifecycle.",
      "distractor_analysis": "DAST (Dynamic Application Security Testing) analyzes a running application by simulating attacks, which can find SQL injection but is typically performed later in the lifecycle and might not pinpoint the exact line of code. SCA (Software Composition Analysis) focuses on identifying known vulnerabilities in third-party libraries and dependencies, not custom application code. General container image vulnerability scanning (CVE scanning) primarily checks for known Common Vulnerabilities and Exposures (CVEs) in operating system packages and installed software, not flaws in the application&#39;s proprietary code.",
      "analogy": "If your house has a structural flaw in its original blueprint (like a weak beam), SAST is like an architect reviewing the blueprints before construction to find it. DAST is like a building inspector testing the finished house for weaknesses. SCA is like checking if the lumber you bought has any defects from the supplier."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "attack",
    "prerequisites": [
      "CONTAINER_SECURITY_FUNDAMENTALS",
      "APPLICATION_SECURITY_TESTING",
      "SQL_INJECTION"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining new privileges that could lead to a container escape, even if it starts with some default capabilities?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing root execution with preventing privilege escalation. runAsNonRoot prevents the container from running as UID 0, but doesn&#39;t stop a non-root user from escalating privileges if allowed by other settings or capabilities."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete mitigation: Students might think setting privileged: false is sufficient. While it&#39;s crucial, it only prevents the container from running with all host capabilities; it doesn&#39;t explicitly prevent a container from escalating privileges from its *initial* set of capabilities."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might conflate filesystem immutability with privilege escalation prevention. readOnlyRootFilesystem prevents writing to the container&#39;s root filesystem but doesn&#39;t directly stop a process from gaining new privileges within the container or escaping to the host."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly controls whether a process inside a container can gain more privileges than its parent process. Specifically, it prevents a process from setting the `NO_NEW_PRIVS` flag, which is a critical defense against privilege escalation. This is distinct from starting as root or having certain capabilities; it prevents the *acquisition* of new privileges during runtime, making it highly effective against many container escape techniques.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, but a non-root user can still escalate privileges if `allowPrivilegeEscalation` is true and other conditions (like granted capabilities) permit. `privileged: false` prevents the container from having all host capabilities, but doesn&#39;t explicitly block privilege escalation from the capabilities it *does* have. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which is good for integrity but doesn&#39;t directly prevent a process from escalating privileges if it can execute code and leverage existing capabilities or kernel vulnerabilities.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a &#39;no promotion&#39; policy. Even if an employee (process) has some initial responsibilities (capabilities), they cannot gain new, higher-level responsibilities (privileges) without explicit approval. `runAsNonRoot` is like ensuring no one starts as CEO, but doesn&#39;t stop a regular employee from getting promoted if the &#39;no promotion&#39; policy isn&#39;t in place."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "A Pod definition demonstrating `allowPrivilegeEscalation: false` within the container&#39;s security context, combined with other hardening measures."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_TECHNIQUES",
      "POD_SECURITY_STANDARDS"
    ]
  },
  {
    "question_text": "A Kubernetes Pod running a database-backed application is configured with a `securityContext` that allows it to run as root and has `CAP_SYS_ADMIN` capability. The application&#39;s database user has `DROP TABLE` permissions. Which security control, if implemented, would best mitigate the blast radius of a successful SQL injection leading to a `DROP TABLE` command, even if prepared statements fail?",
    "correct_answer": "Revoke `DROP TABLE` permissions from the database user and grant only `SELECT` and `INSERT`.",
    "distractors": [
      {
        "question_text": "Set `securityContext.runAsNonRoot: true` for the Pod.",
        "misconception": "Targets scope misunderstanding: While `runAsNonRoot` is good practice, it prevents the container process from running as root *inside* the container, but doesn&#39;t directly prevent the database user (which is a separate concept from the container&#39;s OS user) from executing `DROP TABLE` if it has those database-level permissions."
      },
      {
        "question_text": "Implement a NetworkPolicy to restrict egress traffic from the Pod to only the database port.",
        "misconception": "Targets control plane confusion: NetworkPolicies control network communication, which is crucial for containing lateral movement. However, they do not prevent a database user with excessive permissions from executing destructive commands *within* the allowed database connection."
      },
      {
        "question_text": "Configure the Pod with `securityContext.capabilities.drop: [&quot;ALL&quot;]`.",
        "misconception": "Targets control type confusion: Dropping capabilities like `CAP_SYS_ADMIN` prevents container escapes and host-level privilege escalation. However, it does not directly control the permissions of a database user within the database itself, which is where the `DROP TABLE` command is executed."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The principle of least privilege dictates that the database user should only have the minimum permissions required for its function. If the application only needs to read and write data, granting `SELECT` and `INSERT` and revoking `DROP TABLE` permissions ensures that even if an SQL injection vulnerability is exploited and a `DROP TABLE` command is attempted, the database will deny it due to insufficient privileges. This directly limits the blast radius of the attack at the database level.",
      "distractor_analysis": "`runAsNonRoot: true` prevents the container&#39;s OS user from being root, but doesn&#39;t affect database user permissions. NetworkPolicies restrict network access but don&#39;t prevent authorized database commands. Dropping `CAP_SYS_ADMIN` prevents container escapes but doesn&#39;t control database-specific user permissions.",
      "analogy": "Imagine a bank teller. `runAsNonRoot` is like ensuring the teller isn&#39;t also the bank manager. A NetworkPolicy is like putting a bulletproof screen between the teller and customers. Dropping `CAP_SYS_ADMIN` is like taking away the teller&#39;s master key to the vault. But revoking `DROP TABLE` is like ensuring the teller&#39;s computer system literally doesn&#39;t have a &#39;delete all accounts&#39; button, regardless of who is logged in or what other security is in place."
    },
    "code_snippets": [
      {
        "language": "bash",
        "code": "CREATE USER natter_api_user PASSWORD &#39;secure_password&#39;;\nGRANT SELECT, INSERT ON spaces, messages TO natter_api_user;",
        "context": "SQL commands to create a restricted database user with least privilege"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "SQL_INJECTION_MITIGATION",
      "PRINCIPLE_OF_LEAST_PRIVILEGE",
      "DATABASE_PERMISSIONS"
    ]
  },
  {
    "question_text": "To limit the blast radius from a compromised frontend pod that should only communicate with a backend service in the same namespace, which NetworkPolicy configuration is most appropriate?",
    "correct_answer": "An Egress NetworkPolicy allowing traffic only to pods with the backend label in the same namespace",
    "distractors": [
      {
        "question_text": "An Ingress NetworkPolicy allowing traffic only from pods with the frontend label",
        "misconception": "Targets ingress vs. egress confusion: Students might focus on protecting the backend from external access (ingress to backend), but the question is about limiting the *compromised frontend&#39;s* outbound communication (egress from frontend)."
      },
      {
        "question_text": "A NetworkPolicy denying all egress traffic from the frontend pod",
        "misconception": "Targets over-restriction: While denying all egress is secure, it would break the legitimate communication with the backend service, making it impractical and not addressing the &#39;only communicate with backend&#39; requirement."
      },
      {
        "question_text": "A Cluster-wide NetworkPolicy denying all traffic between namespaces",
        "misconception": "Targets scope and specificity: Students might think broader policies are always better, but a cluster-wide policy is too broad and doesn&#39;t specifically address the frontend-to-backend communication within a namespace, nor does it allow the legitimate traffic."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To limit the blast radius from a compromised frontend pod, you need to control its *outbound* (egress) traffic. The policy should explicitly allow communication only to the intended backend service within the same namespace. An Egress NetworkPolicy with a `podSelector` targeting the backend service&#39;s label and a `namespaceSelector` (or implicitly, by not specifying one, restricting to the current namespace) achieves this by default denying all other outbound traffic.",
      "distractor_analysis": "An Ingress NetworkPolicy would control *incoming* traffic to the frontend, not its *outgoing* traffic after compromise. Denying all egress traffic would prevent the frontend from communicating with the legitimate backend service, breaking functionality. A cluster-wide policy denying all inter-namespace traffic is too broad and doesn&#39;t specifically address the frontend&#39;s egress to its backend within the same namespace, nor does it allow the legitimate traffic.",
      "analogy": "Imagine a security guard at a factory. An Egress NetworkPolicy is like telling a specific worker (the frontend pod) exactly which other departments (backend service) they are allowed to send packages to, and no one else. An Ingress policy would be about who can send packages *to* that worker."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: frontend-egress-to-backend\n  namespace: my-app\nspec:\n  podSelector:\n    matchLabels:\n      app: frontend\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              app: backend\n      ports:\n        - protocol: TCP\n          port: 8080 # Assuming backend listens on 8080",
        "context": "Kubernetes NetworkPolicy limiting egress from frontend to backend pod in the same namespace"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "NETWORK_SEGMENTATION"
    ]
  },
  {
    "question_text": "Which Pod Security Standard (PSS) profile would explicitly prevent a container from running with `hostPath` volume mounts?",
    "correct_answer": "Restricted",
    "distractors": [
      {
        "question_text": "Baseline",
        "misconception": "Targets partial understanding of PSS profiles: Students might know Baseline is more secure than Privileged but not realize it still permits hostPath volumes, which Restricted explicitly forbids."
      },
      {
        "question_text": "Privileged",
        "misconception": "Targets fundamental PSS misunderstanding: Students might incorrectly associate &#39;Privileged&#39; with stricter controls, or confuse it with the idea of &#39;privilege&#39; in general, when it&#39;s the least restrictive PSS profile."
      },
      {
        "question_text": "Unrestricted",
        "misconception": "Targets non-existent profile: Students might invent a profile name or confuse it with the absence of any PSS enforcement, not realizing it&#39;s not a defined PSS profile."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `Restricted` Pod Security Standard profile is designed to enforce current hardening best practices. It explicitly disallows features that allow host access, such as `hostPath` volumes, which can be used for container escapes or to access sensitive host files. The `Baseline` profile allows `hostPath` volumes, and the `Privileged` profile allows all capabilities and host access.",
      "distractor_analysis": "The `Baseline` profile permits `hostPath` volumes, so it would not prevent this. The `Privileged` profile is the least restrictive and allows all host access, including `hostPath` volumes. `Unrestricted` is not a defined Pod Security Standard profile.",
      "analogy": "If PSS profiles are like security levels for a building, `Privileged` is like having no security at all, `Baseline` is like having basic ID checks but still allowing visitors to bring in large bags, and `Restricted` is like airport security – strict checks, no large bags, and specific items are forbidden, including anything that could give you access to restricted areas (like `hostPath` volumes)."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: hostpath-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    volumeMounts:\n    - name: host-path-volume\n      mountPath: /host/path\n  volumes:\n  - name: host-path-volume\n    hostPath:\n      path: /var/log\n      type: DirectoryOrCreate",
        "context": "Example Pod manifest using a hostPath volume, which would be blocked by the Restricted PSS profile"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "definition",
    "prerequisites": [
      "POD_SECURITY_STANDARDS",
      "KUBERNETES_VOLUMES"
    ]
  },
  {
    "question_text": "A Kubernetes Pod is configured to run a web application. An attacker discovers that the application&#39;s error messages expose detailed stack traces and server version information. Which Pod Security Standard profile would explicitly prevent a deployment from running if it attempts to expose this type of sensitive information in its output?",
    "correct_answer": "None of the Pod Security Standards directly prevent application-level information leakage in error messages.",
    "distractors": [
      {
        "question_text": "Restricted",
        "misconception": "Targets scope misunderstanding: Students might assume &#39;Restricted&#39; covers all security aspects, including application-level output, but PSS focuses on Pod infrastructure security, not application logic."
      },
      {
        "question_text": "Baseline",
        "misconception": "Targets incomplete coverage: Students might think &#39;Baseline&#39; would catch this as a basic security hygiene, but PSS Baseline also focuses on infrastructure-level controls, not application output."
      },
      {
        "question_text": "Privileged",
        "misconception": "Targets inverse logic: Students might incorrectly associate &#39;Privileged&#39; with allowing all insecure practices, but it&#39;s about allowing host access, not dictating application output format."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Pod Security Standards (PSS) like Privileged, Baseline, and Restricted primarily focus on infrastructure-level security configurations for Pods, such as preventing privileged containers, restricting host access, managing capabilities, and enforcing non-root execution. They do not directly inspect or control the application&#39;s output content, error messages, or HTTP headers. Preventing information leakage in application error messages is an application-level security concern that must be addressed through secure coding practices, proper error handling, and API gateway configurations, not by PSS.",
      "distractor_analysis": "The Restricted PSS profile enforces the strongest security constraints on Pods, but these constraints are related to container runtime settings (e.g., `runAsNonRoot`, `allowPrivilegeEscalation: false`, dropping capabilities), not the content of application responses. The Baseline profile provides a moderately restrictive policy, also focused on runtime settings. The Privileged profile essentially imposes no restrictions, allowing full host access, but it still doesn&#39;t dictate application output. All PSS profiles operate at the Kubernetes infrastructure layer, not the application layer where information leakage in error messages occurs.",
      "analogy": "Pod Security Standards are like building codes for a house&#39;s foundation, walls, and roof – they ensure the structure is sound. Application-level security, like preventing information leakage in error messages, is akin to the interior design and furnishing choices – they determine what information is displayed inside the house. The building code doesn&#39;t dictate what pictures you hang on the walls."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "POD_SECURITY_STANDARDS",
      "APPLICATION_SECURITY_FUNDAMENTALS",
      "API_SECURITY_CONCEPTS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges through a `setuid` or `setgid` binary within the container?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing initial root execution with preventing privilege escalation from a non-root user. runAsNonRoot only ensures the container starts as non-root, but doesn&#39;t stop a non-root user from escalating if allowed."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets mechanism confusion: Students might think making the filesystem read-only prevents all privilege escalation. While it prevents modifying system binaries, it doesn&#39;t stop exploitation of existing setuid/setgid binaries or kernel vulnerabilities."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets incomplete understanding of privilege escalation vectors: While dropping capabilities is crucial, allowPrivilegeEscalation: false specifically addresses the `setuid` and `setgid` binary vector by preventing the `no_new_privs` flag from being unset, which is a distinct mechanism from capabilities."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting in a Kubernetes security context prevents a process from gaining more privileges than its parent process. Specifically, it ensures that the `no_new_privs` flag is set on the container process, which prevents the execution of `setuid` or `setgid` binaries from granting additional privileges. This is a direct and effective control against privilege escalation via these common Linux mechanisms.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container starts as a non-root user but doesn&#39;t prevent that non-root user from escalating privileges if a vulnerable `setuid` binary exists. `readOnlyRootFilesystem: true` makes the root filesystem immutable, which can prevent an attacker from installing new `setuid` binaries, but it won&#39;t stop the exploitation of existing ones. `capabilities.drop: [&quot;ALL&quot;]` removes all Linux capabilities, which is a strong security measure, but `allowPrivilegeEscalation: false` specifically targets the `setuid`/`setgid` binary vector by enforcing `no_new_privs`, which is a distinct and complementary control.",
      "analogy": "Imagine `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re in the building, you can&#39;t pick up a special key that lets you into restricted areas, even if you find one lying around.&#39; `runAsNonRoot: true` is just making sure you don&#39;t start with a master key. `readOnlyRootFilesystem: true` is like gluing down all the existing keys so they can&#39;t be moved or replaced, but if a key is already in a lock, it can still be turned."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      capabilities:\n        drop: [&quot;ALL&quot;]\n",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` within the security context."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGE_ESCALATION",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from performing actions that could lead to a container escape by exploiting dangerous Linux capabilities like `CAP_SYS_ADMIN`?",
    "correct_answer": "Dropping all capabilities (`capabilities.drop: [&quot;ALL&quot;]`)",
    "distractors": [
      {
        "question_text": "Setting `allowPrivilegeEscalation: false`",
        "misconception": "Targets partial understanding: Students might think `allowPrivilegeEscalation: false` prevents all privilege-related attacks, but it only prevents a process from gaining *more* privileges than its parent, not from using existing dangerous capabilities."
      },
      {
        "question_text": "Enabling `readOnlyRootFilesystem: true`",
        "misconception": "Targets scope confusion: Students might confuse filesystem immutability with capability control. `readOnlyRootFilesystem` prevents writing to the root filesystem but doesn&#39;t restrict the actions a process can take with its granted capabilities."
      },
      {
        "question_text": "Setting `runAsNonRoot: true`",
        "misconception": "Targets user vs. capability confusion: Students might believe running as a non-root user inherently prevents capability-based escapes. While good practice, a non-root user can still exploit dangerous capabilities if they are not dropped."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Linux capabilities allow granular control over privileges, breaking down the traditional root/non-root dichotomy. Dangerous capabilities like `CAP_SYS_ADMIN` can be abused to perform host-level operations, leading to container escapes. By explicitly dropping all capabilities (`capabilities.drop: [&quot;ALL&quot;]`), the container is stripped of these powerful privileges, significantly reducing the attack surface for capability-based escapes. This is a fundamental security control for container hardening.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but if the container already has dangerous capabilities, this setting won&#39;t remove them. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which is good for integrity but doesn&#39;t prevent a process with `CAP_SYS_ADMIN` from manipulating host resources. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, but even a non-root user can perform powerful actions if granted capabilities like `CAP_SYS_ADMIN`.",
      "analogy": "Imagine a security guard with a master key (root user) versus a guard with a specific toolset (capabilities). Dropping all capabilities is like taking away all the guard&#39;s tools, leaving them with only basic functions. `allowPrivilegeEscalation: false` is like preventing the guard from asking for *more* tools, but they still have their initial set. `readOnlyRootFilesystem: true` is like locking the guard&#39;s office door, but they can still use their tools outside. `runAsNonRoot: true` is like giving the guard a different uniform, but they might still have the same dangerous tools."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating dropping all capabilities for enhanced security."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "LINUX_CAPABILITIES",
      "CONTAINER_SECURITY_CONTEXTS",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "To prevent a compromised container from performing SQL injection attacks against an internal database, which network policy configuration is most effective in limiting the blast radius?",
    "correct_answer": "Egress NetworkPolicy allowing traffic only to the database&#39;s specific IP/port and denying all other external traffic.",
    "distractors": [
      {
        "question_text": "Ingress NetworkPolicy denying all traffic to the compromised container.",
        "misconception": "Targets direction confusion: Students confuse ingress (incoming) with egress (outgoing) traffic; an ingress policy prevents external access *to* the container, not *from* it to the database."
      },
      {
        "question_text": "Egress NetworkPolicy allowing traffic to all internal services within the same namespace.",
        "misconception": "Targets scope over-permissioning: Students might think limiting to the same namespace is sufficient, but it still allows broad access to other services in that namespace, potentially including other databases or sensitive services."
      },
      {
        "question_text": "Applying a Pod Security Standard (PSS) &#39;Restricted&#39; profile to the container.",
        "misconception": "Targets control plane confusion: Students conflate runtime security controls (PSS) with network segmentation; PSS prevents container runtime vulnerabilities but does not control network traffic flow."
      }
    ],
    "detailed_explanation": {
      "core_logic": "An Egress NetworkPolicy controls outgoing traffic from a pod. By explicitly allowing traffic only to the known IP address and port of the internal database and implicitly denying all other egress, you ensure that even if the container is compromised, it cannot reach other internal systems, external networks, or perform reconnaissance, thus significantly limiting the blast radius of a potential SQL injection or other data exfiltration attempt.",
      "distractor_analysis": "An Ingress NetworkPolicy controls incoming traffic to a pod, which is irrelevant for preventing a compromised pod from initiating outgoing attacks. Allowing traffic to all internal services in the same namespace is too broad and could still allow lateral movement to other sensitive services. Applying a PSS &#39;Restricted&#39; profile enhances runtime security by limiting capabilities and user IDs, but it does not govern network communication paths.",
      "analogy": "This is like giving a delivery driver a manifest with only one specific address (database IP/port) they are allowed to visit, and explicitly telling them they cannot go anywhere else. Even if they try to deviate, the policy prevents them from reaching unintended destinations."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: db-egress-policy\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: compromised-app\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - ipBlock:\n            cidr: 10.0.0.10/32 # Specific database IP\n      ports:\n        - protocol: TCP\n          port: 5432 # PostgreSQL port",
        "context": "Kubernetes Egress NetworkPolicy to restrict outgoing traffic to a specific database"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "NETWORK_SEGMENTATION",
      "SQL_INJECTION_PREVENTION"
    ]
  },
  {
    "question_text": "Which Pod Security Standard (PSS) profile would explicitly prevent a container from running with `CAP_SYS_ADMIN` capability, and why is this important for container security?",
    "correct_answer": "Restricted, because it disallows the use of most Linux capabilities, including `CAP_SYS_ADMIN`, which is often used for container escapes.",
    "distractors": [
      {
        "question_text": "Baseline, because it prevents known privilege escalations and dangerous capabilities.",
        "misconception": "Targets PSS profile misunderstanding: Students confuse Baseline with Restricted; Baseline allows many capabilities by default and does not explicitly forbid `CAP_SYS_ADMIN`."
      },
      {
        "question_text": "Privileged, because it allows full control over the host, making `CAP_SYS_ADMIN` redundant.",
        "misconception": "Targets inverse logic: Students might incorrectly assume &#39;Privileged&#39; means it handles capabilities securely, when it actually grants *all* capabilities and host access, which is the opposite of prevention."
      },
      {
        "question_text": "HostProcess, because it allows direct access to host resources, negating the need for capabilities.",
        "misconception": "Targets feature confusion: Students confuse HostProcess (Windows-specific, for running host processes) with Linux capabilities and PSS, which are distinct concepts."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The &#39;Restricted&#39; Pod Security Standard profile is designed for hardened security. It explicitly disallows the use of most Linux capabilities, including `CAP_SYS_ADMIN`. `CAP_SYS_ADMIN` is a highly dangerous capability that grants a wide range of administrative privileges, such as mounting filesystems, manipulating namespaces, and performing other actions that can lead to container escape or host compromise. Preventing its use is a critical step in securing containers.",
      "distractor_analysis": "The &#39;Baseline&#39; profile is less restrictive than &#39;Restricted&#39; and permits the use of many capabilities, including `CAP_SYS_ADMIN` by default unless explicitly dropped. The &#39;Privileged&#39; profile grants *all* capabilities and full host access, which is the opposite of preventing `CAP_SYS_ADMIN`. &#39;HostProcess&#39; is a Windows-specific feature for running processes directly on the host and is not related to Linux capabilities or PSS profiles for preventing `CAP_SYS_ADMIN`.",
      "analogy": "Think of PSS profiles as different levels of security clearance for a building. &#39;Restricted&#39; is like a visitor pass that only allows access to public areas and explicitly forbids entry to server rooms (where `CAP_SYS_ADMIN` actions happen). &#39;Baseline&#39; is like an employee pass that allows more access but still has some restrictions. &#39;Privileged&#39; is like having a master key to the entire building, including all restricted areas."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: policy.k8s.io/v1beta1\nkind: PodSecurityPolicy # Note: PSP is deprecated, but illustrates the concept\nmetadata:\n  name: restricted\nspec:\n  privileged: false\n  allowPrivilegeEscalation: false\n  requiredDropCapabilities:\n    - ALL\n  # ... other restricted settings\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: restricted-pod\n  labels:\n    pod-security.kubernetes.io/enforce: restricted # For Pod Security Admission\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true",
        "context": "Example of a Pod configured to meet the &#39;Restricted&#39; Pod Security Standard requirements, specifically dropping all capabilities."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "POD_SECURITY_STANDARDS",
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "A container image is found to contain a known vulnerability in a core library. Which image scanning technique is most effective at detecting this type of vulnerability?",
    "correct_answer": "Software Bill of Materials (SBOM) analysis combined with vulnerability database lookup.",
    "distractors": [
      {
        "question_text": "Static Application Security Testing (SAST) of the application code.",
        "misconception": "Targets scope confusion: Students confuse application code analysis with dependency analysis; SAST analyzes custom code, not pre-built library vulnerabilities within the image."
      },
      {
        "question_text": "Dynamic Application Security Testing (DAST) of the running container.",
        "misconception": "Targets runtime vs. build-time confusion: Students confuse runtime testing with image content analysis; DAST tests the running application&#39;s behavior, not the static composition of its underlying libraries."
      },
      {
        "question_text": "Runtime behavioral analysis and anomaly detection.",
        "misconception": "Targets detection vs. prevention: Students confuse post-deployment detection of malicious activity with pre-deployment identification of known vulnerabilities in components."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Detecting known vulnerabilities in core libraries within a container image is best achieved by generating a Software Bill of Materials (SBOM) for the image. An SBOM lists all components, dependencies, and their versions. This SBOM is then cross-referenced against public and private vulnerability databases (like CVEs) to identify any known security flaws in the included libraries. This is a build-time or pre-deployment scanning technique.",
      "distractor_analysis": "Static Application Security Testing (SAST) analyzes the source code of the *application* for vulnerabilities, not the pre-compiled libraries or operating system components within the image. Dynamic Application Security Testing (DAST) tests the *running* application for vulnerabilities by interacting with it, which is less effective for identifying known vulnerabilities in static library components. Runtime behavioral analysis detects anomalous activity *after* deployment, but the goal here is to detect the vulnerability *in the image* before it&#39;s run.",
      "analogy": "This is like checking the ingredients list (SBOM) of a packaged food item against a list of known allergens (vulnerability database) before you consume it. SAST would be like checking the recipe for errors, and DAST would be like tasting the food to see if it makes you sick."
    },
    "code_snippets": [
      {
        "language": "bash",
        "code": "trivy image --format cyclonedx --output sbom.json my-container-image:latest\ntrivy image my-container-image:latest",
        "context": "Example commands using Trivy to generate an SBOM and scan a container image for vulnerabilities."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "procedure",
    "prerequisites": [
      "CONTAINER_IMAGE_SCANNING",
      "SOFTWARE_BILL_OF_MATERIALS",
      "VULNERABILITY_MANAGEMENT"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges by exploiting vulnerabilities that require additional Linux capabilities?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing root execution with preventing privilege escalation. runAsNonRoot prevents the container from starting as root, but doesn&#39;t stop a non-root user from escalating privileges if allowed."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only prevents all privilege escalation, but it primarily prevents writing to the root filesystem, not gaining new capabilities or user IDs."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete protection: While &#39;privileged: false&#39; is good practice, it&#39;s the default and doesn&#39;t explicitly prevent privilege escalation from within the container if other capabilities are present or can be acquired. It prevents the container from running with all host capabilities."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly prevents a process in the container from gaining more privileges than its parent process. Specifically, it prevents a process from setting the `no_new_privs` flag, which is crucial for preventing privilege escalation attacks, especially those involving `setuid` or `setgid` binaries or acquiring new capabilities.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, but a non-root user can still escalate privileges if allowed. `readOnlyRootFilesystem: true` prevents modifications to the root filesystem but doesn&#39;t stop a process from gaining new capabilities. `privileged: false` is the default and prevents the container from having all host capabilities, but it doesn&#39;t explicitly block privilege escalation from within the container if it already has some capabilities or can acquire them.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a security guard who prevents anyone from getting a higher-level access badge once they&#39;re inside the building, regardless of their initial access level. Other settings might prevent them from entering with a master key (runAsNonRoot) or from writing on the walls (readOnlyRootFilesystem), but this one specifically blocks the act of upgrading their own access."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` within a security context, often combined with dropping capabilities for defense in depth."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "PRIVILEGE_ESCALATION_CONCEPTS"
    ]
  },
  {
    "question_text": "A Kubernetes cluster hosts multiple microservices on shared nodes. One microservice, `frontend-app`, is compromised and starts making outbound connections to known malicious IPs. To prevent this compromise from affecting other microservices on the same node and to limit its outbound communication, which network policy configuration is most appropriate?",
    "correct_answer": "An Egress NetworkPolicy applied to `frontend-app` that denies all outbound traffic except to whitelisted internal services and necessary external APIs.",
    "distractors": [
      {
        "question_text": "An Ingress NetworkPolicy applied to `frontend-app` that denies all inbound traffic except from the API Gateway.",
        "misconception": "Targets scope confusion: Students confuse Ingress (inbound) with Egress (outbound) traffic. While ingress control is good, it doesn&#39;t address the outbound malicious connections."
      },
      {
        "question_text": "A Cluster-wide NetworkPolicy that denies all traffic to known malicious IPs for all pods.",
        "misconception": "Targets over-permissioning/over-scoping: While denying traffic to malicious IPs is good, a cluster-wide policy might be too broad and difficult to manage, potentially blocking legitimate traffic for other applications if not carefully crafted. It also doesn&#39;t specifically isolate the compromised app."
      },
      {
        "question_text": "Applying `hostNetwork: false` to the `frontend-app` pod to prevent it from accessing the host&#39;s network interfaces.",
        "misconception": "Targets control plane confusion: Students confuse `hostNetwork` (which is false by default and prevents direct host network access) with NetworkPolicy. `hostNetwork: false` is a good practice but doesn&#39;t control pod-to-pod or pod-to-external traffic at the policy level."
      }
    ],
    "detailed_explanation": {
      "core_logic": "When a microservice is compromised and initiates outbound connections to malicious IPs, the primary concern is to contain its ability to communicate externally and potentially spread the attack or exfiltrate data. An Egress NetworkPolicy specifically controls outbound traffic from a pod. By denying all outbound traffic by default and only allowing explicitly whitelisted connections (e.g., to internal services, databases, and legitimate external APIs), the blast radius of the compromised `frontend-app` is significantly limited. This aligns with the principle of least privilege for network communication.",
      "distractor_analysis": "An Ingress NetworkPolicy controls inbound traffic, which is important for protecting the service but does not address the outbound malicious connections. A cluster-wide policy to deny malicious IPs is a good general security measure, but it&#39;s not specific to isolating the compromised application and might be harder to manage or prone to false positives if not extremely precise. `hostNetwork: false` is the default and prevents a pod from using the host&#39;s network namespace directly, but it doesn&#39;t provide granular control over the pod&#39;s own network traffic, which is what NetworkPolicy does.",
      "analogy": "Imagine a compromised employee in an office building. An Egress NetworkPolicy is like restricting that employee&#39;s phone calls and emails to only approved contacts and services, preventing them from contacting external malicious parties. An Ingress policy would be like controlling who can enter their office, which is also important but doesn&#39;t stop them from making outbound calls."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: frontend-app-egress-policy\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: frontend-app\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - podSelector: {}\n      ports:\n        - protocol: TCP\n          port: 80\n        - protocol: TCP\n          port: 443\n    - to:\n        - ipBlock:\n            cidr: 10.0.0.0/8 # Example: Allow internal network access\n    # Deny all other egress by default (implicit if no other rules match)",
        "context": "Kubernetes Egress NetworkPolicy to restrict outbound traffic for a specific microservice."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "MICROSERVICE_SECURITY",
      "CONTAINER_COMPROMISE_MITIGATION"
    ]
  },
  {
    "question_text": "A Kubernetes cluster administrator wants to prevent any container from gaining new privileges after it starts, specifically to mitigate container escape attempts that rely on privilege escalation. Which securityContext setting directly addresses this requirement?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "privileged: false",
        "misconception": "Targets scope misunderstanding: Students confuse &#39;privileged&#39; mode (which grants all capabilities and host access) with &#39;privilege escalation&#39; (gaining new privileges from existing ones). Setting privileged: false is a good practice but doesn&#39;t specifically prevent escalation if other capabilities are present."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets concept conflation: Students confuse preventing a container from running as root with preventing privilege escalation. runAsNonRoot prevents starting as UID 0, but a non-root user can still attempt to escalate privileges if allowed by capabilities or other misconfigurations."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only prevents all forms of privilege escalation. While it limits some attack vectors (e.g., writing to system binaries), it doesn&#39;t prevent escalation via kernel exploits or capability abuse if the process already has those capabilities."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting in a container&#39;s security context directly controls whether a process can gain more privileges than its parent process. Specifically, it prevents a process from setting the `NO_NEW_PRIVS` flag and prevents the `execve` system call from granting new privileges. This is a critical control against container escape techniques that rely on exploiting vulnerabilities to escalate privileges within the container to gain host access.",
      "distractor_analysis": "`privileged: false` prevents the container from running in privileged mode, which grants all Linux capabilities and direct host access. While important, it doesn&#39;t specifically prevent a non-privileged container from escalating privileges if it has certain capabilities. `runAsNonRoot: true` ensures the container does not run as UID 0 (root), but a non-root user can still attempt privilege escalation. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which helps prevent tampering but doesn&#39;t directly block privilege escalation attempts that don&#39;t involve writing to the root filesystem.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re inside the building, you cannot get a higher security clearance than you currently have.&#39; Even if you have some access (capabilities), you can&#39;t use them to get more. `privileged: false` is like not giving you the master key in the first place. `runAsNonRoot: true` is like saying &#39;you can&#39;t be the CEO.&#39; `readOnlyRootFilesystem: true` is like making sure the building&#39;s blueprints can&#39;t be changed."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: no-priv-escalation-pod\nspec:\n  containers:\n  - name: my-container\n    image: nginx\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` within a security context, often combined with dropping capabilities and running as non-root for robust defense."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "A Kubernetes cluster running in Azure needs to restrict egress traffic from a specific Pod to only allow connections to an external database service on port 5432. Which Kubernetes network policy configuration, combined with Azure Network Security Groups, effectively enforces this rule?",
    "correct_answer": "A Kubernetes NetworkPolicy with an Egress rule specifying the database IP/port and an Azure NSG on the AKS subnet allowing outbound traffic to the database IP/port.",
    "distractors": [
      {
        "question_text": "An Azure Network Security Group (NSG) on the AKS subnet with an outbound rule allowing port 5432 to the database IP, without a Kubernetes NetworkPolicy.",
        "misconception": "Targets scope confusion: Students might believe NSGs alone are sufficient for granular pod-level control, but NSGs operate at the subnet/NIC level and cannot differentiate between pods within the same subnet."
      },
      {
        "question_text": "A Kubernetes NetworkPolicy with an Egress rule specifying the database IP/port, and an Azure NSG on the Pod&#39;s specific NIC allowing all outbound traffic.",
        "misconception": "Targets incomplete defense-in-depth: Students might think a NetworkPolicy is enough, but if the NSG is too permissive, it creates a bypass for traffic not explicitly blocked by the NetworkPolicy, especially for non-Kubernetes traffic from the VM."
      },
      {
        "question_text": "A Kubernetes NetworkPolicy with an Ingress rule blocking all traffic except to the database, and an Azure NSG on the AKS subnet allowing all outbound traffic.",
        "misconception": "Targets rule direction and scope error: Students confuse Ingress (incoming) with Egress (outgoing) rules and misunderstand that NSGs on the subnet still need to be restrictive for outbound traffic, even if a NetworkPolicy exists."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To restrict egress traffic from a specific Pod to an external database, a multi-layered approach is required. The Kubernetes NetworkPolicy provides granular, pod-level control within the cluster, ensuring that only the specified Pod can initiate connections to the database IP and port. However, Kubernetes NetworkPolicies only apply to traffic within the cluster&#39;s network. For traffic leaving the AKS subnet to an external service, an Azure Network Security Group (NSG) is necessary. The NSG, applied at the AKS subnet level, acts as a firewall for all traffic entering and leaving that subnet. By configuring both the NetworkPolicy and the NSG with the specific egress rule (allowing port 5432 to the database IP), you achieve defense-in-depth, ensuring that both internal Kubernetes controls and external Azure network controls enforce the desired traffic restriction.",
      "distractor_analysis": "1. An NSG alone on the AKS subnet cannot differentiate between individual pods; it applies to all resources within that subnet. Thus, it cannot enforce a rule for a &#39;specific Pod&#39; without affecting others. 2. An NSG on the Pod&#39;s specific NIC (if applicable, though AKS typically uses shared NICs for nodes) allowing all outbound traffic would negate the purpose of the NetworkPolicy for external traffic, as the NSG would permit any outbound connection, bypassing the NetworkPolicy&#39;s intent for external services. 3. An Ingress rule on a NetworkPolicy controls incoming traffic, not outgoing (egress). Allowing all outbound traffic on the NSG would also defeat the purpose of restricting egress to the database.",
      "analogy": "Think of the Kubernetes NetworkPolicy as a security guard inside a specific office (the Pod) who only allows calls to a specific external phone number (the database). The Azure NSG is like the building&#39;s main security gate, which also needs to be configured to only allow calls to that specific external number from anyone inside the building. Both layers must be in place and correctly configured for the restriction to be effective."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-db-egress\n  namespace: my-app-namespace\nspec:\n  podSelector:\n    matchLabels:\n      app: my-pod\n  policyTypes:\n  - Egress\n  egress:\n  - to:\n    - ipBlock:\n        cidr: 10.0.0.10/32 # External database IP\n    ports:\n    - protocol: TCP\n      port: 5432",
        "context": "Kubernetes NetworkPolicy to restrict egress from a specific pod to an external database."
      },
      {
        "language": "bash",
        "code": "az network nsg rule create \\\n  --resource-group my-aks-rg \\\n  --nsg-name my-aks-nsg \\\n  --name AllowDBEgress \\\n  --priority 100 \\\n  --direction Outbound \\\n  --access Allow \\\n  --protocol Tcp \\\n  --source-address-prefixes &#39;*&#39; \\\n  --source-port-ranges &#39;*&#39; \\\n  --destination-address-prefixes 10.0.0.10 \\\n  --destination-port-ranges 5432",
        "context": "Azure CLI command to create an NSG rule allowing outbound traffic to the external database IP and port from the AKS subnet."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "AZURE_NETWORK_SECURITY_GROUPS",
      "DEFENSE_IN_DEPTH_PRINCIPLES"
    ]
  },
  {
    "question_text": "An attacker has gained control of a container within a Kubernetes Pod and is attempting to perform network reconnaissance against other pods in the same namespace. Which NetworkPolicy configuration would effectively limit the blast radius by preventing outbound connections from the compromised pod to other internal pods, while still allowing necessary ingress traffic?",
    "correct_answer": "An egress NetworkPolicy applied to the compromised pod&#39;s namespace, denying all outbound traffic by default and explicitly allowing only required connections to external services.",
    "distractors": [
      {
        "question_text": "An ingress NetworkPolicy applied to the compromised pod, denying all inbound traffic from other internal pods.",
        "misconception": "Targets scope and direction confusion: Students might confuse ingress with egress, or believe denying ingress to the target pods will prevent outbound from the source. This only prevents traffic *to* the compromised pod, not *from* it."
      },
      {
        "question_text": "A default deny-all ingress NetworkPolicy for the entire cluster, with explicit allows for all legitimate traffic.",
        "misconception": "Targets over-scoping: While a good security practice, a cluster-wide deny-all ingress policy is too broad for limiting a single compromised pod&#39;s egress. It also doesn&#39;t directly address outbound traffic from the compromised pod."
      },
      {
        "question_text": "Applying `hostNetwork: false` in the pod&#39;s security context to prevent host-level network access.",
        "misconception": "Targets control plane confusion: Students might confuse network policies with pod security contexts. `hostNetwork: false` prevents the pod from using the host&#39;s network namespace, but does not control inter-pod communication within the cluster network."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To limit the blast radius from a compromised pod performing network reconnaissance, an egress NetworkPolicy is required. By applying a default deny-all egress policy to the namespace containing the compromised pod, all outbound connections from pods in that namespace are blocked. Specific rules can then be added to allow only legitimate outbound traffic (e.g., to external APIs, databases, or other necessary services), effectively preventing unauthorized reconnaissance or lateral movement to other internal pods.",
      "distractor_analysis": "An ingress NetworkPolicy on the compromised pod would only prevent traffic *to* it, not *from* it. A cluster-wide deny-all ingress policy is overly broad for this specific problem and doesn&#39;t address the egress from the compromised pod. `hostNetwork: false` is a security context setting that isolates the pod from the host&#39;s network, but it does not control traffic between pods within the Kubernetes cluster network, which is the domain of NetworkPolicies.",
      "analogy": "Imagine a security guard (NetworkPolicy) at the exit of a building (namespace). To stop a suspicious person (compromised pod) from leaving and exploring other buildings (other pods), the guard must be instructed to block all exits (default deny egress) and only allow authorized personnel to leave through specific doors (explicit allow rules)."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-all-egress\n  namespace: compromised-app\nspec:\n  podSelector: {}\n  policyTypes:\n  - Egress\n  egress: [] # Denies all egress by default\n---\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-external-egress\n  namespace: compromised-app\nspec:\n  podSelector: {}\n  policyTypes:\n  - Egress\n  egress:\n  - to:\n    - ipBlock:\n        cidr: 0.0.0.0/0\n        except:\n        - 10.0.0.0/8 # Example: Exclude internal cluster CIDR\n    ports:\n    - protocol: TCP\n      port: 443",
        "context": "NetworkPolicy to deny all egress by default and then explicitly allow necessary external connections from a namespace."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "CONTAINER_SECURITY_FUNDAMENTALS",
      "BLAST_RADIUS_REDUCTION"
    ]
  },
  {
    "question_text": "A Kubernetes pod is configured with `privileged: true`. Which Pod Security Standard (PSS) profile would explicitly prevent this configuration from being deployed?",
    "correct_answer": "Restricted",
    "distractors": [
      {
        "question_text": "Baseline",
        "misconception": "Targets misunderstanding of PSS tiers: Students might think Baseline is strict enough to block privileged containers, but it allows some potentially dangerous capabilities and privileged mode is not explicitly forbidden."
      },
      {
        "question_text": "Privileged",
        "misconception": "Targets confusion about PSS naming: Students might incorrectly associate the &#39;Privileged&#39; PSS profile with preventing privileged containers, when in fact, this profile allows all capabilities and privileged mode."
      },
      {
        "question_text": "HostPath",
        "misconception": "Targets conflation of PSS with specific security contexts: Students might confuse a specific security context setting (like HostPath volumes) with a PSS profile name, indicating a lack of understanding of PSS categories."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `privileged: true` setting grants a container all capabilities on the host, effectively removing all security protections and allowing direct access to host resources. The Restricted Pod Security Standard profile explicitly disallows `privileged: true` as it is considered a high-risk configuration that can lead to container escapes and host compromise. This standard enforces strict hardening best practices.",
      "distractor_analysis": "The Baseline PSS profile allows `privileged: true` and focuses on preventing known privilege escalations. The Privileged PSS profile explicitly allows all capabilities and `privileged: true`, making it the least restrictive. &#39;HostPath&#39; is a type of volume mount, not a Pod Security Standard profile.",
      "analogy": "If PSS profiles were security levels for a building, &#39;Privileged&#39; would be &#39;no security, open doors&#39;, &#39;Baseline&#39; would be &#39;basic locks on doors&#39;, and &#39;Restricted&#39; would be &#39;multi-factor authentication, no master keys, and limited access to sensitive areas&#39;."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: privileged-pod\nspec:\n  containers:\n  - name: my-container\n    image: busybox\n    command: [&quot;sleep&quot;, &quot;3600&quot;]\n    securityContext:\n      privileged: true",
        "context": "Example of a Kubernetes Pod configuration that would be blocked by the Restricted Pod Security Standard profile."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_BASICS",
      "POD_SECURITY_STANDARDS",
      "CONTAINER_SECURITY_CONTEXTS"
    ]
  },
  {
    "question_text": "To limit the blast radius of a compromised front-end application container, which Kubernetes NetworkPolicy configuration effectively restricts its outbound traffic to only a specific database service within the same namespace?",
    "correct_answer": "An egress NetworkPolicy with a podSelector matching the database service and a port for the database protocol.",
    "distractors": [
      {
        "question_text": "An ingress NetworkPolicy allowing traffic only from the front-end application container.",
        "misconception": "Targets scope confusion: Students confuse ingress (inbound) with egress (outbound) traffic control; an ingress policy would not restrict the compromised container&#39;s outbound connections."
      },
      {
        "question_text": "A NetworkPolicy with a namespaceSelector targeting only the database&#39;s namespace.",
        "misconception": "Targets granularity misunderstanding: Students might think namespaceSelector is sufficient, but it&#39;s too broad for restricting to a specific service within a namespace and doesn&#39;t specify outbound direction."
      },
      {
        "question_text": "Applying a securityContext with `allowPrivilegeEscalation: false` to the front-end container.",
        "misconception": "Targets control plane confusion: Students conflate security contexts (container-level runtime security) with network policies (network-level traffic control); security contexts do not manage network traffic flow."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To limit outbound traffic from a compromised container, an egress NetworkPolicy is required. This policy should specify the source (the compromised front-end container, typically via a podSelector) and the destination (the database service, also via a podSelector and the specific port it listens on). This ensures the front-end can only initiate connections to the intended database and no other internal or external services, thus minimizing the impact of a compromise.",
      "distractor_analysis": "An ingress NetworkPolicy controls inbound traffic to a pod, not outbound traffic from it. A NetworkPolicy with a namespaceSelector would restrict traffic to an entire namespace, which is too broad if the goal is to restrict to a specific service within that namespace, and it doesn&#39;t inherently define egress. Applying a securityContext like `allowPrivilegeEscalation: false` is a runtime security control for the container itself, preventing privilege escalation, but it does not govern network traffic flow.",
      "analogy": "Imagine a security guard (NetworkPolicy) at the exit door of a room (the front-end container). An egress policy tells the guard exactly which other rooms (database service) the person leaving the room is allowed to visit. An ingress policy would be a guard at the entrance, controlling who can come in, which is not the problem here."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: frontend-egress-to-db\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: frontend\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              app: database\n      ports:\n        - protocol: TCP\n          port: 5432 # Example PostgreSQL port",
        "context": "Kubernetes NetworkPolicy to restrict egress from &#39;frontend&#39; pods to &#39;database&#39; pods on a specific port."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORKING",
      "NETWORK_POLICY_CONCEPTS",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "To prevent a containerized application from making unauthorized outbound connections to external malicious IP addresses, which Kubernetes network policy configuration is most effective?",
    "correct_answer": "An Egress NetworkPolicy that explicitly denies traffic to a list of known malicious IPs and allows only necessary outbound connections.",
    "distractors": [
      {
        "question_text": "An Ingress NetworkPolicy that only allows traffic from specific internal services.",
        "misconception": "Targets scope confusion: Students confuse Ingress (incoming) with Egress (outgoing) traffic. An Ingress policy controls what can connect to the pod, not what the pod can connect to."
      },
      {
        "question_text": "Setting `hostNetwork: false` in the Pod&#39;s security context.",
        "misconception": "Targets control plane confusion: Students conflate hostNetwork setting (which isolates the pod from the host network namespace) with NetworkPolicy (which controls traffic flow within the cluster network). hostNetwork: false is a good practice but doesn&#39;t define outbound rules."
      },
      {
        "question_text": "Using `securityContext.allowPrivilegeEscalation: false` to prevent outbound connections.",
        "misconception": "Targets unrelated control: Students incorrectly link privilege escalation prevention with network egress control. `allowPrivilegeEscalation` prevents a process from gaining more privileges than its parent, not from making network connections."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Controlling outbound traffic from a pod is achieved using an Egress NetworkPolicy. This policy type specifies rules for traffic leaving the pod. By explicitly denying connections to known malicious IP addresses and only allowing necessary outbound connections (e.g., to specific services or external APIs), you implement a &#39;default deny&#39; posture for egress, significantly reducing the risk of data exfiltration or command-and-control communication.",
      "distractor_analysis": "An Ingress NetworkPolicy controls incoming traffic to a pod, not outgoing. Setting `hostNetwork: false` isolates the pod from the host&#39;s network namespace but does not define rules for traffic leaving the pod&#39;s own network namespace. `securityContext.allowPrivilegeEscalation: false` is a security context setting that prevents a process from gaining more privileges than its parent; it has no direct bearing on network egress rules.",
      "analogy": "Think of an Egress NetworkPolicy as a bouncer at the exit of a club. It checks everyone leaving to ensure they are allowed to go to specific places and prevents them from going to known dangerous locations. An Ingress policy would be the bouncer at the entrance, checking who is allowed to come in."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-malicious-egress\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: my-app\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - ipBlock:\n            cidr: 0.0.0.0/0\n            except:\n              - 10.0.0.0/8\n              - 172.16.0.0/12\n              - 192.168.0.0/16\n              - 1.2.3.4/32 # Example of a known malicious IP to block\n      ports:\n        - protocol: TCP\n          port: 80\n        - protocol: TCP\n          port: 443\n    - to: # Allow specific internal services\n        - podSelector:\n            matchLabels:\n              app: internal-service\n      ports:\n        - protocol: TCP\n          port: 8080",
        "context": "Kubernetes NetworkPolicy demonstrating egress control to block malicious IPs and allow specific outbound traffic."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORKING",
      "NETWORK_POLICIES",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which Kubernetes NetworkPolicy configuration would prevent a compromised frontend application pod from initiating connections to a backend database pod in a different namespace, assuming the database only accepts connections from its own namespace?",
    "correct_answer": "An Egress NetworkPolicy on the frontend pod&#39;s namespace, denying traffic to the database pod&#39;s namespace.",
    "distractors": [
      {
        "question_text": "An Ingress NetworkPolicy on the database pod&#39;s namespace, allowing traffic only from its own namespace.",
        "misconception": "Targets scope confusion: While this policy would protect the database, it doesn&#39;t prevent the *frontend* from attempting to initiate the connection (egress). The question asks how to prevent the frontend from initiating the connection, not just how to protect the database from unwanted ingress."
      },
      {
        "question_text": "A default Deny All Egress NetworkPolicy on the frontend pod&#39;s namespace, with specific rules to allow necessary external traffic.",
        "misconception": "Targets over-restriction vs. specific targeting: While a default deny egress is a strong security posture, it&#39;s a broader solution than specifically targeting the cross-namespace communication. The question implies a targeted prevention of a specific attack vector, not a complete egress lockdown."
      },
      {
        "question_text": "An Ingress NetworkPolicy on the frontend pod, denying all incoming connections.",
        "misconception": "Targets direction confusion: An Ingress policy controls incoming traffic to the frontend, not outgoing traffic from it. This would prevent users from accessing the frontend but wouldn&#39;t stop the frontend from trying to connect to the database."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To prevent a compromised frontend pod from initiating connections to a backend database in a different namespace, an Egress NetworkPolicy must be applied to the frontend&#39;s namespace. This policy would explicitly deny outgoing traffic from pods in the frontend&#39;s namespace to pods in the database&#39;s namespace. This directly addresses the &#39;blast radius&#39; limitation by controlling what the compromised pod can reach.",
      "distractor_analysis": "An Ingress NetworkPolicy on the database&#39;s namespace would protect the database, but it wouldn&#39;t prevent the frontend from *attempting* the connection, which is what the question asks to prevent from the frontend&#39;s perspective. A default Deny All Egress is a good practice but is a broader solution than specifically targeting the cross-namespace communication. An Ingress NetworkPolicy on the frontend only controls incoming traffic, not outgoing.",
      "analogy": "Imagine the frontend pod as a person in a room. An Egress NetworkPolicy is like locking the doors *from the inside* to prevent that person from leaving to specific other rooms (namespaces). An Ingress policy on the database is like locking the doors *from the outside* of the database&#39;s room, which protects the database but doesn&#39;t stop the person in the frontend room from trying to open their door and go there."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-egress-to-db-namespace\n  namespace: frontend-ns\nspec:\n  podSelector: {}\n  policyTypes:\n  - Egress\n  egress:\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          name: backend-ns\n    ports: [] # Deny all ports to this namespace",
        "context": "Egress NetworkPolicy in the frontend namespace to deny all traffic to the backend namespace."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "NAMESPACE_ISOLATION",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "A Kubernetes application is deployed with a web server container that processes untrusted user input. To prevent directory traversal attacks where an attacker tries to access files outside the intended web root, which security context setting is most directly effective?",
    "correct_answer": "readOnlyRootFilesystem: true",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope confusion: Students might think preventing privilege escalation also prevents file system access, but it&#39;s about gaining higher privileges, not restricting file system navigation."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets user vs. file system confusion: While good practice, running as non-root prevents root user actions, but doesn&#39;t inherently restrict a non-root user from traversing directories they have access to within the container&#39;s filesystem."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets capability relevance: Students might overgeneralize capabilities. Dropping capabilities restricts privileged operations, but directory traversal is often a logical flaw in the application, not directly tied to Linux capabilities."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Directory traversal attacks exploit vulnerabilities in web applications to access files and directories stored outside the web root folder. Setting `readOnlyRootFilesystem: true` in the container&#39;s security context makes the container&#39;s root filesystem immutable. This prevents the attacker from writing to or modifying existing files outside the intended web root, and while it doesn&#39;t prevent reading, it significantly limits the impact of such an attack by preventing data modification or planting malicious files.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but doesn&#39;t directly restrict file system navigation. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, which is good for general security but doesn&#39;t prevent a non-root user from traversing directories they have read access to. `capabilities.drop: [&quot;ALL&quot;]` removes all Linux capabilities, which is a strong security measure, but directory traversal is primarily an application-level vulnerability, not directly mitigated by capability restrictions unless the traversal leads to a privileged operation that requires a capability.",
      "analogy": "Imagine a library where books are organized in specific sections. Directory traversal is like someone finding a loophole to access books from a restricted section. `readOnlyRootFilesystem: true` is like making all the shelves and books in the library permanently fixed in place, so even if someone finds a loophole, they can&#39;t move or replace any books, only read what&#39;s already there."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: web-server-pod\nspec:\n  containers:\n  - name: web-app\n    image: my-web-app:latest\n    securityContext:\n      readOnlyRootFilesystem: true\n    volumeMounts:\n    - name: web-root\n      mountPath: /var/www/html\n  volumes:\n  - name: web-root\n    emptyDir: {}",
        "context": "Kubernetes Pod definition with readOnlyRootFilesystem enabled for the web server container, mounting a separate volume for writable content."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "WEB_APPLICATION_VULNERABILITIES",
      "CONTAINER_FILESYSTEMS"
    ]
  },
  {
    "question_text": "A containerized web application is found to have an exposed `/admin` directory due to a misconfigured NGINX server, allowing unauthorized access. Which Kubernetes NetworkPolicy configuration would effectively limit the blast radius by preventing external access to this specific path while allowing internal application traffic?",
    "correct_answer": "An Egress NetworkPolicy allowing traffic to internal services, and an Ingress NetworkPolicy denying traffic to `/admin` path for external sources.",
    "distractors": [
      {
        "question_text": "An Ingress NetworkPolicy allowing all traffic from the `frontend` namespace to the web application pod.",
        "misconception": "Targets scope misunderstanding: This policy is too broad; it allows all traffic from a specific namespace, not just internal application traffic, and doesn&#39;t specifically block the vulnerable path from external sources."
      },
      {
        "question_text": "A Pod Security Policy (PSP) preventing the web application pod from running as root.",
        "misconception": "Targets control plane confusion: PSPs (now deprecated) and Pod Security Standards control pod creation and runtime behavior, not network traffic flow or specific URL path access."
      },
      {
        "question_text": "Setting `securityContext.readOnlyRootFilesystem: true` for the web application container.",
        "misconception": "Targets irrelevant control: `readOnlyRootFilesystem` prevents writing to the container&#39;s root filesystem, which is a good security practice but has no bearing on network access to specific URL paths."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To limit the blast radius from an exposed `/admin` directory, a NetworkPolicy needs to control network traffic. An Ingress NetworkPolicy can be configured to deny external traffic specifically to the `/admin` path (if the ingress controller supports path-based rules, or by targeting the service/pod if the path is handled by a dedicated service). An Egress NetworkPolicy ensures the application can still communicate with necessary internal services, adhering to the principle of least privilege for network communication. This combination ensures that while internal components can interact, the vulnerable path is shielded from external attackers.",
      "distractor_analysis": "Allowing all traffic from a `frontend` namespace is too permissive and doesn&#39;t address the specific `/admin` path vulnerability from external sources. Pod Security Policies (or Pod Security Standards) are for controlling pod runtime security, not network traffic. `readOnlyRootFilesystem` prevents file system modifications, which is unrelated to network path access control.",
      "analogy": "Imagine a building with a vulnerable back door. An Egress NetworkPolicy is like allowing employees to use internal hallways to reach other offices. An Ingress NetworkPolicy is like putting a guard at the back door to prevent unauthorized external access, specifically to that door, while still allowing authorized visitors through the main entrance."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-external-admin-access\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: web-app\n  policyTypes:\n    - Ingress\n  ingress:\n    - from:\n        - ipBlock:\n            cidr: 0.0.0.0/0\n            except:\n              - 10.0.0.0/8 # Allow internal cluster traffic\n      ports:\n        - protocol: TCP\n          port: 80\n      # Note: Path-based blocking typically handled by Ingress Controller or Service Mesh\n      # This policy would deny all external traffic unless explicitly allowed for other paths\n      # A more granular solution might involve an Ingress Controller rule or a service mesh policy.\n\n---\n\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-internal-egress\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: web-app\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - podSelector: {}\n          namespaceSelector: {}\n      ports:\n        - protocol: TCP\n          port: 8080 # Example: Allow egress to internal database on port 8080\n",
        "context": "Example NetworkPolicy to restrict external ingress and allow specific internal egress. Note that path-based blocking is often handled by an Ingress Controller or Service Mesh, not directly by Kubernetes NetworkPolicy."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "WEB_APPLICATION_SECURITY",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "Which container security context setting is primarily designed to prevent a container from executing arbitrary code by limiting its ability to write to sensitive memory regions, thereby mitigating buffer overflow exploits?",
    "correct_answer": "readOnlyRootFilesystem: true",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope confusion: Students might confuse preventing privilege escalation (gaining higher privileges) with preventing arbitrary code execution via memory corruption. While related to security, it doesn&#39;t directly address the writeability of memory regions."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets user context confusion: Students might think running as a non-root user inherently prevents buffer overflows. While good practice, a non-root user can still trigger a buffer overflow if the application is vulnerable and has write access to the overflowed buffer."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets capability misunderstanding: Students might believe dropping all capabilities prevents all forms of code execution. While dropping capabilities is crucial for security, it primarily limits kernel-level actions, not necessarily user-space memory writes that lead to buffer overflows within the application&#39;s allocated memory."
      }
    ],
    "detailed_explanation": {
      "core_logic": "A buffer overflow occurs when a program attempts to write more data to a buffer than it can hold, overwriting adjacent memory. If the root filesystem is read-only, an attacker exploiting a buffer overflow would have a significantly harder time injecting and executing malicious code, as they cannot easily write new executables or modify existing ones on the filesystem. While it doesn&#39;t prevent the overflow itself, it severely limits the post-exploitation impact, especially code execution.",
      "distractor_analysis": "allowPrivilegeEscalation: false prevents a process from gaining more privileges than its parent, but doesn&#39;t stop a vulnerable application from overflowing a buffer. runAsNonRoot: true ensures the container doesn&#39;t run as UID 0, which is good for general security, but a non-root process can still be vulnerable to buffer overflows. capabilities.drop: [&quot;ALL&quot;] removes dangerous kernel capabilities, but a buffer overflow is often an application-level vulnerability that can occur without special capabilities, especially if the attacker aims to overwrite data within the application&#39;s own memory space.",
      "analogy": "Imagine a safe with a limited capacity (buffer). A buffer overflow is like trying to stuff too much money into it, causing bills to spill out. &#39;readOnlyRootFilesystem: true&#39; is like making the entire safe out of transparent, unmodifiable glass – you can see the money, but you can&#39;t add or remove anything from the outside, making it much harder to replace the spilled money with counterfeit bills (malicious code)."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-app\nspec:\n  containers:\n  - name: my-container\n    image: my-vulnerable-app:latest\n    securityContext:\n      readOnlyRootFilesystem: true",
        "context": "Kubernetes Pod configuration with readOnlyRootFilesystem enabled to mitigate code injection via buffer overflows."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "CONTAINER_SECURITY_FUNDAMENTALS",
      "BUFFER_OVERFLOW_CONCEPTS",
      "KUBERNETES_SECURITY_CONTEXTS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges by disallowing the use of `setuid` and `setgid` binaries?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing root user execution with preventing privilege escalation. `runAsNonRoot` prevents the container from starting as root, but doesn&#39;t stop a non-root user from escalating privileges if `allowPrivilegeEscalation` is true and a `setuid` binary is present."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets mechanism confusion: Students might think making the filesystem read-only prevents all privilege escalation. While it can prevent writing new `setuid` binaries, it doesn&#39;t prevent the execution of existing ones or other forms of privilege escalation."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete protection: Students may believe `privileged: false` is sufficient to prevent all privilege escalation. While it removes many dangerous capabilities, it doesn&#39;t explicitly prevent `setuid`/`setgid` execution, which `allowPrivilegeEscalation: false` specifically addresses."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting in a Kubernetes security context prevents a process from gaining more privileges than its parent process. Specifically, it ensures that a process cannot execute binaries with the `setuid` or `setgid` bits set, which are common mechanisms for privilege escalation within a container. This directly addresses the risk of an attacker using such binaries to elevate their privileges.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, but a non-root user can still escalate privileges if `allowPrivilegeEscalation` is true and a `setuid` binary is available. `readOnlyRootFilesystem: true` prevents modifications to the root filesystem, which can help prevent new `setuid` binaries from being installed, but it doesn&#39;t stop existing ones from being executed if `allowPrivilegeEscalation` is true. `privileged: false` removes many dangerous capabilities but does not specifically block `setuid`/`setgid` execution, which `allowPrivilegeEscalation: false` directly targets.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;you cannot use special keys found inside the building to open more secure doors.&#39; Even if you&#39;re not the building manager (not root), you can&#39;t use a `setuid` key to become one. `runAsNonRoot` is like saying &#39;you can&#39;t start as the building manager.&#39; `readOnlyRootFilesystem` is like saying &#39;you can&#39;t install new special keys.&#39; `privileged: false` is like taking away your master key, but you might still find other special keys lying around."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: restricted-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Pod security context demonstrating `allowPrivilegeEscalation: false` to prevent privilege escalation."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGE_ESCALATION",
      "POD_SECURITY_STANDARDS"
    ]
  },
  {
    "question_text": "What RBAC configuration is considered excessive for a service account that only needs to read `ConfigMaps` within its own namespace?",
    "correct_answer": "A ClusterRole with `get`, `list` on `ConfigMaps` and a ClusterRoleBinding to the service account",
    "distractors": [
      {
        "question_text": "A Role with `get`, `list` on `ConfigMaps` and a RoleBinding to the service account",
        "misconception": "Targets misunderstanding of &#39;excessive&#39;: Students might think this is the correct, minimal approach, not recognizing that the question asks for an *excessive* configuration. This option is actually the principle of least privilege."
      },
      {
        "question_text": "A Role with `*` verbs on `ConfigMaps` and a RoleBinding to the service account",
        "misconception": "Targets scope of &#39;excessive&#39; within namespace: While `*` verbs are excessive, this configuration is still namespace-scoped, which is less excessive than granting cluster-wide read access when only namespace-level is needed."
      },
      {
        "question_text": "A ClusterRole with `get`, `list` on `Pods` and a ClusterRoleBinding to the service account",
        "misconception": "Targets resource type confusion: Students might focus on the ClusterRole/ClusterRoleBinding being excessive, but miss that the resource type (`Pods` instead of `ConfigMaps`) is also incorrect for the stated requirement, making it a different kind of error."
      }
    ],
    "detailed_explanation": {
      "core_logic": "For a service account that only needs to read `ConfigMaps` within its own namespace, the principle of least privilege dictates using a `Role` and `RoleBinding` that are namespace-scoped. A `ClusterRole` and `ClusterRoleBinding`, even if restricted to `get` and `list` verbs on `ConfigMaps`, grants cluster-wide read access to `ConfigMaps` in *all* namespaces. This is excessive because the service account only requires access within its *own* namespace.",
      "distractor_analysis": "A `Role` with `get`, `list` on `ConfigMaps` and a `RoleBinding` is the correct, least-privilege approach for namespace-scoped access. A `Role` with `*` verbs on `ConfigMaps` is excessive in terms of verbs but still namespace-scoped. A `ClusterRole` with `get`, `list` on `Pods` is excessive in scope (cluster-wide) and also grants access to the wrong resource type (`Pods` instead of `ConfigMaps`). The question specifically asks for an *excessive* configuration for reading `ConfigMaps` within its own namespace, making the cluster-wide `ConfigMap` read access the most relevant excessive option.",
      "analogy": "If you only need to read a specific book in your local library branch, getting a library card that lets you read *any* book in *any* branch across the entire city is excessive. A `ClusterRole` for namespace-scoped access is like that city-wide library card."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: excessive-configmap-reader\nrules:\n- apiGroups: [&quot;&quot;]\n  resources: [&quot;configmaps&quot;]\n  verbs: [&quot;get&quot;, &quot;list&quot;]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: bind-excessive-configmap-reader\nspec:\n  roleRef:\n    apiGroup: rbac.authorization.k8s.io\n    kind: ClusterRole\n    name: excessive-configmap-reader\n  subjects:\n  - kind: ServiceAccount\n    name: my-service-account\n    namespace: my-namespace",
        "context": "Example of an excessive ClusterRole and ClusterRoleBinding for a service account needing only namespace-scoped ConfigMap read access."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "KUBERNETES_RBAC_ROLES",
      "KUBERNETES_RBAC_BINDINGS",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "To limit the blast radius of a compromised web application pod, preventing it from initiating connections to other internal application pods in different namespaces, which NetworkPolicy configuration should be applied?",
    "correct_answer": "An Egress NetworkPolicy on the web application pod, denying traffic to pods in other namespaces.",
    "distractors": [
      {
        "question_text": "An Ingress NetworkPolicy on the web application pod, denying traffic from other namespaces.",
        "misconception": "Targets Ingress vs. Egress confusion: Students might confuse inbound (ingress) with outbound (egress) traffic. An Ingress policy would prevent others from connecting *to* the web app, not prevent the web app from connecting *out*."
      },
      {
        "question_text": "An Egress NetworkPolicy on all other internal application pods, denying traffic from the web application pod&#39;s namespace.",
        "misconception": "Targets policy placement: While this would achieve a similar outcome, it&#39;s less efficient and harder to manage. The principle is to restrict the compromised source, not protect every potential target individually. This shifts the burden of protection."
      },
      {
        "question_text": "A default Deny-All Egress NetworkPolicy on the web application pod, with specific rules to allow necessary external connections.",
        "misconception": "Targets over-restriction: While a default deny-all egress is a strong security posture, the question asks for a policy to specifically prevent connections to *other internal application pods in different namespaces*, implying a more targeted restriction rather than a full deny-all with exceptions."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To prevent a compromised web application pod from initiating connections to other internal application pods in different namespaces, an Egress NetworkPolicy is required. This policy should be applied to the web application pod and explicitly deny outbound traffic to pods in other namespaces. This limits the &#39;blast radius&#39; by containing the lateral movement capabilities of the compromised pod.",
      "distractor_analysis": "An Ingress NetworkPolicy would control incoming traffic to the web app, not outgoing. Applying Egress policies to all *other* internal pods is less efficient and harder to manage than restricting the source of potential compromise. A default Deny-All Egress policy is a strong security measure, but the question asks for a specific solution to prevent cross-namespace internal communication, which can be achieved with a more targeted Egress policy.",
      "analogy": "Imagine a fire breaking out in one room (the compromised web app pod). An Egress NetworkPolicy is like immediately closing the door of that room to prevent the fire from spreading to other rooms (other internal pods/namespaces). An Ingress policy would be like closing the doors of other rooms to prevent the fire from entering, which is less effective if the fire is already inside the first room."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-egress-to-other-namespaces\n  namespace: web-app-namespace\nspec:\n  podSelector:\n    matchLabels:\n      app: web-app\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - namespaceSelector:\n            matchLabels:\n              name: web-app-namespace # Allow egress within its own namespace\n    - to: [] # Implicitly denies all other egress if no other rules match",
        "context": "Kubernetes NetworkPolicy denying egress from &#39;web-app&#39; pods to any pod outside its own namespace."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "NETWORK_SEGMENTATION_CONCEPTS",
      "CONTAINER_LATERAL_MOVEMENT"
    ]
  },
  {
    "question_text": "Which Pod Security Standard (PSS) profile would explicitly block a container from running with `hostPath` mounts, which can be used for container escape?",
    "correct_answer": "Restricted",
    "distractors": [
      {
        "question_text": "Baseline",
        "misconception": "Targets incomplete knowledge of PSS profiles: Students might know Baseline is more secure than Privileged but not realize it still permits `hostPath` mounts, which are restricted by the more stringent &#39;Restricted&#39; profile."
      },
      {
        "question_text": "Privileged",
        "misconception": "Targets fundamental misunderstanding of PSS: Students might confuse the most permissive profile with one that enforces security. Privileged mode explicitly allows `hostPath` mounts and all other insecure configurations."
      },
      {
        "question_text": "Standard",
        "misconception": "Targets non-existent profile: Students might invent a &#39;Standard&#39; profile, indicating a lack of familiarity with the actual PSS profiles (Privileged, Baseline, Restricted)."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `Restricted` Pod Security Standard profile is designed to enforce hardened security best practices. It explicitly disallows `hostPath` volumes, which are a common vector for container escape by allowing a container to access the host filesystem. The `Baseline` profile, while more secure than `Privileged`, still permits `hostPath` volumes.",
      "distractor_analysis": "The `Baseline` profile allows `hostPath` volumes, making it insufficient to block this specific vulnerability. The `Privileged` profile is the most permissive and explicitly allows `hostPath` volumes. &#39;Standard&#39; is not one of the defined Pod Security Standard profiles.",
      "analogy": "If `hostPath` mounts are like leaving a back door open to your house, the `Restricted` PSS profile is like a strict security guard who ensures all back doors are sealed shut. The `Baseline` guard might allow some back doors if they seem &#39;safe,&#39; and the `Privileged` guard leaves all doors wide open."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: policy.k8s.io/v1\nkind: PodSecurityAdmissionConfiguration\nmetadata:\n  name: example\nplugins:\n  mutate:\n    - policy: restricted\n  validate:\n    - policy: restricted\n  audit:\n    - policy: restricted",
        "context": "Example of a Pod Security Admission configuration enforcing the &#39;restricted&#39; profile."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "definition",
    "prerequisites": [
      "KUBERNETES_POD_SECURITY_STANDARDS",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "A Kubernetes cluster administrator wants to prevent any container from gaining new privileges after it starts. Which securityContext setting directly enforces this requirement?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "privileged: false",
        "misconception": "Targets scope misunderstanding: Students confuse &#39;privileged&#39; mode (which grants all capabilities and host access) with the ability to escalate privileges from a non-privileged state. Setting privileged: false prevents starting as a privileged container but doesn&#39;t stop a non-privileged container from escalating if other conditions allow it."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets specific vs. general privilege: Students associate &#39;non-root&#39; with &#39;no privilege escalation&#39;. While running as non-root is a good practice, it doesn&#39;t inherently prevent a non-root user from escalating privileges if they have the necessary capabilities or vulnerabilities."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only prevents all forms of privilege escalation. While it limits some attack vectors (e.g., writing to system binaries), it doesn&#39;t prevent privilege escalation through kernel exploits or capability abuse that doesn&#39;t involve filesystem writes."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting in a container&#39;s security context directly prevents a process from gaining more privileges than its parent process. Specifically, it prevents the `setuid` and `setgid` bits from being honored if the executable has them, and it prevents a process from gaining capabilities via `execve` if the executable is not marked as privileged. This is a crucial control for preventing container escapes and privilege escalation within the container.",
      "distractor_analysis": "`privileged: false` prevents the container from running in privileged mode, which grants all capabilities and direct host access, but it doesn&#39;t specifically prevent a non-privileged container from escalating privileges if other conditions (like granted capabilities) allow it. `runAsNonRoot: true` ensures the container does not run as UID 0, which is a good security practice, but a non-root user can still escalate privileges if allowed. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which helps prevent certain types of attacks but doesn&#39;t directly control privilege escalation mechanisms like `setuid` or capability inheritance.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re inside the building, you can&#39;t get a higher security clearance than you started with.&#39; `privileged: false` is like saying &#39;you can&#39;t enter the building with a master key.&#39; `runAsNonRoot: true` is like saying &#39;you can&#39;t be the CEO to enter the building.&#39; And `readOnlyRootFilesystem: true` is like saying &#39;you can&#39;t write on the walls inside the building.&#39;"
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: no-privilege-escalation-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true\n      runAsUser: 1000",
        "context": "Example Pod manifest demonstrating `allowPrivilegeEscalation: false` within a security context, combined with other hardening measures."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "PRIVILEGE_ESCALATION_CONCEPTS"
    ]
  },
  {
    "question_text": "Which image scanning technique is most effective at detecting known vulnerabilities like SQL injection and Cross-Site Scripting (XSS) in containerized web applications?",
    "correct_answer": "Dynamic Application Security Testing (DAST) during runtime or pre-deployment",
    "distractors": [
      {
        "question_text": "Static Application Security Testing (SAST) on the Dockerfile and application code",
        "misconception": "Targets scope misunderstanding: SAST analyzes source code or binaries without running the application, making it less effective for runtime vulnerabilities like SQLi/XSS that manifest during execution."
      },
      {
        "question_text": "Software Composition Analysis (SCA) for third-party libraries",
        "misconception": "Targets incomplete solution: SCA focuses on known vulnerabilities in dependencies, not custom code logic or runtime interaction flaws that lead to SQLi/XSS."
      },
      {
        "question_text": "Container image vulnerability scanning for OS packages",
        "misconception": "Targets limited scope: While important, OS package scanning primarily identifies vulnerabilities in the base image and installed packages, not application-layer flaws like SQLi/XSS."
      }
    ],
    "detailed_explanation": {
      "core_logic": "SQL injection and Cross-Site Scripting (XSS) are application-layer vulnerabilities that typically manifest during the execution of a web application. Dynamic Application Security Testing (DAST) tools actively interact with the running application (or a deployed instance) by sending various inputs and observing its behavior and responses. This allows DAST to identify vulnerabilities that are only detectable at runtime, such as improper input validation leading to SQLi or XSS.",
      "distractor_analysis": "SAST analyzes code without execution, so it might miss runtime-specific flaws. SCA focuses on known vulnerabilities in third-party components, not custom application logic or interaction flaws. Container image vulnerability scanning primarily checks for vulnerabilities in the operating system and installed packages, not the application&#39;s specific code or its runtime behavior.",
      "analogy": "If SAST is like reviewing a blueprint for structural flaws, and SCA is like checking the quality of pre-fabricated parts, then DAST is like stress-testing the actual building by trying to open doors with wrong keys or pushing walls to see if they collapse. SQLi and XSS are &#39;structural flaws&#39; that only appear when the &#39;building&#39; is actively used."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "CONTAINER_SECURITY_FUNDAMENTALS",
      "VULNERABILITY_SCANNING_TYPES",
      "WEB_APPLICATION_VULNERABILITIES"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from performing privileged operations like loading kernel modules or manipulating network interfaces, even if it runs as root?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete understanding of &#39;privileged&#39;: Students often believe &#39;privileged: false&#39; removes all dangerous capabilities, but it only removes the &#39;privileged&#39; flag, leaving default capabilities intact."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets confusion between user identity and capabilities: Students might think preventing root user also prevents privileged operations, but a non-root user can still have dangerous capabilities if not dropped."
      },
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets misunderstanding of privilege escalation scope: Students confuse preventing *escalation* of privileges with preventing *initial* privileged operations. This setting prevents gaining *more* privileges, not preventing existing ones."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `capabilities.drop: [&quot;ALL&quot;]` setting explicitly removes all Linux capabilities from a container. This is the most effective way to prevent privileged operations like loading kernel modules (`CAP_SYS_MODULE`) or manipulating network interfaces (`CAP_NET_ADMIN`), regardless of whether the container runs as root or a non-root user. By default, containers are granted a set of capabilities, some of which can be exploited for container escapes or host compromise.",
      "distractor_analysis": "`privileged: false` only removes the `privileged` flag, which grants all capabilities and access to host devices. However, even without this flag, containers still retain a default set of capabilities that can be dangerous. `runAsNonRoot: true` prevents the container from running as UID 0, but a non-root user can still perform privileged actions if granted specific capabilities. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent process, but it doesn&#39;t prevent the container from starting with dangerous capabilities in the first place.",
      "analogy": "Imagine a security guard (container) who has a master key (all capabilities). `privileged: false` is like taking away the master key but still leaving them with a set of standard keys (default capabilities) that can open many doors. `runAsNonRoot: true` is like making sure the guard isn&#39;t the chief of security, but they still have their keys. `allowPrivilegeEscalation: false` is like preventing the guard from getting *more* keys. `capabilities.drop: [&quot;ALL&quot;]` is like taking away *all* their keys, leaving them with no ability to open any restricted doors."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating `capabilities.drop: [&quot;ALL&quot;]` within the securityContext to remove all Linux capabilities."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "LINUX_CAPABILITIES",
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "A containerized web application is found to be vulnerable to Clickjacking. Which HTTP security header, if properly configured in the application&#39;s ingress or service mesh, would mitigate this vulnerability?",
    "correct_answer": "X-Frame-Options",
    "distractors": [
      {
        "question_text": "Strict-Transport-Security",
        "misconception": "Targets header function confusion: Students confuse HSTS (which enforces HTTPS) with headers that prevent UI redressing attacks. HSTS prevents downgrade attacks, not frame-based attacks."
      },
      {
        "question_text": "X-XSS-Protection",
        "misconception": "Targets header function confusion: Students confuse X-XSS-Protection (which enables browser&#39;s built-in XSS filter) with headers that prevent framing. X-XSS-Protection is for Cross-Site Scripting, not Clickjacking."
      },
      {
        "question_text": "Content-Security-Policy",
        "misconception": "Targets broad vs. specific control: While CSP can mitigate Clickjacking with &#39;frame-ancestors&#39; directive, X-Frame-Options is the more direct and specific header for this vulnerability, and CSP is often seen as a broader security control. Students might pick CSP for its general security reputation without knowing the specific directive."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Clickjacking, or UI redressing, involves tricking a user into clicking on something different from what they perceive. The X-Frame-Options HTTP response header can prevent this by instructing the browser whether it should be allowed to render a page in a &lt;frame&gt;, &lt;iframe&gt;, &lt;embed&gt;, or &lt;object&gt;. Setting it to &#39;DENY&#39; or &#39;SAMEORIGIN&#39; prevents the page from being framed by external sites.",
      "distractor_analysis": "Strict-Transport-Security (HSTS) enforces the use of HTTPS, preventing protocol downgrade attacks, but does not address framing. X-XSS-Protection is a header used to enable or disable the browser&#39;s built-in XSS filter. Content-Security-Policy (CSP) is a powerful header that can mitigate various attacks, including Clickjacking via the `frame-ancestors` directive, but X-Frame-Options is specifically designed and more commonly used for this particular vulnerability, making it the most direct answer.",
      "analogy": "Think of X-Frame-Options as a &#39;No Trespassing&#39; sign specifically for windows (frames) on your house (web page). It tells others they can&#39;t put their content in your window. HSTS is like ensuring your house always uses a secure, locked door (HTTPS), while X-XSS-Protection is like having a special filter for mail (scripts) to prevent malicious content."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-app-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/server-snippet: |\n      add_header X-Frame-Options &quot;DENY&quot;;\nspec:\n  rules:\n  - host: myapp.example.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: my-app-service\n            port:\n              number: 80",
        "context": "Kubernetes Ingress configuration to add X-Frame-Options header for Nginx Ingress Controller"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "WEB_SECURITY_HEADERS",
      "KUBERNETES_INGRESS",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from performing host-level privilege escalation by exploiting dangerous Linux capabilities like `CAP_SYS_ADMIN`?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets partial understanding: Students confuse preventing *new* privileges with preventing *existing* dangerous capabilities. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but doesn&#39;t remove capabilities it already has."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets scope misunderstanding: Students often equate `privileged: false` with complete security. While important, `privileged: false` only prevents the container from running with all capabilities and direct host device access; it doesn&#39;t explicitly drop individual dangerous capabilities that might still be granted by default."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets user vs. capability confusion: Students confuse preventing root user execution with preventing capability-based privilege escalation. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, but a non-root user can still exploit dangerous capabilities if they are present."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `capabilities.drop: [&quot;ALL&quot;]` setting within a container&#39;s security context explicitly removes all Linux capabilities from the container. This is the most effective way to prevent a container from exploiting dangerous capabilities like `CAP_SYS_ADMIN` (which allows for host-level operations like mounting filesystems, manipulating namespaces, and loading kernel modules) for privilege escalation or container escape. By dropping all capabilities, the container operates with the absolute minimum privileges required, significantly reducing its attack surface.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it does not remove capabilities that the container already possesses. `privileged: false` prevents the container from running with *all* capabilities and direct host device access, but it doesn&#39;t explicitly drop individual dangerous capabilities that might still be granted by default to a non-privileged container. `runAsNonRoot: true` ensures the container does not run as the root user (UID 0), which is a good practice, but a non-root user can still exploit dangerous capabilities if they are present in the container&#39;s security context.",
      "analogy": "Imagine a security guard (container) who has a master key (CAP_SYS_ADMIN). `capabilities.drop: [&quot;ALL&quot;]` is like taking away all their keys, leaving them with only the ability to open the front door. `allowPrivilegeEscalation: false` is like telling them they can&#39;t ask for more keys. `privileged: false` is like telling them they can&#39;t use the master key for everything, but they might still have some dangerous keys. `runAsNonRoot: true` is like making sure the guard isn&#39;t the chief of security, but they could still have dangerous keys."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating the use of `capabilities.drop: [&quot;ALL&quot;]` within the security context to enhance container security."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_PREVENTION"
    ]
  },
  {
    "question_text": "A Kubernetes pod is configured with `hostNetwork: true` and `privileged: true`. Which Pod Security Standard profile would explicitly prevent this configuration from being deployed?",
    "correct_answer": "Restricted",
    "distractors": [
      {
        "question_text": "Baseline",
        "misconception": "Targets partial understanding of PSS profiles: Students might think Baseline is sufficient because it disallows privileged containers, but it permits hostNetwork, which is also a critical security risk."
      },
      {
        "question_text": "Privileged",
        "misconception": "Targets misunderstanding of PSS purpose: Students might confuse the &#39;Privileged&#39; profile as a restrictive one, when in fact it allows all configurations, including highly insecure ones like `privileged: true` and `hostNetwork: true`."
      },
      {
        "question_text": "Namespace-level Pod Security Admission with `warn` mode",
        "misconception": "Targets confusion between enforcement modes and profiles: Students might confuse the admission controller&#39;s mode (warn) with the security standard profile itself, or think that a &#39;warn&#39; mode would prevent deployment, when it only logs warnings."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `Restricted` Pod Security Standard profile is designed to enforce current hardening best practices. It explicitly disallows configurations that provide broad host access, such as `privileged: true` and `hostNetwork: true`. Both of these settings grant significant privileges that can lead to container escapes or host compromise, making them incompatible with the `Restricted` profile.",
      "distractor_analysis": "`Baseline` profile disallows `privileged: true` but permits `hostNetwork: true`, so it would not prevent the entire configuration. The `Privileged` profile allows any configuration, including the insecure one described, as it imposes no restrictions. Namespace-level Pod Security Admission with `warn` mode would only issue a warning and allow the pod to be deployed, not prevent it.",
      "analogy": "Imagine the Pod Security Standards as different levels of security checks at an airport. &#39;Privileged&#39; is like no checks at all, letting anything through. &#39;Baseline&#39; is like a basic metal detector, catching some obvious threats but letting others pass. &#39;Restricted&#39; is like full body scanners and bag checks, preventing almost all risky items from boarding."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: highly-privileged-pod\nspec:\n  hostNetwork: true\n  containers:\n  - name: my-container\n    image: busybox\n    command: [&quot;sleep&quot;, &quot;3600&quot;]\n    securityContext:\n      privileged: true",
        "context": "Example Pod configuration that would be blocked by the Restricted Pod Security Standard."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "KUBERNETES_POD_SECURITY_STANDARDS",
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_NETWORK_SECURITY"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from executing arbitrary code injected via a reflected XSS vulnerability that attempts to leverage host capabilities?",
    "correct_answer": "securityContext.capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets partial solution bias: While good practice, runAsNonRoot prevents running as UID 0 but doesn&#39;t prevent a non-root user from exploiting capabilities if they are present and the XSS payload can trigger them."
      },
      {
        "question_text": "securityContext.readOnlyRootFilesystem: true",
        "misconception": "Targets scope misunderstanding: This prevents writing to the container&#39;s root filesystem but does not prevent in-memory execution of injected scripts or exploitation of existing capabilities."
      },
      {
        "question_text": "Pod Security Standard: Baseline",
        "misconception": "Targets insufficient standard: The Baseline standard allows certain capabilities by default and does not explicitly drop ALL capabilities, leaving potential attack surface for capability-based escapes."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Reflected XSS vulnerabilities typically lead to client-side code execution. If this injected code attempts to escalate privileges or escape the container by leveraging Linux capabilities (e.g., CAP_SYS_ADMIN, CAP_NET_RAW), dropping all capabilities (`securityContext.capabilities.drop: [&quot;ALL&quot;]`) is the most effective preventive measure. This removes the tools the injected code would need to interact with the host kernel in a privileged manner, significantly hindering container escape attempts.",
      "distractor_analysis": "Setting `runAsNonRoot: true` prevents the container from running as UID 0, but a non-root user can still exploit capabilities if they are not dropped. `readOnlyRootFilesystem: true` prevents writing to the container&#39;s root filesystem but doesn&#39;t stop in-memory execution or capability exploitation. The &#39;Baseline&#39; Pod Security Standard is less restrictive than &#39;Restricted&#39; and does not mandate dropping all capabilities, thus leaving a larger attack surface.",
      "analogy": "Imagine the injected XSS code as a thief trying to break into a house. `drop: [&quot;ALL&quot;]` is like removing all the thief&#39;s tools (lockpicks, crowbars) before they even get near the door. `runAsNonRoot: true` is like making sure the thief isn&#39;t wearing a &#39;master key&#39; badge, but they might still have other tools. `readOnlyRootFilesystem: true` is like making sure the walls are concrete, but the thief might still try to pick the lock. The &#39;Baseline&#39; standard is like having some basic security, but not the highest level."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating security context settings to prevent capability-based attacks from injected code."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_TECHNIQUES",
      "XSS_VULNERABILITIES"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from executing arbitrary code by disabling the ability to gain new privileges?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing root execution with preventing privilege escalation. runAsNonRoot prevents the container from starting as UID 0, but doesn&#39;t stop a non-root user from escalating privileges if other vulnerabilities exist."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only prevents code execution. While it limits persistence and modification, it doesn&#39;t directly prevent in-memory execution or privilege escalation if the initial code is already running."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets partial solution bias: While dropping all capabilities is highly effective, allowPrivilegeEscalation: false specifically prevents a process from gaining *new* privileges, which is a direct mechanism for arbitrary code execution after an initial compromise. Dropping capabilities is a broader control, but allowPrivilegeEscalation directly addresses the &#39;gaining new privileges&#39; aspect."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting in a container&#39;s security context prevents a process from gaining more privileges than its parent process. Specifically, it ensures that the `no_new_privs` flag is set on the container process, which prevents the use of `setuid` or `setgid` binaries, or file capabilities, to escalate privileges. This is a critical control against arbitrary code execution, as many exploits rely on gaining elevated privileges to achieve their objectives.",
      "distractor_analysis": "`runAsNonRoot: true` prevents the container from running as the root user (UID 0) initially, but doesn&#39;t stop a non-root user from escalating privileges if other vulnerabilities or misconfigurations are present. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which helps prevent an attacker from writing malicious binaries or modifying system files, but it doesn&#39;t directly prevent arbitrary code execution or privilege escalation if the code is executed in memory or within writable volumes. `capabilities.drop: [&quot;ALL&quot;]` is a very strong control that removes all Linux capabilities from the container, significantly reducing the attack surface. While highly effective, `allowPrivilegeEscalation: false` specifically targets the mechanism of gaining *new* privileges, which is a direct countermeasure to many arbitrary code execution scenarios where an attacker tries to elevate their permissions after initial compromise.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says, &#39;Once you&#39;re inside this building, you cannot upgrade your access card to get into more restricted areas.&#39; Even if you find a way to trick the system, this rule prevents you from getting a higher level of access."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: no-priv-escalation-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-secure-image\n    securityContext:\n      allowPrivilegeEscalation: false",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false`"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGES",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges by exploiting a vulnerability that allows it to modify its own capabilities?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing root execution with preventing privilege escalation. runAsNonRoot prevents the container from starting as root, but doesn&#39;t stop a non-root user from escalating privileges if allowed."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only prevents all privilege escalation. While it helps prevent writing to system binaries, it doesn&#39;t directly prevent capability-based privilege escalation."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete protection: Students may believe setting privileged to false is sufficient. While it removes many host-level privileges, it doesn&#39;t explicitly prevent a container from escalating privileges if it retains certain capabilities or can acquire new ones."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly prevents a process in a container from gaining more privileges than its parent process. Specifically, it ensures that the `no_new_privs` flag is set on the container process, which prevents it from executing a setuid or setgid binary that would grant it additional privileges, or from gaining new capabilities. This is crucial for preventing privilege escalation attacks within the container.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container does not run as UID 0, but a non-root user can still escalate privileges if allowed. `readOnlyRootFilesystem: true` prevents modifications to the root filesystem but doesn&#39;t directly stop a process from gaining new capabilities or executing setuid binaries if they exist elsewhere. `privileged: false` removes broad host access but doesn&#39;t specifically prevent privilege escalation within the container&#39;s existing scope if `allowPrivilegeEscalation` is not also set to `false`.",
      "analogy": "Imagine a security guard (container process) who is already inside a building. `allowPrivilegeEscalation: false` is like taking away their ability to pick up a master key (gain new privileges) they might find lying around, even if they don&#39;t have one initially. `runAsNonRoot: true` is like ensuring they don&#39;t start their shift with a master key. `readOnlyRootFilesystem: true` is like making sure the building&#39;s blueprints can&#39;t be altered. `privileged: false` is like not giving them a universal access card to the entire city."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true",
        "context": "Pod manifest demonstrating `allowPrivilegeEscalation: false` within a security context, often combined with dropping capabilities and running as non-root for defense in depth."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "PRIVILEGE_ESCALATION_CONCEPTS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from executing arbitrary commands as root by dropping all Linux capabilities?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets partial understanding of root prevention: Students might think preventing the container from starting as root also prevents it from gaining root-like privileges later, but capabilities can still be exploited even by non-root users if granted."
      },
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets confusion between initial privilege and escalation: Students confuse preventing initial root execution with preventing privilege escalation. While important, this setting prevents gaining *additional* privileges, not the initial set of capabilities that might include dangerous ones."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets misunderstanding of &#39;privileged&#39; scope: Students often equate &#39;privileged: false&#39; with complete security, but it only removes the most extreme host access. Containers still run with a default set of capabilities that can be exploited for escape, even without being fully &#39;privileged&#39;."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `capabilities.drop: [&quot;ALL&quot;]` setting explicitly removes all Linux capabilities from the container. This is a crucial security measure because many container escape techniques and privilege escalation vulnerabilities rely on the presence of specific capabilities (e.g., CAP_SYS_ADMIN, CAP_NET_RAW). By dropping all capabilities, the container&#39;s attack surface is significantly reduced, making it much harder to perform actions that could lead to host compromise.",
      "distractor_analysis": "`runAsNonRoot: true` prevents the container from running as UID 0, but a non-root user can still exploit dangerous capabilities if they are not dropped. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t remove the initial set of capabilities the container starts with. `privileged: false` prevents the container from running in privileged mode (which grants all capabilities and direct host access), but even non-privileged containers retain a default set of capabilities that can be dangerous if not explicitly dropped.",
      "analogy": "Imagine a safe with multiple locks. `runAsNonRoot: true` is like ensuring the person trying to open it isn&#39;t the vault manager. `allowPrivilegeEscalation: false` is like preventing them from finding new keys once inside. `privileged: false` is like not giving them the master key. But `capabilities.drop: [&quot;ALL&quot;]` is like removing all the tools they could use to pick any of the locks, regardless of their initial access level."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating how to drop all capabilities for a container."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "LINUX_CAPABILITIES",
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which type of SQL injection relies on an external channel to confirm its success, rather than direct application responses or errors?",
    "correct_answer": "Out-of-band SQL injection",
    "distractors": [
      {
        "question_text": "Error-based SQL injection",
        "misconception": "Targets confusion with direct feedback: Students might confuse out-of-band with error-based, which provides direct feedback through error messages, not external channels."
      },
      {
        "question_text": "Blind SQL injection (Boolean-based)",
        "misconception": "Targets confusion with indirect feedback: Students might think blind SQL injection, which infers results through true/false conditions, is the same as using an external channel, but it still uses the same application channel."
      },
      {
        "question_text": "Union-based SQL injection",
        "misconception": "Targets confusion with data retrieval: Students might associate Union-based, which retrieves data directly into the application&#39;s response, with the need for external confirmation, which is incorrect."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Out-of-band SQL injection is a complex technique used when the attacker cannot directly see the results of their injection through the application&#39;s response, errors, or inferred timing. Instead, it leverages an external channel, such as a DNS lookup or a request to a controlled server, to confirm the success of the injection or exfiltrate data. This method is necessary when the primary communication channel is too restrictive.",
      "distractor_analysis": "Error-based SQL injection provides direct feedback through database error messages. Blind SQL injection (Boolean-based) infers results by observing changes in the application&#39;s response based on true/false conditions, but still within the same channel. Union-based SQL injection directly retrieves data by appending a UNION SELECT statement to the original query, displaying results within the application&#39;s normal output.",
      "analogy": "Imagine trying to communicate with someone through a thick wall. If you can&#39;t hear their voice (direct response) or see their gestures (error messages), you might try tapping on the wall in a specific pattern and listening for a response from a friend outside the building (external channel). That&#39;s like out-of-band SQL injection."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "definition",
    "prerequisites": [
      "SQL_INJECTION_BASICS",
      "NETWORK_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "A Kubernetes application is vulnerable to SQL injection due to improper input validation. Which security context setting, if properly configured, could have prevented the application from directly accessing sensitive database credentials stored as environment variables within the pod?",
    "correct_answer": "readOnlyRootFilesystem: true",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope confusion: Students might think preventing privilege escalation also prevents access to environment variables, but these are distinct security controls. Privilege escalation relates to gaining higher privileges within the container or host, not data access."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets user context misunderstanding: While good practice, running as a non-root user does not inherently restrict access to environment variables or files that the non-root user is already permitted to read, which includes environment variables."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets capability relevance: Students might overgeneralize the impact of dropping capabilities. Dropping capabilities restricts privileged operations (like network raw sockets, system calls) but does not directly prevent a compromised application from reading its own environment variables."
      }
    ],
    "detailed_explanation": {
      "core_logic": "While `readOnlyRootFilesystem: true` doesn&#39;t directly prevent SQL injection, it&#39;s the most relevant security context setting among the choices for preventing a compromised application from *modifying* or *exfiltrating* sensitive data by writing it to the filesystem. If database credentials were stored in a file on the root filesystem (e.g., `/etc/secrets/db_creds`), making that filesystem read-only would prevent the attacker from modifying or deleting that file, or writing exfiltrated data to it. For environment variables, the primary defense is not to store sensitive credentials directly in them, but if they are, `readOnlyRootFilesystem` helps prevent an attacker from writing them to a file for later retrieval if the application is compromised.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, which is crucial for preventing container escapes but doesn&#39;t restrict access to existing environment variables. `runAsNonRoot: true` ensures the container runs as a non-root user, reducing the impact of some vulnerabilities, but a non-root user can still read environment variables. `capabilities.drop: [&quot;ALL&quot;]` removes all Linux capabilities, significantly hardening the container, but again, it doesn&#39;t directly prevent an application from reading its own environment variables.",
      "analogy": "Imagine a safe with a combination lock (the database). SQL injection is like guessing the combination. `readOnlyRootFilesystem: true` is like making the safe itself unmovable and its exterior unalterable, so even if you guess the combination, you can&#39;t easily steal the whole safe or leave a note on it for later."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: vulnerable-app\nspec:\n  containers:\n  - name: app\n    image: vulnerable-image\n    env:\n    - name: DB_PASSWORD\n      valueFrom:\n        secretKeyRef:\n          name: db-credentials\n          key: password\n    securityContext:\n      readOnlyRootFilesystem: true",
        "context": "Pod definition showing `readOnlyRootFilesystem: true` to prevent writing to the root filesystem, which could be used by an attacker to exfiltrate data or modify configuration after an SQL injection."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "SQL_INJECTION_BASICS",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which securityContext setting is most effective at preventing a container from gaining new privileges, a common step in container escape attempts?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing root execution with preventing privilege escalation. runAsNonRoot prevents starting as root, but doesn&#39;t stop a non-root process from escalating if allowed."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only prevents privilege escalation, but this primarily prevents writing to the root filesystem, not gaining new privileges via capabilities or other means."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete mitigation: While &#39;privileged: false&#39; is crucial, it doesn&#39;t explicitly prevent *all* forms of privilege escalation if the container still has certain capabilities or other vulnerabilities. &#39;allowPrivilegeEscalation: false&#39; specifically targets the `no_new_privs` flag."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly maps to the `NO_NEW_PRIVS` flag in Linux. When set to false, it prevents a process from gaining more privileges than its parent process. This is a critical control against container escape, as many escape techniques involve escalating privileges (e.g., by executing setuid binaries or exploiting kernel vulnerabilities that grant new capabilities).",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container does not run as UID 0, but a non-root user can still escalate privileges if allowed. `readOnlyRootFilesystem: true` prevents writes to the root filesystem but doesn&#39;t stop a process from gaining new privileges. `privileged: false` removes broad host access but doesn&#39;t specifically prevent privilege escalation if the container still has some capabilities or other vectors.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re inside, you can&#39;t get a bigger key.&#39; Other settings might control which door you enter or what you can touch, but this one specifically limits your ability to upgrade your access level."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true",
        "context": "Example Pod manifest demonstrating `allowPrivilegeEscalation: false` within a securityContext."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "A Kubernetes pod is configured with `securityContext.privileged: true`. Which Pod Security Standard profile would explicitly block the deployment of this pod?",
    "correct_answer": "Restricted",
    "distractors": [
      {
        "question_text": "Baseline",
        "misconception": "Targets misunderstanding of Baseline scope: Students might think Baseline is strict enough, but it allows privileged containers, focusing on preventing known privilege escalations rather than outright privileged access."
      },
      {
        "question_text": "HostProcess",
        "misconception": "Targets confusion with Windows-specific features: HostProcess is a Windows-specific feature for running processes directly on the host, not a general Pod Security Standard profile for Linux containers."
      },
      {
        "question_text": "Privileged",
        "misconception": "Targets conflation of profile name with configuration: Students might assume a &#39;Privileged&#39; profile exists to allow privileged containers, but the standards are named for their restrictiveness, not what they permit."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `securityContext.privileged: true` setting grants a container all capabilities and access to host devices, effectively removing all container isolation. The Restricted Pod Security Standard explicitly disallows privileged containers, along with other highly sensitive settings, to enforce strong hardening. The Baseline standard, while more restrictive than Privileged, still permits privileged containers.",
      "distractor_analysis": "The Baseline profile allows privileged containers, so it would not block this deployment. HostProcess is a Windows-specific feature and not a Pod Security Standard profile. There is no &#39;Privileged&#39; Pod Security Standard profile; the standards are named &#39;Privileged&#39;, &#39;Baseline&#39;, and &#39;Restricted&#39; based on their level of restriction, with &#39;Privileged&#39; being the least restrictive (allowing anything).",
      "analogy": "If Pod Security Standards are like security checkpoints, &#39;Privileged&#39; is an open gate, &#39;Baseline&#39; is a metal detector, and &#39;Restricted&#39; is a full body scanner that would immediately flag a &#39;privileged&#39; item as contraband."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: privileged-pod\nspec:\n  containers:\n  - name: my-container\n    image: busybox\n    command: [&quot;sleep&quot;, &quot;3600&quot;]\n    securityContext:\n      privileged: true",
        "context": "Example of a Kubernetes Pod configuration that would be blocked by the Restricted Pod Security Standard."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "KUBERNETES_BASICS",
      "POD_SECURITY_STANDARDS",
      "CONTAINER_SECURITY_CONTEXTS"
    ]
  },
  {
    "question_text": "A critical application pod needs to communicate only with a specific database service within the same namespace and deny all other egress traffic. Which NetworkPolicy configuration achieves this least-privilege communication?",
    "correct_answer": "Egress policy allowing traffic to the database service&#39;s podSelector and port, denying all other egress",
    "distractors": [
      {
        "question_text": "Ingress policy allowing traffic from the database service&#39;s podSelector and port, denying all other ingress",
        "misconception": "Targets confusion between ingress and egress: Students might confuse the direction of traffic, applying an ingress policy when egress is needed for outbound communication."
      },
      {
        "question_text": "Egress policy allowing traffic to all pods in the same namespace, denying cross-namespace traffic",
        "misconception": "Targets over-permissioning within namespace: Students might grant too broad access within the same namespace, violating least privilege by allowing communication to services other than the database."
      },
      {
        "question_text": "NetworkPolicy with `policyTypes: [&quot;Ingress&quot;, &quot;Egress&quot;]` and no rules, effectively denying all traffic",
        "misconception": "Targets misunderstanding of default deny: Students might think an empty policy with both types denies all traffic, but it would deny all traffic, including the required database communication, leading to an outage."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To restrict outbound (egress) traffic from the application pod, an `egress` NetworkPolicy is required. This policy should specify a `to` rule that matches the `podSelector` and `ports` of the specific database service. By default, if an egress policy exists for a pod, all traffic not explicitly allowed is denied, thus achieving the &#39;deny all other egress&#39; requirement.",
      "distractor_analysis": "An `ingress` policy controls inbound traffic to the application pod, not outbound traffic. Allowing traffic to &#39;all pods in the same namespace&#39; violates least privilege by permitting communication with services other than the database. A NetworkPolicy with `policyTypes: [&quot;Ingress&quot;, &quot;Egress&quot;]` and no rules would deny *all* ingress and egress traffic, including the necessary database connection, causing an outage.",
      "analogy": "This is like giving a delivery driver a manifest that only allows them to deliver to one specific address (the database service) and nowhere else. An ingress policy would be like controlling who can deliver *to* the driver. Allowing all pods in the namespace is like letting the driver deliver to any house on the street. An empty policy is like telling the driver they can&#39;t deliver anything at all."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: app-db-egress\n  namespace: my-app-namespace\nspec:\n  podSelector:\n    matchLabels:\n      app: my-app\n  policyTypes:\n  - Egress\n  egress:\n  - to:\n    - podSelector:\n        matchLabels:\n          app: my-database\n    ports:\n    - protocol: TCP\n      port: 5432",
        "context": "Kubernetes NetworkPolicy allowing egress only to a specific database service on a specific port."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "procedure",
    "prerequisites": [
      "KUBERNETES_NETWORKING",
      "NETWORK_POLICIES",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "Which `securityContext` setting prevents a container from gaining additional privileges beyond those it started with, even if a process inside attempts to call `setuid` or `setgid`?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets confusion between initial user and privilege escalation: Students might think running as non-root prevents all privilege escalation, but a non-root user can still attempt to escalate privileges if `allowPrivilegeEscalation` is true."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets misunderstanding of `privileged` scope: Students might think `privileged: false` inherently prevents all forms of privilege escalation, but it only prevents the container from running with all capabilities and host access; it doesn&#39;t specifically block `setuid`/`setgid` if other conditions allow it."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets confusion between filesystem and process privileges: Students might confuse filesystem immutability with process privilege control, but `readOnlyRootFilesystem` only protects the filesystem, not the ability of a process to change its user ID."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly controls whether a process can gain more privileges than its parent process. Specifically, it prevents a process from calling `setuid` or `setgid` if the executable has the `setuid` or `setgid` bit set, or if the process attempts to gain capabilities. This is a crucial control against privilege escalation within a container.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container starts as a non-root user, but doesn&#39;t prevent that non-root user from escalating privileges if `allowPrivilegeEscalation` is true. `privileged: false` prevents the container from running with full host access and all capabilities, but doesn&#39;t specifically block `setuid`/`setgid` calls if the container still has some capabilities. `readOnlyRootFilesystem: true` makes the root filesystem immutable, which is a good security practice but unrelated to process privilege escalation.",
      "analogy": "This is like a security guard&#39;s badge: `allowPrivilegeEscalation: false` means the guard cannot upgrade their own badge to a higher clearance level. `runAsNonRoot: true` is like ensuring the guard starts with a basic badge. `privileged: false` is like ensuring the guard doesn&#39;t have a master key to the whole building. `readOnlyRootFilesystem: true` is like making sure the guard&#39;s uniform cannot be altered."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "securityContext:\n  allowPrivilegeEscalation: false\n  capabilities:\n    drop: [&quot;ALL&quot;]\n  runAsNonRoot: true",
        "context": "Kubernetes security context configuration to prevent privilege escalation and enforce least privilege."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "LINUX_CAPABILITIES",
      "CONTAINER_SECURITY_CONTEXTS",
      "PRIVILEGE_ESCALATION"
    ]
  },
  {
    "question_text": "A containerized application is vulnerable to an out-of-band SQL Injection attack. Which Kubernetes NetworkPolicy configuration would best prevent the exfiltration of data to an external attacker-controlled server?",
    "correct_answer": "Egress NetworkPolicy denying all outbound traffic except to known, whitelisted internal services and DNS.",
    "distractors": [
      {
        "question_text": "Ingress NetworkPolicy allowing traffic only from the load balancer.",
        "misconception": "Targets scope confusion: Ingress policies control incoming traffic, not outgoing data exfiltration, which is the concern for out-of-band attacks."
      },
      {
        "question_text": "Egress NetworkPolicy allowing all outbound traffic on ports 80 and 443.",
        "misconception": "Targets incomplete restriction: While common for web traffic, this still allows exfiltration over standard HTTP/HTTPS ports to arbitrary external IPs, which is precisely what out-of-band SQLi exploits."
      },
      {
        "question_text": "NetworkPolicy denying all traffic to the container.",
        "misconception": "Targets over-restriction: This would make the application inaccessible and non-functional, which is not a practical solution for a running service."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Out-of-band SQL Injection relies on the vulnerable application making an outbound connection to an attacker-controlled server to exfiltrate data. An Egress NetworkPolicy specifically controls outbound traffic from a pod. By default, pods allow all egress. To prevent this attack, an Egress NetworkPolicy should be implemented to deny all outbound traffic by default and then explicitly whitelist only the necessary internal services (e.g., database, other microservices) and DNS resolvers that the application needs to communicate with. This prevents the container from initiating connections to arbitrary external IPs, thus blocking the out-of-band channel.",
      "distractor_analysis": "An Ingress NetworkPolicy only controls traffic *into* the pod, not *out* of it, so it&#39;s ineffective against data exfiltration. Allowing all outbound traffic on ports 80 and 443 is too permissive, as an attacker could still use these common ports to send data to their server. Denying all traffic to the container would render the application unusable, which is not a viable security control for a functional service.",
      "analogy": "Imagine a secure vault (your container) that needs to send messages to a few trusted recipients (internal services). An out-of-band attack is like someone inside the vault trying to send a secret message to an unknown person outside. An Egress NetworkPolicy is like having a strict mailroom that only allows messages to pre-approved addresses, blocking any attempts to send mail to unauthorized external recipients."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-all-egress-except-internal\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: vulnerable-app\n  policyTypes:\n    - Egress\n  egress:\n    # Allow DNS resolution\n    - to:\n        - namespaceSelector: {}\n          podSelector:\n            matchLabels:\n              k8s-app: kube-dns\n      ports:\n        - protocol: UDP\n          port: 53\n    # Allow traffic to internal database\n    - to:\n        - podSelector:\n            matchLabels:\n              app: internal-db\n      ports:\n        - protocol: TCP\n          port: 5432\n    # Implicitly denies all other egress traffic",
        "context": "Kubernetes NetworkPolicy to restrict outbound connections for a specific application, preventing out-of-band data exfiltration."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "SQL_INJECTION_TYPES",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges that could lead to a container escape, specifically by restricting its ability to perform privileged operations like mounting filesystems or modifying kernel parameters?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets partial understanding of privilege escalation: Students might think this setting alone prevents all privilege gains, but it only prevents a process from gaining more privileges than its parent, not from starting with dangerous capabilities."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets confusion with deprecated or broad controls: Students might associate &#39;privileged: false&#39; with comprehensive security, but it&#39;s a coarse-grained control that still leaves many dangerous capabilities enabled by default."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets misunderstanding of user vs. capability privileges: Students might confuse running as a non-root user with preventing privileged operations, but a non-root user can still have dangerous capabilities assigned."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `capabilities.drop: [&quot;ALL&quot;]` setting explicitly removes all Linux capabilities from a container. This is crucial because many container escape techniques, including those exploiting `CAP_SYS_ADMIN`, rely on these capabilities to perform privileged operations on the host. By dropping all capabilities, the container is severely restricted in what it can do, making it much harder to escape.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but if the container starts with dangerous capabilities, this setting won&#39;t remove them. `privileged: false` is the default and prevents the container from running in &#39;privileged mode&#39; (which grants all capabilities and direct host access), but it still leaves a default set of capabilities that can be exploited. `runAsNonRoot: true` ensures the container runs as a non-root user, which is good practice, but a non-root user can still possess dangerous capabilities if not explicitly dropped.",
      "analogy": "Imagine a security guard (container) being given a set of tools (capabilities). `capabilities.drop: [&quot;ALL&quot;]` is like taking away all the dangerous tools (like crowbars or lock-picking kits) so the guard can&#39;t misuse them. `allowPrivilegeEscalation: false` is like saying the guard can&#39;t ask for more tools than they already have. `privileged: false` is like not giving the guard a master key to the entire building. `runAsNonRoot: true` is like making sure the guard isn&#39;t the building manager, but they might still have dangerous tools if not explicitly removed."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: restricted-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating security context settings to prevent privilege escalation and container escape."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "LINUX_CAPABILITIES",
      "CONTAINER_SECURITY_CONTEXTS",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining new privileges after it has started, thereby mitigating privilege escalation attempts?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing initial root execution with preventing privilege escalation; runAsNonRoot prevents starting as root but doesn&#39;t stop a non-root user from escalating if allowed."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only prevents all privilege escalation, but it primarily prevents writing to the root filesystem, not gaining new capabilities or user IDs."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete mitigation: Students may believe disabling privileged mode is sufficient, but while it removes many host-level privileges, it doesn&#39;t explicitly prevent a container from attempting to escalate privileges within its existing capabilities or through other means."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting in a container&#39;s security context prevents a process from gaining more privileges than its parent process. Specifically, it ensures that the `no_new_privs` flag is set on the container process, which prevents `setuid` and `setgid` binaries from granting new privileges and blocks the use of capabilities to escalate privileges. This is a direct control against privilege escalation.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container does not start as the root user (UID 0), but it does not prevent a non-root user from escalating privileges if the container&#39;s capabilities or other configurations allow it. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which is good for integrity but doesn&#39;t directly prevent a process from gaining new privileges if it doesn&#39;t need to write to the root filesystem. `privileged: false` (the default) prevents the container from running in privileged mode, which grants all capabilities and access to host devices, but it doesn&#39;t explicitly set `no_new_privs` to prevent escalation from existing capabilities.",
      "analogy": "Imagine a security guard (container process) who has a certain level of access. `allowPrivilegeEscalation: false` is like telling the guard, &#39;You cannot get a higher security clearance than you currently have, no matter what special keys or badges you find.&#39; `runAsNonRoot: true` is like saying, &#39;You can&#39;t start your shift as the head of security.&#39; `readOnlyRootFilesystem: true` is like saying, &#39;You can&#39;t write on the walls of the building.&#39; `privileged: false` is like saying, &#39;You don&#39;t have the master key to everything.&#39;"
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: no-priv-escalation-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` in a security context to prevent privilege escalation."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "PRIVILEGE_ESCALATION_CONCEPTS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges by exploiting a vulnerability that allows it to modify its own process capabilities?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing initial root execution with preventing privilege escalation; runAsNonRoot prevents a container from starting as root, but doesn&#39;t stop a non-root user from escalating if allowed."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only prevents all privilege escalation, but it primarily prevents writing to the root filesystem, not modifying process capabilities."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets incomplete prevention: While dropping all capabilities is crucial, allowPrivilegeEscalation: false specifically prevents a process from gaining *new* privileges, even if some capabilities were initially granted or if a vulnerability allows re-adding them."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting in a container&#39;s security context prevents a process from gaining more privileges than its parent process. Specifically, it ensures that the `no_new_privs` flag is set on the container process, which prevents the process from executing a setuid or setgid binary that would grant it additional privileges, or from gaining new capabilities. This is a direct control against privilege escalation attempts.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container does not start as UID 0, but a non-root user can still escalate privileges if allowed. `readOnlyRootFilesystem: true` prevents writes to the root filesystem but doesn&#39;t directly stop a process from gaining new capabilities or executing privileged binaries. While `capabilities.drop: [&quot;ALL&quot;]` is a strong control to remove dangerous capabilities, `allowPrivilegeEscalation: false` acts as a complementary defense, preventing the re-acquisition of capabilities or other forms of privilege escalation even if a vulnerability exists.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a &#39;no promotion&#39; policy. Even if an employee (process) finds a loophole, they cannot get a higher-level badge (privilege) than what they started with. `runAsNonRoot` is like ensuring no one starts as the CEO, and `capabilities.drop: [&quot;ALL&quot;]` is like taking away all special tools from everyone."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: no-priv-escalation-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      capabilities:\n        drop: [&quot;ALL&quot;]\n",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` within a security context."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "PRIVILEGE_ESCALATION_CONCEPTS"
    ]
  },
  {
    "question_text": "An intentionally vulnerable application, OWASP Juice Shop, is deployed as a containerized application on a target VM. Which Pod Security Standard would be most appropriate to prevent the container from gaining elevated privileges on the host, assuming it&#39;s running on a Kubernetes cluster?",
    "correct_answer": "Restricted",
    "distractors": [
      {
        "question_text": "Baseline",
        "misconception": "Targets incomplete protection: Students might think Baseline is sufficient for vulnerable apps, but it allows some potentially dangerous capabilities and hostPath mounts that Restricted disallows."
      },
      {
        "question_text": "Privileged",
        "misconception": "Targets misunderstanding of security goals: Students might confuse &#39;vulnerable-by-design&#39; with needing full host access, not realizing the goal is to test the application&#39;s vulnerabilities, not the container runtime&#39;s."
      },
      {
        "question_text": "HostProcess",
        "misconception": "Targets incorrect application of Windows-specific concepts: Students might confuse HostProcess (a Windows-specific feature for running processes directly on the host) with general Linux container security standards."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The &#39;Restricted&#39; Pod Security Standard is designed to enforce current best practices for hardening pods, significantly reducing the attack surface. It prevents privilege escalation by disallowing hostPath volumes, requiring `runAsNonRoot: true`, and dropping all capabilities, which is crucial for containing a vulnerable application like OWASP Juice Shop and preventing it from impacting the host system.",
      "distractor_analysis": "The &#39;Baseline&#39; standard is less restrictive and allows some capabilities and volume types that could be exploited by a vulnerable application. &#39;Privileged&#39; mode grants full access to the host, which is the opposite of what&#39;s desired for containing a vulnerable app. &#39;HostProcess&#39; is a Windows-specific feature for running processes directly on the host and is not a Pod Security Standard for Linux containers.",
      "analogy": "If your house has a known weak lock (the vulnerable app), &#39;Restricted&#39; is like putting a strong, reinforced door and bars on the windows to contain any breach. &#39;Baseline&#39; might be like just locking the door, which is better than nothing but still leaves vulnerabilities. &#39;Privileged&#39; is like leaving the front door wide open."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: restricted\nspec:\n  privileged: false\n  allowPrivilegeEscalation: false\n  requiredDropCapabilities:\n    - ALL\n  volumes:\n    - &#39;configMap&#39;\n    - &#39;emptyDir&#39;\n    - &#39;projected&#39;\n    - &#39;secret&#39;\n    - &#39;downwardAPI&#39;\n  hostNetwork: false\n  hostPID: false\n  hostIPC: false\n  runAsUser:\n    rule: &#39;MustRunAsNonRoot&#39;\n  seccompProfile:\n    type: &#39;RuntimeDefault&#39;\n  # ... other restricted settings\n",
        "context": "Example of a PodSecurityPolicy (PSP) configuration that aligns with the &#39;Restricted&#39; Pod Security Standard. Note: PSPs are deprecated in Kubernetes 1.25+ and replaced by Pod Security Admission."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_POD_SECURITY_STANDARDS",
      "CONTAINER_SECURITY_CONTEXTS",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "A containerized application is running with `CAP_NET_RAW` capability, allowing it to craft raw network packets. Which security context setting should be applied to prevent a container from performing network-level attacks like ARP spoofing or custom packet injection?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets setting confusion: Students confuse general privilege escalation with specific capability management. allowPrivilegeEscalation prevents gaining *new* privileges, but doesn&#39;t remove existing dangerous capabilities like CAP_NET_RAW."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets scope misunderstanding: Students might think restricting filesystem writes prevents all attacks, but network-level attacks using capabilities are independent of filesystem write access."
      },
      {
        "question_text": "seccompProfile.type: RuntimeDefault",
        "misconception": "Targets incomplete mitigation: While `RuntimeDefault` seccomp profiles block many dangerous syscalls, they often do not explicitly drop all capabilities, and `CAP_NET_RAW` might still be allowed depending on the specific profile and kernel version."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `CAP_NET_RAW` capability allows a process to create raw sockets, which is essential for crafting and sending custom network packets. This capability is frequently abused in network-level attacks such as ARP spoofing, custom packet injection, and bypassing network filters. To prevent such attacks, the most effective security context setting is `capabilities.drop: [&quot;ALL&quot;]`, which removes all default capabilities from the container, including `CAP_NET_RAW`. If specific capabilities are needed, they should be explicitly added back using `capabilities.add`.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it does not remove existing dangerous capabilities. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which is good for integrity but irrelevant to network capability abuse. `seccompProfile.type: RuntimeDefault` applies a default seccomp profile that restricts syscalls, but it&#39;s not guaranteed to drop `CAP_NET_RAW` or prevent all forms of capability abuse without explicit capability dropping.",
      "analogy": "Imagine a security guard (container) who has a special tool (CAP_NET_RAW) that lets them tamper with the building&#39;s wiring (network). `capabilities.drop: [&quot;ALL&quot;]` is like taking away all their tools. `allowPrivilegeEscalation: false` is like preventing them from getting *new* tools, but they still have the old ones. `readOnlyRootFilesystem: true` is like locking the tool shed, but they still have the tool in their hand. `seccompProfile.type: RuntimeDefault` is like giving them a basic rulebook, but it might not explicitly forbid using that specific tool."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-network-pod\nspec:\n  containers:\n  - name: my-app\n    image: my-secure-image\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true",
        "context": "Kubernetes Pod manifest demonstrating how to drop all capabilities to prevent network-level attacks."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "LINUX_CAPABILITIES",
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_NETWORK_SECURITY"
    ]
  },
  {
    "question_text": "A Kubernetes cluster is configured with two VPCs, `vpc-target` and `vpc-attacker`, connected via VPC Peering. A `vm-kali` pod in `vpc-attacker` needs to access a `vm-target` pod in `vpc-target`. Which network policy configuration ensures `vm-kali` can initiate connections to `vm-target` while limiting `vm-target` from initiating connections back to `vm-kali`?",
    "correct_answer": "An Egress NetworkPolicy on `vm-kali` allowing traffic to `vm-target`&#39;s CIDR, and an Ingress NetworkPolicy on `vm-target` allowing traffic from `vm-kali`&#39;s CIDR, with no Ingress policy on `vm-kali` from `vm-target`.",
    "distractors": [
      {
        "question_text": "An Ingress NetworkPolicy on `vm-kali` allowing traffic from `vpc-target`&#39;s CIDR, and an Egress NetworkPolicy on `vm-target` allowing traffic to `vpc-attacker`&#39;s CIDR.",
        "misconception": "Targets directionality confusion: Students might confuse Ingress/Egress directions, thinking an Ingress policy on the attacker allows it to initiate connections, or that an Egress policy on the target prevents incoming connections."
      },
      {
        "question_text": "A single Cluster-wide NetworkPolicy allowing all traffic between `vpc-target` and `vpc-attacker`.",
        "misconception": "Targets over-permissioning/scope: Students might opt for broad policies for simplicity, failing to apply the principle of least privilege and ignoring the need for granular control over connection initiation."
      },
      {
        "question_text": "No NetworkPolicy is needed, as VPC Peering and firewall rules already handle traffic flow between the VPCs.",
        "misconception": "Targets Kubernetes vs. Cloud Network Policy scope: Students might confuse cloud-level VPC peering and firewall rules with Kubernetes NetworkPolicies, which operate at a finer-grained, pod-level within the cluster."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To allow `vm-kali` to initiate connections to `vm-target` but prevent `vm-target` from initiating connections back to `vm-kali`, you need to define policies that control the outbound traffic from `vm-kali` and the inbound traffic to `vm-target`. An Egress NetworkPolicy on `vm-kali` explicitly permits outbound traffic to `vm-target`&#39;s IP range. An Ingress NetworkPolicy on `vm-target` explicitly permits inbound traffic from `vm-kali`&#39;s IP range. Crucially, by not having an Ingress policy on `vm-kali` that allows traffic from `vm-target`, `vm-target` cannot initiate connections back to `vm-kali`.",
      "distractor_analysis": "The first distractor reverses the policy directions, which would prevent `vm-kali` from initiating connections. The second distractor suggests a broad policy that violates the principle of least privilege and doesn&#39;t achieve the specific one-way communication requirement. The third distractor incorrectly assumes that VPC peering and cloud firewall rules are sufficient for granular pod-level network segmentation within Kubernetes, ignoring the role of Kubernetes NetworkPolicies.",
      "analogy": "Imagine `vm-kali` as a customer service representative and `vm-target` as a customer. The customer service rep (vm-kali) can call the customer (vm-target), but the customer cannot call the rep back directly; they must wait for the rep to call them. This requires the rep to have permission to make outbound calls to customers, and the customer to be able to receive calls from the rep, but the rep&#39;s phone doesn&#39;t accept incoming calls from customers."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-kali-to-target\n  namespace: attacker-namespace\nspec:\n  podSelector:\n    matchLabels:\n      app: vm-kali\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - ipBlock:\n            cidr: &quot;10.0.1.0/24&quot; # CIDR of vpc-target\n      ports:\n        - protocol: TCP\n          port: 80 # Example port for web access\n---\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-target-from-kali\n  namespace: target-namespace\nspec:\n  podSelector:\n    matchLabels:\n      app: vm-target\n  policyTypes:\n    - Ingress\n  ingress:\n    - from:\n        - ipBlock:\n            cidr: &quot;10.0.2.0/24&quot; # CIDR of vpc-attacker\n      ports:\n        - protocol: TCP\n          port: 80 # Example port for web access",
        "context": "NetworkPolicies to allow vm-kali to initiate connections to vm-target, but not vice-versa, assuming `vpc-target` is 10.0.1.0/24 and `vpc-attacker` is 10.0.2.0/24."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "VPC_PEERING",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges by exploiting vulnerabilities that rely on privilege escalation?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing a container from starting as root with preventing privilege escalation from a non-root user. runAsNonRoot only ensures the initial user is not root."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only prevents all forms of privilege escalation, but it primarily prevents writing to the root filesystem, not exploiting kernel vulnerabilities or capabilities."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete protection: While &#39;privileged: false&#39; is good practice, it doesn&#39;t explicitly prevent privilege escalation if the container still has some capabilities or can exploit other kernel vulnerabilities. It&#39;s a broader setting, not specific to escalation prevention."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting in a container&#39;s security context prevents a process from gaining more privileges than its parent process. Specifically, it prevents the `setuid` and `setgid` bits from being honored if the executable has them, and it prevents a process from gaining capabilities beyond those it already has. This is a direct control against privilege escalation attempts within the container.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container starts as a non-root user but doesn&#39;t prevent that non-root user from escalating privileges if a vulnerability exists. `readOnlyRootFilesystem: true` prevents modifications to the container&#39;s root filesystem but doesn&#39;t stop a process from escalating privileges in memory or through other means. `privileged: false` is a broader setting that removes many host-level privileges, but a non-privileged container can still attempt privilege escalation if `allowPrivilegeEscalation` is not explicitly set to `false`.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re inside, you can&#39;t get a bigger key.&#39; `runAsNonRoot: true` is like saying &#39;only non-managers can enter this area.&#39; You can still be a non-manager and try to steal a manager&#39;s key (escalate privileges) if there&#39;s no rule against it."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-secure-pod\nspec:\n  containers:\n  - name: my-app\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      capabilities:\n        drop: [&quot;ALL&quot;]\n",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` in the security context."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "PRIVILEGE_ESCALATION_CONCEPTS"
    ]
  },
  {
    "question_text": "Which Kubernetes security control is most effective at mitigating the OWASP Top 10 risk of &#39;Injection&#39; in a containerized application?",
    "correct_answer": "Implementing strict input validation and parameterized queries within the application code, combined with Pod Security Standard &#39;Restricted&#39; to prevent privilege escalation.",
    "distractors": [
      {
        "question_text": "Applying a NetworkPolicy to restrict egress traffic from the pod to only necessary external services.",
        "misconception": "Targets control plane confusion: Students confuse network segmentation (NetworkPolicy) with application-level input validation; NetworkPolicy limits blast radius but doesn&#39;t prevent the initial injection."
      },
      {
        "question_text": "Setting `readOnlyRootFilesystem: true` in the container&#39;s security context to prevent writing to the filesystem.",
        "misconception": "Targets scope misunderstanding: Students think filesystem immutability prevents injection, but injection typically targets databases or application logic, not the container&#39;s root filesystem."
      },
      {
        "question_text": "Using a `seccompProfile: RuntimeDefault` to limit syscalls available to the container.",
        "misconception": "Targets partial solution bias: While seccomp is good for general hardening, it&#39;s not the primary defense against Injection, which is an application-level vulnerability. It might prevent some post-injection exploits but not the injection itself."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Injection vulnerabilities (like SQL Injection, Command Injection) occur when untrusted data is sent to an interpreter as part of a command or query. The most effective mitigation is at the application layer: strict input validation to sanitize or reject malicious input, and using parameterized queries or prepared statements to separate data from code. The &#39;Restricted&#39; Pod Security Standard further enhances security by enforcing best practices like `runAsNonRoot` and `allowPrivilegeEscalation: false`, which can limit the impact if an injection leads to code execution.",
      "distractor_analysis": "NetworkPolicy restricts network communication, which is a containment control, not a prevention for injection. `readOnlyRootFilesystem: true` prevents changes to the container&#39;s filesystem but doesn&#39;t stop malicious commands from being executed via an interpreter. `seccompProfile: RuntimeDefault` limits system calls, which is a good defense-in-depth measure against container escapes or privilege escalation, but it doesn&#39;t directly address the root cause of injection vulnerabilities at the application input level.",
      "analogy": "Think of Injection as someone trying to trick a chef into adding poison to a recipe by disguising it as an ingredient. Input validation is like the chef meticulously checking every ingredient before adding it. NetworkPolicy is like locking the kitchen door after the food is served – it prevents further damage but doesn&#39;t stop the initial poisoning. Read-only filesystem is like making sure the recipe book can&#39;t be rewritten, which doesn&#39;t stop the chef from being tricked."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: policy/v1\nkind: PodSecurityConfiguration\nmetadata:\n  name: pss-restricted\nspec:\n  default: Restricted\n  exemptions:\n    namespaces: [&quot;kube-system&quot;]\n",
        "context": "Example of enforcing the &#39;Restricted&#39; Pod Security Standard cluster-wide or per namespace."
      },
      {
        "language": "python",
        "code": "import sqlite3\n\ndef get_user_data(username):\n    conn = sqlite3.connect(&#39;users.db&#39;)\n    cursor = conn.cursor()\n    # Correct: Using parameterized query to prevent SQL Injection\n    cursor.execute(&quot;SELECT * FROM users WHERE username = ?&quot;, (username,))\n    data = cursor.fetchone()\n    conn.close()\n    return data\n\n# Vulnerable example (DO NOT USE IN PRODUCTION):\n# cursor.execute(f&quot;SELECT * FROM users WHERE username = &#39;{username}&#39;&quot;)",
        "context": "Python example demonstrating parameterized query to prevent SQL Injection."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "OWASP_TOP_10",
      "CONTAINER_SECURITY_FUNDAMENTALS",
      "KUBERNETES_SECURITY_CONTEXTS",
      "POD_SECURITY_STANDARDS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting prevents a container from gaining additional privileges beyond those it started with, specifically addressing potential privilege escalation attempts?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "privileged: false",
        "misconception": "Targets scope misunderstanding: Students confuse &#39;privileged&#39; mode (which grants all capabilities and host access) with &#39;privilege escalation&#39; (gaining *additional* privileges from an unprivileged state). Setting privileged: false prevents starting in privileged mode but doesn&#39;t specifically block escalation from an already unprivileged state."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets specific control confusion: Students might think preventing root execution also prevents any privilege escalation. However, runAsNonRoot only ensures the container doesn&#39;t start as UID 0; it doesn&#39;t prevent a non-root user from escalating privileges if other vulnerabilities or capabilities exist."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets mechanism confusion: Students might associate filesystem immutability with preventing all forms of privilege escalation. While it can hinder some escalation techniques that rely on writing to system binaries, it doesn&#39;t directly prevent privilege escalation via kernel exploits or capability abuse."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly controls whether a process can gain more privileges than its parent process. This is crucial for preventing privilege escalation attacks, where an attacker might exploit a vulnerability to elevate their permissions within the container, potentially leading to a container escape. By setting this to `false`, the container&#39;s processes are prevented from using the `setuid` or `setgid` bits, or from executing binaries with capabilities that would grant them higher privileges.",
      "distractor_analysis": "`privileged: false` prevents the container from running in privileged mode, which grants all Linux capabilities and access to host devices. While important, it&#39;s a broader control and doesn&#39;t specifically target the *escalation* of privileges from an already unprivileged state. `runAsNonRoot: true` ensures the container does not run as the root user (UID 0), but a non-root user could still attempt to escalate privileges if allowed. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which can prevent some forms of compromise but doesn&#39;t directly block the mechanism of privilege escalation itself.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says, &#39;Once you&#39;re inside the building, you cannot get a higher security clearance than what you entered with.&#39; `privileged: false` is like saying, &#39;You&#39;re not allowed to enter with a master key.&#39; `runAsNonRoot: true` is like saying, &#39;You can&#39;t be the CEO to enter.&#39; And `readOnlyRootFilesystem: true` is like saying, &#39;You can&#39;t change the building&#39;s blueprints once inside.&#39;"
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` within a security context."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGE_ESCALATION",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "A Kubernetes cluster administrator needs to define an RBAC `ClusterRole` that allows a service account to only view `Pods` and `Deployments` across all namespaces, without any modification capabilities. Which `ClusterRole` definition adheres to the principle of least privilege?",
    "correct_answer": "A `ClusterRole` with `apiGroups: [&quot;&quot;, &quot;apps&quot;]`, `resources: [&quot;pods&quot;, &quot;deployments&quot;]`, and `verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]`.",
    "distractors": [
      {
        "question_text": "A `ClusterRole` with `apiGroups: [&quot;*&quot;]`, `resources: [&quot;*&quot;]`, and `verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]`.",
        "misconception": "Targets excessive resource scope: Students might use wildcards for API groups and resources, granting access to sensitive resources like Secrets or ConfigMaps, even if verbs are restricted to read-only."
      },
      {
        "question_text": "A `Role` with `apiGroups: [&quot;&quot;, &quot;apps&quot;]`, `resources: [&quot;pods&quot;, &quot;deployments&quot;]`, and `verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]` in each namespace.",
        "misconception": "Targets scope confusion (Role vs. ClusterRole): Students confuse namespace-scoped `Role` with cluster-scoped `ClusterRole`. A `Role` cannot grant access across all namespaces, even if duplicated."
      },
      {
        "question_text": "A `ClusterRole` with `apiGroups: [&quot;&quot;, &quot;apps&quot;]`, `resources: [&quot;pods&quot;, &quot;deployments&quot;]`, and `verbs: [&quot;*&quot;]`.",
        "misconception": "Targets excessive verb permissions: Students might use wildcard verbs, granting `create`, `update`, `delete`, etc., which violates least privilege for a view-only requirement."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To view resources across all namespaces, a `ClusterRole` is required, as `Role` is namespace-scoped. The principle of least privilege dictates specifying only the necessary API groups (`&quot;&quot;` for Pods, `&quot;apps&quot;` for Deployments), resources (`pods`, `deployments`), and verbs (`get`, `list`, `watch`) to avoid granting unnecessary permissions like `create`, `update`, or `delete`, or access to other resource types.",
      "distractor_analysis": "Using `apiGroups: [&quot;*&quot;]` or `resources: [&quot;*&quot;]` grants access to all API groups and resources, which is excessive for viewing only Pods and Deployments. A `Role` is namespace-scoped and cannot provide cluster-wide access. Using `verbs: [&quot;*&quot;]` grants all possible actions, including modification and deletion, which is not required for viewing.",
      "analogy": "This is like giving a security guard a master key that only opens the doors to the server rooms (specific resources) and only allows them to look inside (get, list, watch), not to change anything or open other parts of the building (other resources or verbs)."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: pod-deployment-viewer\nrules:\n- apiGroups: [&quot;&quot;, &quot;apps&quot;]\n  resources: [&quot;pods&quot;, &quot;deployments&quot;]\n  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]\n",
        "context": "Least-privilege ClusterRole for viewing Pods and Deployments across all namespaces"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "KUBERNETES_RBAC",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "A container image is found to contain a critical vulnerability in a commonly used library, `libssl.so.1.1`. Which image scanning technique is most effective at detecting this specific type of vulnerability?",
    "correct_answer": "Software Bill of Materials (SBOM) analysis combined with vulnerability database lookup",
    "distractors": [
      {
        "question_text": "Static Application Security Testing (SAST) on the application source code",
        "misconception": "Targets scope confusion (code vs. dependencies): Students might confuse SAST, which analyzes *application code*, with dependency scanning. SAST won&#39;t detect vulnerabilities in pre-compiled system libraries like `libssl.so.1.1` unless the application directly compiles it from source."
      },
      {
        "question_text": "Dynamic Application Security Testing (DAST) during runtime",
        "misconception": "Targets detection method confusion: Students might think DAST, which tests a running application for vulnerabilities, is suitable. DAST is effective for runtime issues (e.g., XSS, SQLi) but less efficient for identifying known vulnerabilities in specific library versions within an image without active exploitation."
      },
      {
        "question_text": "Behavioral analysis during container execution",
        "misconception": "Targets reactive vs. proactive detection: Students might confuse runtime behavioral analysis (which detects anomalous activity) with proactive vulnerability identification. Behavioral analysis might detect *exploitation* of the vulnerability, but not the *presence* of the vulnerable library itself before execution."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Detecting vulnerabilities in specific libraries like `libssl.so.1.1` within a container image requires knowing the components (libraries, packages) present in the image and comparing their versions against known vulnerability databases. Software Bill of Materials (SBOM) analysis generates a list of all software components and their versions, which can then be cross-referenced with vulnerability databases (CVEs) to identify known issues. This is the most direct and effective method for this scenario.",
      "distractor_analysis": "SAST analyzes application source code, not pre-compiled system libraries or dependencies within an image. DAST tests a running application for vulnerabilities but is not designed to enumerate and identify known vulnerabilities in static library files within an image. Behavioral analysis monitors runtime activity for suspicious patterns, which is reactive and doesn&#39;t proactively identify the vulnerable library itself.",
      "analogy": "Imagine you have a box of LEGOs (container image). SBOM analysis is like having a detailed inventory list of every brick (library) and its model number (version), which you can then check against a recall list (vulnerability database). SAST is like checking the instructions for building a specific model, DAST is like testing if the built model falls apart, and behavioral analysis is like watching if someone tries to steal a piece from the built model."
    },
    "code_snippets": [
      {
        "language": "bash",
        "code": "trivy image --format cyclonedx --output sbom.json my-vulnerable-image:latest\ntrivy image my-vulnerable-image:latest",
        "context": "Example commands using Trivy to generate an SBOM and scan an image for vulnerabilities"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "CONTAINER_IMAGE_SCANNING",
      "VULNERABILITY_MANAGEMENT",
      "SBOM_CONCEPTS"
    ]
  },
  {
    "question_text": "Which Pod Security Standard (PSS) profile would explicitly prevent a container from running with the `NET_ADMIN` capability, which allows network interface configuration and firewall manipulation?",
    "correct_answer": "Restricted",
    "distractors": [
      {
        "question_text": "Baseline",
        "misconception": "Targets incomplete understanding of PSS profiles: Students might think Baseline is sufficient for most security needs. While Baseline prevents some dangerous capabilities, it *does not* restrict `NET_ADMIN` by default, allowing it if not explicitly dropped."
      },
      {
        "question_text": "Privileged",
        "misconception": "Targets inverse understanding: Students might confuse &#39;Privileged&#39; as a profile that *enforces* restrictions. The Privileged profile *disables* all security restrictions, allowing any capability, including `NET_ADMIN`."
      },
      {
        "question_text": "Unrestricted",
        "misconception": "Targets non-existent profile: Students might invent a profile name or confuse it with the absence of a profile. &#39;Unrestricted&#39; is not a defined Pod Security Standard profile; the closest concept is the absence of any PSS enforcement, which would allow `NET_ADMIN`."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `Restricted` Pod Security Standard profile is designed for highly-privileged workloads and explicitly disallows the use of most Linux capabilities, including `NET_ADMIN`. It enforces strict security best practices to minimize the attack surface, making it the correct choice for preventing containers from running with dangerous capabilities like `NET_ADMIN`.",
      "distractor_analysis": "The `Baseline` profile is a moderately restrictive profile that allows some capabilities, including `NET_ADMIN`, if not explicitly dropped. The `Privileged` profile is the least restrictive, essentially turning off all security checks and allowing all capabilities. `Unrestricted` is not a valid Pod Security Standard profile name.",
      "analogy": "Think of PSS profiles as security levels for a building. `Restricted` is like a high-security zone where only essential tools are allowed, and network configuration tools (`NET_ADMIN`) are strictly forbidden. `Baseline` is a general access area where some tools are allowed, and `Privileged` is like a construction zone where anything goes."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: restricted-net-admin-pod\n  labels:\n    app: myapp\nspec:\n  securityContext:\n    runAsNonRoot: true\n    seccompProfile:\n      type: RuntimeDefault\n    capabilities:\n      drop: [&quot;ALL&quot;]\n  containers:\n  - name: my-container\n    image: my-image:latest",
        "context": "A Pod manifest that would conform to the Restricted PSS profile, implicitly dropping NET_ADMIN and other capabilities."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "definition",
    "prerequisites": [
      "POD_SECURITY_STANDARDS",
      "LINUX_CAPABILITIES"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges through a `setuid` or `setgid` binary execution?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing initial root execution with preventing privilege escalation; runAsNonRoot prevents the container from starting as root, but doesn&#39;t stop a non-root user from escalating privileges if allowed."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets mechanism confusion: Students might think making the filesystem read-only prevents all privilege escalation, but it primarily prevents writing to the root filesystem, not necessarily executing existing setuid/setgid binaries or exploiting kernel vulnerabilities."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete protection: While `privileged: false` is good practice, it&#39;s a broad setting that removes many host capabilities. `allowPrivilegeEscalation: false` specifically targets the `setuid`/`setgid` mechanism, which `privileged: false` alone doesn&#39;t fully mitigate if other capabilities are present."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly controls whether a process can gain more privileges than its parent. Specifically, it prevents a process from executing a binary with the `setuid` or `setgid` bit set, or from gaining new capabilities. This is a critical control against privilege escalation within a container, as it blocks a common attack vector where an attacker exploits a vulnerability in a `setuid` binary to elevate their privileges to root.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container doesn&#39;t start as root, but a non-root user could still escalate privileges if `allowPrivilegeEscalation` is true. `readOnlyRootFilesystem: true` prevents modifications to the root filesystem but doesn&#39;t stop the execution of existing `setuid` binaries. `privileged: false` removes broad host access but doesn&#39;t specifically target the `setuid`/`setgid` mechanism as directly as `allowPrivilegeEscalation: false` does, and a container could still escalate if other capabilities are present and `allowPrivilegeEscalation` is true.",
      "analogy": "Imagine `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re inside, you can&#39;t pick up a special key that lets you into more secure areas.&#39; `runAsNonRoot` is like saying &#39;you can&#39;t enter the building with a master key to begin with.&#39;"
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      runAsUser: 1000",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` within the container&#39;s security context."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGE_ESCALATION",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "A containerized application is found to be running with `CAP_NET_RAW` capability, allowing it to craft raw network packets. Which `securityContext` setting should be applied to prevent this specific capability from being used?",
    "correct_answer": "capabilities.drop: [&quot;NET_RAW&quot;]",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets setting confusion: Students confuse general privilege escalation prevention with specific capability management; allowPrivilegeEscalation prevents gaining *new* privileges, not dropping existing ones."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets scope misunderstanding: Students think disabling privileged mode removes all dangerous capabilities, but containers still retain default capabilities, including potentially `CAP_NET_RAW`, even when not privileged."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets unrelated control: Students conflate user identity with capabilities; running as a non-root user does not automatically drop specific Linux capabilities like `CAP_NET_RAW`."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `capabilities.drop` field within a container&#39;s `securityContext` is used to remove specific Linux capabilities from the container&#39;s process. Dropping `CAP_NET_RAW` prevents the container from performing raw socket operations, which can be exploited for network-based attacks like spoofing or sniffing. This adheres to the principle of least privilege by removing unnecessary powerful capabilities.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t remove existing capabilities. `privileged: false` ensures the container doesn&#39;t have full access to the host, but it doesn&#39;t explicitly drop individual default capabilities. `runAsNonRoot: true` ensures the container runs as a non-root user, which is good practice, but it&#39;s orthogonal to managing Linux capabilities.",
      "analogy": "Think of `capabilities.drop` as removing specific tools from a toolbox. `CAP_NET_RAW` is like a specialized network tool. You remove it so the worker (container) can&#39;t use it, even if they&#39;re allowed to be in the workshop (container environment)."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: network-restricted-pod\nspec:\n  containers:\n  - name: my-app\n    image: my-image:latest\n    securityContext:\n      capabilities:\n        drop:\n        - NET_RAW",
        "context": "Kubernetes Pod manifest demonstrating how to drop the CAP_NET_RAW capability."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is crucial for preventing a container from gaining elevated privileges beyond its initial configuration, specifically targeting scenarios where an attacker might try to escalate privileges within the container?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope confusion: Students confuse preventing initial root execution with preventing privilege escalation; runAsNonRoot prevents a container from starting as UID 0, but doesn&#39;t stop it from escalating if it starts as a non-root user with certain capabilities."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type misunderstanding: Students might think making the filesystem read-only prevents all privilege escalation, but it primarily prevents writing to the root filesystem, not necessarily gaining new privileges through other means (e.g., kernel exploits, capability abuse)."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete mitigation: Students might believe setting privileged: false is sufficient, but while it prevents the container from having full access to the host, it doesn&#39;t explicitly prevent a non-privileged container from escalating privileges if it retains dangerous capabilities or has other vulnerabilities."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting prevents a process in a container from gaining more privileges than its parent process. This is particularly important for preventing attackers from exploiting vulnerabilities (e.g., SUID binaries, kernel exploits) to escalate their privileges within the container, even if they started as a non-root user. It directly addresses the scenario of an attacker attempting to gain elevated privileges.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container doesn&#39;t start as the root user, but doesn&#39;t prevent privilege escalation from a non-root user. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which is a good security practice but doesn&#39;t directly block privilege escalation mechanisms that don&#39;t involve writing to the root filesystem. `privileged: false` prevents the container from running in privileged mode (which grants all capabilities and access to host devices), but a non-privileged container can still have capabilities that allow for privilege escalation if `allowPrivilegeEscalation` is not set to `false`.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re in, you can&#39;t get a bigger key.&#39; Even if you have a basic key (non-root user), you can&#39;t find a way to get the master key (root privileges) from inside."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      capabilities:\n        drop: [&quot;ALL&quot;]\n",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` within the security context to prevent privilege escalation."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "PRIVILEGE_ESCALATION_CONCEPTS",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges beyond its initial configuration, specifically by disallowing the `setuid` and `setgid` bits from being used to escalate privileges?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing initial root execution with preventing privilege escalation. runAsNonRoot prevents a container from starting as UID 0, but doesn&#39;t stop a non-root user from escalating if allowed by other means."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets mechanism confusion: Students might think making the filesystem read-only prevents all privilege escalation. While it helps by preventing writing to system binaries, it doesn&#39;t directly prevent privilege escalation via `setuid`/`setgid` binaries already present or other kernel exploits."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets incomplete understanding of privilege escalation: While dropping all capabilities is a strong defense, `allowPrivilegeEscalation: false` specifically targets the `setuid`/`setgid` mechanism, which is distinct from capabilities. Dropping capabilities is broader, but `allowPrivilegeEscalation` directly addresses this specific vector."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting in a Kubernetes security context directly controls whether a process can gain more privileges than its parent process. Specifically, it prevents a container process from executing binaries with the `setuid` or `setgid` bits set, which are common mechanisms for privilege escalation within Linux systems. By setting this to `false`, you significantly reduce the attack surface for privilege escalation attempts.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container does not start as the root user (UID 0) but does not prevent a non-root user from escalating privileges if other conditions allow it. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which is good for integrity but doesn&#39;t directly block the `setuid`/`setgid` mechanism for privilege escalation. `capabilities.drop: [&quot;ALL&quot;]` is a very strong control that removes all Linux capabilities, which would indirectly prevent many forms of privilege escalation, but `allowPrivilegeEscalation: false` specifically targets the `setuid`/`setgid` mechanism, which is a distinct and critical vector for privilege escalation.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as disabling the &#39;master key&#39; function on certain doors. Even if someone has a regular key (non-root user), they can&#39;t use a special mechanism (setuid/setgid) to unlock all doors. `runAsNonRoot: true` is like ensuring no one starts with a master key. `readOnlyRootFilesystem: true` is like super-gluing the door frames to prevent tampering, but doesn&#39;t stop someone with a master key from using it. `capabilities.drop: [&quot;ALL&quot;]` is like removing all tools a person might have, which is effective, but `allowPrivilegeEscalation` specifically targets the &#39;master key&#39; mechanism."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: no-priv-escalation-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      runAsUser: 1000",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` within a security context."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGE_ESCALATION_FUNDAMENTALS",
      "CONTAINER_SECURITY_BEST_PRACTICES"
    ]
  },
  {
    "question_text": "A containerized application is found to be vulnerable to Server-Side Request Forgery (SSRF) due to an open redirect, allowing an attacker to make requests from the container&#39;s perspective to internal network resources. Which Kubernetes NetworkPolicy configuration would best mitigate the blast radius of such an SSRF vulnerability?",
    "correct_answer": "A NetworkPolicy that denies egress traffic from the application pod to internal network ranges (e.g., 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) and only permits egress to necessary external services.",
    "distractors": [
      {
        "question_text": "A NetworkPolicy that denies all ingress traffic to the application pod, except from the API server.",
        "misconception": "Targets ingress vs. egress confusion: Students might focus on ingress protection, but SSRF is an egress vulnerability where the compromised application initiates outbound connections."
      },
      {
        "question_text": "A NetworkPolicy that only allows ingress traffic from specific trusted namespaces.",
        "misconception": "Targets scope misunderstanding: While good for general segmentation, this policy primarily addresses lateral movement *into* the pod, not the outbound connections initiated by an SSRF from *within* the pod."
      },
      {
        "question_text": "A NetworkPolicy that denies all egress traffic from the application pod to any IP address outside the cluster.",
        "misconception": "Targets over-restriction: This policy is too restrictive and would break legitimate external communication for the application, which is often necessary. The goal is to block internal network access, not all external access."
      }
    ],
    "detailed_explanation": {
      "core_logic": "SSRF vulnerabilities allow a compromised application to act as a proxy, making requests to internal or external resources from the server&#39;s perspective. To mitigate the blast radius, a NetworkPolicy should restrict the container&#39;s outbound (egress) connections. By denying egress to private IP address ranges (RFC 1918 addresses like 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16), the policy prevents the SSRF from reaching other internal services or infrastructure components, effectively containing the attack to the compromised pod itself. Legitimate external communication should still be allowed.",
      "distractor_analysis": "Denying all ingress traffic (except API server) protects against external attacks *to* the pod, but an SSRF originates *from* the pod. Allowing ingress from trusted namespaces is also an ingress control. Denying all egress outside the cluster is overly broad; the primary concern for SSRF is usually access to *internal* network resources, and most applications need some external connectivity.",
      "analogy": "Imagine an employee (the application) who can make phone calls (network requests). An SSRF is like that employee being tricked into calling internal company numbers and asking for sensitive information. A NetworkPolicy for SSRF is like restricting that employee&#39;s phone to only call approved external vendors, preventing them from calling other internal departments or sensitive internal lines."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-internal-egress\n  namespace: my-app-namespace\nspec:\n  podSelector:\n    matchLabels:\n      app: my-vulnerable-app\n  policyTypes:\n  - Egress\n  egress:\n  - to:\n    - ipBlock:\n        cidr: 0.0.0.0/0\n        except:\n        - 10.0.0.0/8\n        - 172.16.0.0/12\n        - 192.168.0.0/16\n    ports:\n    - protocol: TCP\n      port: 80\n    - protocol: TCP\n      port: 443\n  # Add other necessary external egress rules here\n",
        "context": "Kubernetes NetworkPolicy to prevent egress to internal IP ranges from a specific application pod, while allowing external HTTP/HTTPS."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "SSRF_VULNERABILITIES",
      "NETWORK_SEGMENTATION"
    ]
  },
  {
    "question_text": "A containerized video streaming application allows users to set their username, which is then displayed on their profile page. A security researcher discovers that entering `&lt;script&gt;alert(1)&lt;/script&gt;` into the username field results in a stored Cross-Site Scripting (XSS) vulnerability that triggers for other users viewing the profile. Which container security control is most effective at preventing the *initial injection* of such a payload into the application&#39;s backend data store, assuming the application itself is vulnerable?",
    "correct_answer": "Input validation and sanitization within the application code",
    "distractors": [
      {
        "question_text": "Implementing a strict Kubernetes NetworkPolicy to restrict egress traffic from the application pod",
        "misconception": "Targets control plane confusion: Students might confuse network-level controls with application-level vulnerabilities. NetworkPolicy limits communication but doesn&#39;t prevent malicious input from being processed by the application itself."
      },
      {
        "question_text": "Enforcing a Pod Security Standard (PSS) of &#39;Restricted&#39; on the application&#39;s namespace",
        "misconception": "Targets scope misunderstanding: PSS &#39;Restricted&#39; prevents container runtime privilege escalation and host access, but it does not directly address application-layer vulnerabilities like XSS, which are about how the application processes user input."
      },
      {
        "question_text": "Configuring the container&#39;s securityContext with `readOnlyRootFilesystem: true`",
        "misconception": "Targets irrelevant control: Students might think making the filesystem read-only prevents data modification, but this only applies to the container&#39;s filesystem, not the application&#39;s ability to write to its database or process user input."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The vulnerability described is a classic stored XSS, which is an application-layer flaw. The most effective control to prevent the initial injection of malicious scripts into the application&#39;s backend is robust input validation and sanitization implemented within the application code itself. This ensures that any user-supplied data, like a username, is checked for malicious content and neutralized (e.g., by encoding HTML entities) before being stored or displayed.",
      "distractor_analysis": "Implementing a strict Kubernetes NetworkPolicy restricts network communication but does not prevent a vulnerable application from accepting and storing malicious input. Enforcing a &#39;Restricted&#39; Pod Security Standard prevents container runtime privilege escalation and host access, but it does not address application-level vulnerabilities like XSS. Configuring `readOnlyRootFilesystem: true` makes the container&#39;s filesystem immutable, but it does not prevent the application from processing and storing malicious data in its database or other persistent storage.",
      "analogy": "This is like trying to prevent someone from putting a harmful ingredient into a cake recipe. Network policies are like locking the kitchen door (preventing external access), PSS is like ensuring the baker wears safety gloves (runtime security), and `readOnlyRootFilesystem` is like making sure the recipe book can&#39;t be changed. But the actual prevention of the harmful ingredient (XSS payload) requires the baker (application) to check and filter every ingredient (input) before it goes into the mix."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "CONTAINER_SECURITY_FUNDAMENTALS",
      "APPLICATION_SECURITY_CONCEPTS",
      "XSS_VULNERABILITIES"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges by exploiting a vulnerability that allows it to execute arbitrary code as root?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing initial root execution with preventing privilege escalation. runAsNonRoot prevents starting as root, but doesn&#39;t stop a non-root user from escalating if a vulnerability exists and allowPrivilegeEscalation is true."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only prevents all privilege escalation. While it helps prevent modifying system binaries, it doesn&#39;t directly prevent a process from gaining capabilities or changing its UID/GID if other conditions allow it."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete mitigation: Students may believe that simply not running in privileged mode is sufficient. While privileged mode grants ALL capabilities, disabling it still leaves default capabilities that can be exploited for privilege escalation if allowPrivilegeEscalation is not explicitly set to false."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly prevents a process from gaining more privileges than its parent process. Specifically, it prevents a process from setting the `no_new_privs` bit and prevents it from executing a setuid or setgid binary that would change its user or group ID. This is crucial for preventing privilege escalation even if an attacker manages to execute code within the container.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container doesn&#39;t start as root, but doesn&#39;t prevent a non-root process from escalating privileges later. `readOnlyRootFilesystem: true` prevents modifications to the root filesystem but doesn&#39;t directly block privilege escalation mechanisms like gaining new capabilities. `privileged: false` prevents the container from running with all host capabilities, but default capabilities can still be exploited if `allowPrivilegeEscalation` is not explicitly set to false.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a &#39;no promotion&#39; policy. Even if an employee (process) finds a loophole, they can&#39;t get a higher-level badge (more privileges) than they started with. `runAsNonRoot` is like saying &#39;no managers start in entry-level positions,&#39; but doesn&#39;t stop an entry-level employee from trying to get promoted."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      capabilities:\n        drop: [&quot;ALL&quot;]\n",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` within the security context to prevent privilege escalation."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGES",
      "CONTAINER_VULNERABILITIES"
    ]
  },
  {
    "question_text": "A Kubernetes cluster administrator is preparing to launch a new application to production. The application&#39;s deployment manifest includes a container that requires access to the host&#39;s `/proc` filesystem for monitoring purposes, but should otherwise be strictly isolated. Which security context configuration would allow this specific access while maintaining strong isolation?",
    "correct_answer": "readOnlyRootFilesystem: true, procMount: HostContainer",
    "distractors": [
      {
        "question_text": "privileged: true",
        "misconception": "Targets over-permissioning: Students might think &#39;privileged&#39; is the only way to get host access, but it grants far too many capabilities and full host access, violating least privilege for a specific need."
      },
      {
        "question_text": "hostPath: /proc, mountPath: /host/proc",
        "misconception": "Targets misunderstanding of procMount vs. hostPath: Students might confuse direct hostPath mounts with the more controlled procMount option, not realizing hostPath can expose more than just /proc details."
      },
      {
        "question_text": "allowPrivilegeEscalation: true, capabilities: [&quot;SYS_PTRACE&quot;]",
        "misconception": "Targets incorrect capability usage: Students might associate host access with capabilities like SYS_PTRACE, but this is for process tracing, not direct /proc filesystem access, and allowPrivilegeEscalation is generally discouraged."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `procMount: HostContainer` setting specifically allows a container to mount the host&#39;s `/proc` filesystem, which is often needed for advanced monitoring tools to gather host-level process information. Combining this with `readOnlyRootFilesystem: true` ensures that while the container can read host process information, its own root filesystem remains immutable, enhancing security by preventing unauthorized writes to its own binaries or configurations.",
      "distractor_analysis": "`privileged: true` grants all capabilities and full access to the host, which is excessive for just `/proc` access and highly insecure. Using a `hostPath` volume mount for `/proc` is possible but `procMount: HostContainer` is a more explicit and often preferred way to manage `/proc` access, especially when combined with `readOnlyRootFilesystem`. `allowPrivilegeEscalation: true` and `capabilities: [&quot;SYS_PTRACE&quot;]` are related to process tracing and privilege escalation, not direct, read-only access to the host&#39;s `/proc` filesystem for general monitoring."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: monitoring-pod\nspec:\n  containers:\n  - name: monitor\n    image: my-monitoring-agent:latest\n    securityContext:\n      readOnlyRootFilesystem: true\n      procMount: HostContainer\n    # Other container configurations...",
        "context": "Kubernetes Pod manifest snippet demonstrating specific host /proc access with read-only root filesystem."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_FILESYSTEMS",
      "CONTAINER_ISOLATION"
    ]
  },
  {
    "question_text": "A containerized web application running Apache on OpenSuSE needs to implement a Web Application Firewall (WAF) using ModSecurity. Which `securityContext` setting would prevent the ModSecurity module from loading correctly if the container was configured with overly restrictive permissions?",
    "correct_answer": "readOnlyRootFilesystem: true",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets misunderstanding of privilege escalation: Students might think any module loading is a privilege escalation, but this setting prevents gaining *new* privileges, not executing existing binaries or loading modules."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets confusion between user identity and file system write access: While ModSecurity might run as a non-root user, `runAsNonRoot` itself doesn&#39;t prevent module loading; the issue is write access to configuration files, which is distinct from user ID."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets overgeneralization of capabilities: Students might assume module loading requires special Linux capabilities, but typically, loading an Apache module is a standard process that doesn&#39;t require elevated capabilities like `CAP_SYS_ADMIN` or `CAP_NET_ADMIN`."
      }
    ],
    "detailed_explanation": {
      "core_logic": "ModSecurity requires its configuration files (e.g., `/etc/apache2/conf.d/mod_security2.conf`) to be accessible and potentially modified by Apache during startup or operation, especially if dynamic rule updates or logging are involved. If `readOnlyRootFilesystem: true` is set, the container&#39;s root filesystem becomes immutable, preventing Apache from writing to or even properly loading configuration files that might be expected to be writable or dynamically generated, leading to ModSecurity failing to initialize or function correctly.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, which is not directly related to loading an Apache module. `runAsNonRoot: true` ensures the container process runs as a non-root user, but Apache (and thus ModSecurity) can still load modules as a non-root user if file permissions are correct and the filesystem is writable. `capabilities.drop: [&quot;ALL&quot;]` removes all Linux capabilities, but loading an Apache module typically does not require special capabilities; it&#39;s a standard application function.",
      "analogy": "Imagine trying to install a new security system (ModSecurity) in a house (container) where all the walls (filesystem) are made of solid, unchangeable concrete (`readOnlyRootFilesystem: true`). You can&#39;t drill holes or run wires, so the security system can&#39;t be properly integrated or configured."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: apache-waf\nspec:\n  containers:\n  - name: webapp\n    image: opensuse/apache-modsecurity\n    securityContext:\n      readOnlyRootFilesystem: true # This would cause issues for ModSecurity configuration\n    volumeMounts:\n    - name: apache-config\n      mountPath: /etc/apache2/conf.d\n  volumes:\n  - name: apache-config\n    emptyDir: {}",
        "context": "Kubernetes Pod definition showing `readOnlyRootFilesystem: true` which could prevent ModSecurity from loading or writing logs/configs."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "attack",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_FILESYSTEMS",
      "WEB_APPLICATION_FIREWALLS"
    ]
  },
  {
    "question_text": "A Kubernetes deployment uses a container image that requires access to the host&#39;s `/proc` filesystem for specific monitoring tools. Which `securityContext` setting, if misconfigured, could allow a container to gain dangerous host-level privileges beyond just `/proc` access?",
    "correct_answer": "privileged: true",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: true",
        "misconception": "Targets scope confusion: Students might confuse `allowPrivilegeEscalation` with granting initial broad privileges. While dangerous, it specifically allows a process to gain *more* privileges than its parent, not necessarily all host privileges from the start."
      },
      {
        "question_text": "hostPath mounts for `/proc`",
        "misconception": "Targets mechanism vs. privilege: Students might think `hostPath` mounts themselves grant excessive privileges. While mounting sensitive host paths is risky, the mount itself is a volume configuration, not a `securityContext` setting that grants *all* host privileges."
      },
      {
        "question_text": "runAsUser: 0",
        "misconception": "Targets user vs. capability: Students might confuse running as root inside the container with having full host privileges. Running as root is dangerous but doesn&#39;t automatically grant all host capabilities or bypass kernel security mechanisms like `privileged: true` does."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `privileged: true` setting in a container&#39;s `securityContext` grants the container all capabilities to the host. This effectively disables most security mechanisms and allows the container to interact with the host kernel and devices as if it were a process running directly on the host, making it extremely dangerous and a common source of misconfiguration vulnerabilities. While mounting `/proc` is necessary for some monitoring, `privileged: true` goes far beyond that, granting full host access.",
      "distractor_analysis": "`allowPrivilegeEscalation: true` allows a process to gain more privileges than its parent, but it doesn&#39;t inherently grant all host privileges like `privileged: true` does. `hostPath` mounts allow access to specific host paths, but the `securityContext` setting `privileged: true` grants broader, systemic host access. `runAsUser: 0` means the container runs as root *inside* the container, which is risky, but it doesn&#39;t bypass kernel security mechanisms or grant all host capabilities in the same way `privileged: true` does.",
      "analogy": "Think of `privileged: true` as giving a container the master key to the entire building, allowing it to open any door and access any system. Mounting `/proc` with a `hostPath` is like giving it a specific key to just one room. `allowPrivilegeEscalation: true` is like allowing someone with a basic key to find a way to get a slightly better key, but not necessarily the master key. `runAsUser: 0` is like letting someone be the &#39;manager&#39; of their own office, but they still can&#39;t access other offices without proper keys."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: dangerous-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      privileged: true # DANGEROUS MISCONFIGURATION\n    volumeMounts:\n    - name: proc-volume\n      mountPath: /host/proc\n  volumes:\n  - name: proc-volume\n    hostPath:\n      path: /proc",
        "context": "Example of a Pod manifest with `privileged: true` and a `hostPath` mount for `/proc`."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "attack",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_PRIVILEGES",
      "MISCONFIGURATION_VULNERABILITIES"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from performing actions that require elevated privileges, such as modifying host system files or loading kernel modules?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete understanding of &#39;privileged&#39;: Students might think setting `privileged: false` removes all dangerous capabilities, but it only prevents the container from running with *all* capabilities and access to host devices; it doesn&#39;t explicitly drop default capabilities that can still be exploited."
      },
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets confusion between initial privileges and escalation: Students confuse preventing *initial* elevated privileges with preventing *escalation* to more privileges. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but doesn&#39;t remove existing dangerous capabilities."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets user vs. capability confusion: Students confuse running as a non-root user with preventing privileged actions. While `runAsNonRoot: true` is good practice, a non-root user can still perform privileged actions if granted dangerous capabilities."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `capabilities.drop: [&quot;ALL&quot;]` setting explicitly removes all Linux capabilities from a container. This is the most effective way to prevent a container from performing actions that require elevated privileges, such as interacting with the host kernel, modifying host files, or loading kernel modules, because these actions typically require specific capabilities like `CAP_SYS_ADMIN`, `CAP_DAC_OVERRIDE`, or `CAP_NET_ADMIN`. By dropping all capabilities, the container is severely restricted in what it can do outside its intended scope.",
      "distractor_analysis": "`privileged: false` is the default and prevents the container from running with *all* capabilities and access to host devices, but it still leaves a default set of capabilities that can be exploited. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t remove the initial set of capabilities the container starts with. `runAsNonRoot: true` ensures the container runs as a non-root user, which is a good security practice, but even a non-root user can perform privileged actions if they possess dangerous capabilities.",
      "analogy": "Imagine a security guard. `runAsNonRoot: true` is like making sure the guard isn&#39;t the chief of police. `privileged: false` is like taking away their master key to the entire building. But `capabilities.drop: [&quot;ALL&quot;]` is like taking away *all* their tools – their handcuffs, their radio, their baton – ensuring they can&#39;t perform any &#39;privileged&#39; actions beyond basic observation."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: restricted-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Pod manifest demonstrating `capabilities.drop: [&quot;ALL&quot;]` within a securityContext to prevent privileged actions."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "LINUX_CAPABILITIES",
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which secure development practice, if consistently applied, would most effectively reduce the &#39;identify and patch&#39; cycle by preventing entire classes of vulnerabilities?",
    "correct_answer": "Embedding security controls into the product architecture from the onset of development (Secure-by-Design)",
    "distractors": [
      {
        "question_text": "Performing regular code reviews and testing to identify vulnerabilities",
        "misconception": "Targets reactive vs. proactive confusion: Students might see code reviews and testing as primary prevention, but these are detection mechanisms, not fundamental design-level prevention of vulnerability classes."
      },
      {
        "question_text": "Ensuring suppliers provide CVEs with Root Cause Analysis (RCA) and CWE identification",
        "misconception": "Targets process vs. prevention: Students might confuse improved vulnerability reporting and analysis with direct prevention of vulnerabilities at the design stage. RCA/CWE helps understand, not prevent, the initial flaw."
      },
      {
        "question_text": "Automating patch management processes to speed up remediation",
        "misconception": "Targets remediation vs. prevention: Students might focus on the &#39;patch&#39; aspect of the problem, thinking faster patching solves the root cause, rather than preventing the vulnerabilities from existing in the first place."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The most effective way to reduce the &#39;identify and patch&#39; cycle and eliminate entire classes of vulnerabilities is to adopt a Secure-by-Design approach. This involves embedding security controls and considerations directly into the product architecture from the very beginning of the development lifecycle. By proactively addressing security at the design phase, fundamental flaws that lead to broad categories of vulnerabilities can be prevented, rather than detected and patched later.",
      "distractor_analysis": "Regular code reviews and testing are crucial for detecting vulnerabilities, but they are reactive measures within the development process, not proactive design-level prevention. Ensuring suppliers provide CVEs with RCA and CWE identification is vital for understanding and analyzing vulnerabilities, which can inform future design, but it doesn&#39;t prevent the initial vulnerability from being introduced. Automating patch management speeds up remediation, but it doesn&#39;t address the root cause of why vulnerabilities exist; it&#39;s a response to existing flaws.",
      "analogy": "Imagine building a house. &#39;Secure-by-Design&#39; is like an architect designing the house with reinforced walls and a strong foundation from day one to withstand earthquakes. Performing code reviews is like having inspectors check the house for cracks after it&#39;s built. Ensuring supplier CVEs is like getting detailed reports on why other houses collapsed. Automating patch management is like having a quick crew to fix cracks once they appear. Only the initial design prevents the fundamental problem."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "VULNERABILITY_MANAGEMENT_FUNDAMENTALS",
      "SDLC_SECURITY",
      "SECURE_BY_DESIGN_PRINCIPLES"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from executing arbitrary code by dropping dangerous Linux capabilities, thereby mitigating common container escape techniques?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets partial prevention: Students confuse preventing privilege escalation with dropping initial capabilities. While related, allowPrivilegeEscalation prevents gaining *new* privileges, not removing *existing* dangerous ones like CAP_SYS_ADMIN."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets user vs. capability confusion: Students think running as a non-root user automatically removes dangerous capabilities. A non-root user can still possess and exploit capabilities if not explicitly dropped."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets broad vs. granular control: Students believe setting privileged: false is sufficient. While it removes many host-level privileges, it doesn&#39;t granularly drop specific dangerous capabilities that can still lead to escapes in a non-privileged container."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `capabilities.drop: [&quot;ALL&quot;]` setting explicitly removes all Linux capabilities from a container. This is a critical security control because many container escape techniques and privilege escalation vulnerabilities rely on the presence of dangerous capabilities (e.g., CAP_SYS_ADMIN, CAP_DAC_OVERRIDE, CAP_NET_RAW). By dropping all capabilities, the container&#39;s attack surface is significantly reduced, making it much harder for an attacker to perform actions that could lead to a host compromise.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t remove capabilities the container already has. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, but a non-root user can still exploit dangerous capabilities if they are present. `privileged: false` prevents the container from running in privileged mode, which grants all capabilities and access to host devices, but a non-privileged container can still retain default dangerous capabilities if not explicitly dropped.",
      "analogy": "Dropping all capabilities is like removing all the specialized tools from a toolbox before handing it to someone. Even if they try to &#39;escalate&#39; their access (allowPrivilegeEscalation: false) or aren&#39;t the &#39;foreman&#39; (runAsNonRoot: true), they simply don&#39;t have the tools to do serious damage."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-app\n    image: my-secure-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating `capabilities.drop: [&quot;ALL&quot;]` within the securityContext to enhance container security."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "LINUX_CAPABILITIES",
      "CONTAINER_SECURITY_CONTEXTS",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "Which method is specifically designed to help organizations prioritize vulnerabilities based on their likelihood of being exploited in the near future, rather than just their inherent severity?",
    "correct_answer": "Exploit Prediction Scoring System (EPSS)",
    "distractors": [
      {
        "question_text": "Common Vulnerability Scoring System (CVSS)",
        "misconception": "Targets metric confusion: Students often associate CVSS with prioritization, but CVSS primarily measures inherent severity, not exploitability likelihood, leading to misprioritization."
      },
      {
        "question_text": "Stakeholder-Specific Vulnerability Categorization (SSVC)",
        "misconception": "Targets scope misunderstanding: Students confuse SSVC&#39;s decision-tree approach for operational impact with EPSS&#39;s statistical prediction of exploitability, missing the key difference in focus."
      },
      {
        "question_text": "Common Weakness Enumeration (CWE)",
        "misconception": "Targets classification confusion: Students mistake CWE, which categorizes types of software weaknesses, for a system that prioritizes individual vulnerabilities based on exploitability."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The Exploit Prediction Scoring System (EPSS) provides a data-driven probability of a vulnerability being exploited in the wild within a specific timeframe (e.g., 30 days). Unlike CVSS, which focuses on the inherent severity of a vulnerability, EPSS helps organizations prioritize remediation efforts by indicating which vulnerabilities are most likely to be actively exploited, allowing for more efficient resource allocation.",
      "distractor_analysis": "CVSS (Common Vulnerability Scoring System) calculates a severity score based on factors like impact and exploitability, but it doesn&#39;t predict the likelihood of active exploitation. SSVC (Stakeholder-Specific Vulnerability Categorization) is a decision-tree model that helps organizations make operational decisions about vulnerabilities based on their specific context, not a general exploit prediction. CWE (Common Weakness Enumeration) is a list of common software weakness types, used for classification and root cause analysis, not for prioritizing individual vulnerabilities based on exploitability.",
      "analogy": "If CVSS tells you how dangerous a specific type of weapon is, EPSS tells you the probability of that weapon being used in an attack tomorrow. SSVC helps you decide what to do if that weapon is found in your specific neighborhood, and CWE is like a catalog of all known weapon designs."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "definition",
    "prerequisites": [
      "VULNERABILITY_MANAGEMENT",
      "RISK_PRIORITIZATION"
    ]
  },
  {
    "question_text": "A containerized web application is vulnerable to Persistent Cross-Site Scripting (XSS) due to unsanitized user input. Which securityContext setting would directly prevent the XSS payload from executing JavaScript within the container&#39;s process, assuming the payload attempts to leverage specific Linux capabilities?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope misunderstanding: Students might think preventing privilege escalation also prevents script execution, but XSS typically runs within the existing user&#39;s context and doesn&#39;t inherently require privilege escalation unless it&#39;s part of a broader exploit chain."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might associate &#39;read-only&#39; with preventing malicious writes, but XSS executes in memory within the browser/container process, not by modifying the filesystem. This prevents persistence but not execution."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets user context confusion: While good practice, running as non-root doesn&#39;t prevent XSS payloads from executing JavaScript. XSS exploits the application&#39;s trust in user input, regardless of the user ID running the process, unless the payload specifically requires root privileges (which XSS typically does not)."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Persistent XSS vulnerabilities allow attackers to inject malicious scripts that are stored and then executed by other users. While securityContext settings primarily protect the container from host compromise or privilege escalation, dropping all capabilities (`capabilities.drop: [&quot;ALL&quot;]`) is the most direct way to prevent an XSS payload from leveraging any specific Linux capabilities that might be required for more advanced or container-escaping XSS attacks (e.g., if the payload attempts to interact with the kernel or network in a privileged way). For typical client-side XSS, the primary defense is input sanitization, but `capabilities.drop: [&quot;ALL&quot;]` provides a strong defense-in-depth layer by severely limiting what the container process can do, making it harder for even sophisticated XSS payloads to achieve broader impact beyond the browser context.",
      "distractor_analysis": "allowPrivilegeEscalation: false prevents a process from gaining more privileges than its parent, but XSS typically runs within the existing privileges of the web server process. readOnlyRootFilesystem: true makes the container&#39;s root filesystem immutable, which is good for integrity but doesn&#39;t prevent in-memory script execution. runAsNonRoot: true ensures the container doesn&#39;t run as UID 0, but XSS can still execute effectively as a non-root user within the application&#39;s context.",
      "analogy": "Imagine a web application as a house. XSS is like someone writing a malicious message on a whiteboard inside the house that everyone who enters reads. `capabilities.drop: [&quot;ALL&quot;]` is like removing all tools (hammers, saws, drills) from the house, making it impossible for the malicious message to, for example, try to drill through the wall or tamper with the electrical system, even if it could instruct someone to do so. It limits the potential damage of the message itself."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: xss-vulnerable-app\nspec:\n  containers:\n  - name: web-app\n    image: vulnerable-web-app:latest\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      readOnlyRootFilesystem: true\n      runAsNonRoot: true\n      runAsUser: 1000",
        "context": "Kubernetes Pod manifest demonstrating securityContext settings to mitigate potential XSS impact by dropping all capabilities."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "XSS_VULNERABILITIES",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "A containerized web application is vulnerable to SQL injection due to unsanitized user input. Which Kubernetes security context setting, if properly configured, would prevent the container from executing arbitrary commands on the host, even if SQL injection led to code execution within the container?",
    "correct_answer": "seccompProfile: type: RuntimeDefault",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope confusion: Students might think preventing privilege escalation also prevents arbitrary command execution, but allowPrivilegeEscalation primarily prevents a process from gaining more privileges than its parent, not from executing commands with its existing privileges."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: While readOnlyRootFilesystem prevents writing to the container&#39;s root filesystem, it does not prevent arbitrary command execution if the attacker can write to other mounted volumes or leverage existing binaries."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets user context misunderstanding: Students might believe running as non-root inherently prevents host command execution, but a non-root user can still execute commands if the container has sufficient capabilities or if the host is misconfigured."
      }
    ],
    "detailed_explanation": {
      "core_logic": "SQL injection leading to code execution within a container often involves leveraging system calls. A `seccompProfile` set to `RuntimeDefault` (or a custom profile) restricts the set of allowed system calls, making it significantly harder for an attacker to execute arbitrary commands that could lead to container escape or host compromise. It acts as a syscall filter, preventing malicious operations even if code execution is achieved.",
      "distractor_analysis": "Setting `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t restrict the commands it can execute with its current privileges. `readOnlyRootFilesystem: true` prevents modifications to the container&#39;s root filesystem but doesn&#39;t stop execution of commands from other writable paths or memory. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, which is good practice, but a non-root user can still execute dangerous commands if not restricted by other mechanisms like seccomp.",
      "analogy": "Think of `seccompProfile` as a bouncer at a club who only lets certain types of people (syscalls) in. Even if someone sneaks past the front door (SQL injection), the bouncer prevents them from doing anything truly disruptive inside (executing dangerous syscalls)."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: vulnerable-app\nspec:\n  containers:\n  - name: web-app\n    image: vulnerable-image:latest\n    securityContext:\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest applying a default seccomp profile to a container."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_SECCOMP",
      "CONTAINER_ESCAPE_TECHNIQUES",
      "SQL_INJECTION_BASICS"
    ]
  },
  {
    "question_text": "A Kubernetes application is vulnerable to SQL injection, allowing an attacker to execute OS commands via a compromised database container. Which security context setting, if properly configured, would have prevented the container from issuing OS commands even after a successful SQLi leading to command injection?",
    "correct_answer": "securityContext.capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "securityContext.readOnlyRootFilesystem: true",
        "misconception": "Targets scope misunderstanding: Students might think making the filesystem read-only prevents OS commands, but it only prevents writing to the root filesystem, not executing commands if the necessary binaries are already present and executable."
      },
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets privilege confusion: While good practice, running as a non-root user does not inherently prevent the execution of OS commands if the non-root user has the necessary permissions and capabilities to do so."
      },
      {
        "question_text": "securityContext.allowPrivilegeEscalation: false",
        "misconception": "Targets timing/sequence error: This prevents a process from gaining *more* privileges than its parent, but if the container already has dangerous capabilities (like CAP_SYS_ADMIN), this setting won&#39;t prevent their use for OS command execution."
      }
    ],
    "detailed_explanation": {
      "core_logic": "SQL injection leading to OS command execution often leverages underlying Linux capabilities that allow a process to perform privileged operations. By dropping all capabilities (`CAP_SYS_ADMIN`, `CAP_NET_RAW`, etc.), the container is stripped of the ability to perform many system-level actions, including those required to issue OS commands, even if a command injection vulnerability is exploited. This significantly limits the blast radius of such an attack.",
      "distractor_analysis": "Setting `readOnlyRootFilesystem: true` prevents writing to the container&#39;s root filesystem but does not prevent the execution of existing binaries or commands if the attacker can inject them into a writable location or leverage existing tools. `runAsNonRoot: true` prevents the container from running as UID 0, but a non-root user can still execute OS commands if they have the necessary permissions and capabilities. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but if the container starts with dangerous capabilities, this setting won&#39;t prevent their use.",
      "analogy": "Imagine a safe with a combination lock (SQLi vulnerability). Even if an attacker guesses the combination, dropping all capabilities is like removing all the tools from inside the safe that could be used to break out of the room. They can open the safe, but they can&#39;t escape the room."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: vulnerable-app\nspec:\n  containers:\n  - name: app\n    image: vulnerable-image\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n    # Other securityContext settings like runAsNonRoot: true, readOnlyRootFilesystem: true\n    # and allowPrivilegeEscalation: false are also recommended for defense in depth.\n",
        "context": "Kubernetes Pod manifest demonstrating how to drop all capabilities for a container."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "SQL_INJECTION_IMPACT"
    ]
  },
  {
    "question_text": "A Kubernetes Pod is configured with `securityContext.privileged: true`. Which Pod Security Standard (PSS) profile would explicitly prevent this Pod from being admitted to the cluster?",
    "correct_answer": "Restricted",
    "distractors": [
      {
        "question_text": "Baseline",
        "misconception": "Targets PSS profile misunderstanding: Students might think Baseline is strict enough, but it allows privileged containers as long as other basic security measures are met, which is not the case for &#39;privileged: true&#39;."
      },
      {
        "question_text": "HostProcess",
        "misconception": "Targets PSS profile confusion: Students might confuse HostProcess (specific to Windows nodes) with a general Linux security profile, or misunderstand its purpose as a security enforcement rather than a specific workload type."
      },
      {
        "question_text": "Any profile with `allowPrivilegeEscalation: false`",
        "misconception": "Targets specific setting vs. profile: Students might focus on a single security context setting, not realizing that `privileged: true` is a much broader and more dangerous setting that is explicitly disallowed by the Restricted profile, regardless of `allowPrivilegeEscalation`."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `privileged: true` setting grants a container all capabilities to the host, effectively giving it root access to the node. The Kubernetes Pod Security Standard &#39;Restricted&#39; profile explicitly disallows privileged containers, along with other host-level access and dangerous capabilities, to enforce strong isolation. Any Pod attempting to run with `privileged: true` would be rejected by a cluster enforcing the Restricted profile.",
      "distractor_analysis": "The &#39;Baseline&#39; PSS profile allows privileged containers, making it unsuitable for preventing this. &#39;HostProcess&#39; is a specific profile for Windows nodes and is not a general security enforcement profile for Linux containers. While `allowPrivilegeEscalation: false` is a good practice, it does not prevent a container from being `privileged: true` from the start; the `privileged: true` setting itself is the primary concern and is directly addressed by the Restricted profile.",
      "analogy": "Imagine a building with different security zones. &#39;Restricted&#39; is like a high-security vault that explicitly forbids anyone from bringing in a master key (privileged: true). &#39;Baseline&#39; might allow master keys if they&#39;re only used in certain areas, which isn&#39;t strict enough. &#39;HostProcess&#39; is like a special access pass for a different building entirely."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: privileged-pod\nspec:\n  containers:\n  - name: my-container\n    image: busybox\n    command: [&quot;sleep&quot;, &quot;3600&quot;]\n    securityContext:\n      privileged: true",
        "context": "Example Pod manifest that would be rejected by the Restricted Pod Security Standard profile."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "KUBERNETES_BASICS",
      "POD_SECURITY_STANDARDS",
      "CONTAINER_SECURITY_CONTEXTS"
    ]
  },
  {
    "question_text": "A containerized web application is vulnerable to code injection due to improper input validation, allowing an attacker to execute arbitrary server-side code. Which security context setting, combined with a robust input validation strategy, directly prevents the execution of untrusted code within the container&#39;s process?",
    "correct_answer": "seccompProfile: type: RuntimeDefault or a custom profile that disallows dangerous syscalls",
    "distractors": [
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets scope misunderstanding: Students might think making the filesystem read-only prevents code execution, but it only prevents writing to the root filesystem, not executing code already present or injected into memory/temporary filesystems."
      },
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets control plane confusion: Students confuse privilege escalation with code execution. While important for defense in depth, this setting prevents a process from gaining more privileges than its parent, not from executing arbitrary code it already has access to."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets partial solution bias: Students might believe running as a non-root user is sufficient. While good practice, a non-root user can still execute arbitrary code if the application is vulnerable to injection and the necessary binaries/interpreters are available."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Code injection exploits vulnerabilities in an application&#39;s input handling, allowing an attacker to supply and execute arbitrary code. While input validation is the primary defense, a strong `seccompProfile` acts as a crucial defense-in-depth mechanism. By default, the `RuntimeDefault` seccomp profile restricts a container&#39;s access to a limited set of system calls (syscalls), preventing many dangerous operations that injected code might attempt (e.g., spawning new processes, modifying kernel parameters, or accessing host resources). A custom seccomp profile can further tighten these restrictions, explicitly disallowing syscalls commonly abused by code injection payloads.",
      "distractor_analysis": "`readOnlyRootFilesystem: true` prevents writing to the container&#39;s root filesystem but does not prevent the execution of code that might be injected into memory, temporary filesystems, or existing writable directories. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, which is a good security practice but doesn&#39;t directly stop the initial execution of injected code. `runAsNonRoot: true` ensures the container process doesn&#39;t run as UID 0, reducing the impact of a compromise, but a non-root user can still execute arbitrary code if the application is vulnerable and the environment allows it.",
      "analogy": "Think of input validation as a bouncer checking IDs at the door, ensuring only authorized guests enter. `seccompProfile` is like having a security guard inside who monitors what guests do, immediately stopping them if they try to pick locks or tamper with the building&#39;s infrastructure, even if they managed to sneak past the bouncer."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: vulnerable-app\nspec:\n  containers:\n  - name: webapp\n    image: my-vulnerable-webapp:latest\n    securityContext:\n      seccompProfile:\n        type: RuntimeDefault # Or a custom profile for stricter control\n    ports:\n    - containerPort: 8080",
        "context": "Kubernetes Pod manifest demonstrating the application of a seccomp profile to a container."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_SECCOMP",
      "CODE_INJECTION_VULNERABILITIES",
      "CONTAINER_RUNTIME_SECURITY"
    ]
  },
  {
    "question_text": "A Kubernetes pod is configured with `privileged: true`. Which Pod Security Standard does this configuration violate, and why?",
    "correct_answer": "The Restricted Pod Security Standard, because it disallows privileged containers.",
    "distractors": [
      {
        "question_text": "The Baseline Pod Security Standard, because it disallows privileged containers.",
        "misconception": "Targets misunderstanding of PSS profiles: Students often confuse Baseline with Restricted, but Baseline allows privileged containers, making this incorrect."
      },
      {
        "question_text": "The Baseline Pod Security Standard, because it requires `allowPrivilegeEscalation: false`.",
        "misconception": "Targets incorrect PSS requirement: Students might incorrectly associate `allowPrivilegeEscalation: false` with the Baseline standard, which is not a strict requirement for Baseline."
      },
      {
        "question_text": "The Restricted Pod Security Standard, because it requires `runAsNonRoot: true`.",
        "misconception": "Targets partial understanding of Restricted PSS: While `runAsNonRoot: true` is a requirement for Restricted, it&#39;s not the primary reason `privileged: true` violates it. The direct violation is the privileged container itself."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `privileged: true` setting grants a container all capabilities and access to host devices, effectively removing all security protections. The Restricted Pod Security Standard explicitly disallows privileged containers to enforce strong isolation and prevent host compromise. The Baseline standard, while more permissive, still aims to prevent known privilege escalations but does not prohibit privileged containers outright.",
      "distractor_analysis": "The Baseline standard permits privileged containers, so it&#39;s not violated by `privileged: true`. While `allowPrivilegeEscalation: false` is a good practice, it&#39;s not a strict requirement for the Baseline standard. `runAsNonRoot: true` is indeed a requirement for the Restricted standard, but the direct and most significant violation caused by `privileged: true` is the privileged container itself, not the user ID.",
      "analogy": "Think of Pod Security Standards as different levels of security clearance for a building. &#39;Privileged: true&#39; is like giving someone a master key to every room, including the server room. The &#39;Restricted&#39; standard is like saying &#39;no one gets a master key, ever,&#39; while &#39;Baseline&#39; might allow some master keys under specific, monitored conditions."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: privileged-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      privileged: true",
        "context": "Example of a Kubernetes Pod configuration with `privileged: true`"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "KUBERNETES_BASICS",
      "POD_SECURITY_STANDARDS",
      "CONTAINER_SECURITY_CONTEXTS"
    ]
  },
  {
    "question_text": "A containerized web application processes user input and dynamically constructs XML nodes on the server-side. An attacker crafts a malicious input string containing XML tags to inject a `&lt;userid&gt;0&lt;/userid&gt;` element, aiming to escalate privileges. Which container security control is primarily designed to prevent the *initial compromise* that would allow such an XML injection vulnerability to be exploited?",
    "correct_answer": "Robust input validation and sanitization within the application code",
    "distractors": [
      {
        "question_text": "Applying a NetworkPolicy to restrict egress traffic from the web application container",
        "misconception": "Targets control plane confusion: Students might confuse network segmentation (a containment control) with application-level input validation (a prevention control). NetworkPolicy limits blast radius *after* compromise, not prevents the vulnerability itself."
      },
      {
        "question_text": "Setting `readOnlyRootFilesystem: true` in the container&#39;s security context",
        "misconception": "Targets scope misunderstanding: Students may incorrectly associate filesystem immutability with preventing application-level injection vulnerabilities. This setting prevents writing to the container&#39;s root filesystem, but not the exploitation of application logic flaws."
      },
      {
        "question_text": "Enforcing the Kubernetes `Restricted` Pod Security Standard on the namespace",
        "misconception": "Targets incomplete mitigation: While `Restricted` PSS is good practice, it focuses on preventing container escapes and privilege escalation *from within the container* (e.g., via capabilities, privileged mode), not application-level vulnerabilities like XML injection."
      }
    ],
    "detailed_explanation": {
      "core_logic": "XML injection is an application-level vulnerability where malicious XML input is processed by the application, leading to unintended behavior like privilege escalation. The primary defense against such vulnerabilities is robust input validation and sanitization within the application code itself. This ensures that any user-supplied data is properly escaped or rejected before it can interfere with the application&#39;s XML parsing logic.",
      "distractor_analysis": "NetworkPolicy restricts network communication, which is a containment control for limiting the blast radius *after* a compromise, not preventing the initial application vulnerability. `readOnlyRootFilesystem: true` prevents modifications to the container&#39;s filesystem but does not address how the application processes input. The `Restricted` Pod Security Standard focuses on hardening the container runtime environment (e.g., dropping capabilities, preventing privileged mode) to prevent container escapes, not application-specific injection flaws.",
      "analogy": "Think of XML injection as someone trying to trick a librarian (the application) into giving them special access by writing a fake &#39;admin&#39; note (malicious XML tag) on a book request form (user input). Robust input validation is like the librarian having a strict policy to only accept official, pre-printed forms and ignoring any handwritten notes, preventing the trick from working in the first place."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "WEB_APPLICATION_SECURITY",
      "XML_INJECTION",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from performing XML External Entity (XXE) attacks that exploit local file inclusion by restricting access to the host filesystem?",
    "correct_answer": "readOnlyRootFilesystem: true",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope confusion: Students might confuse general privilege escalation prevention with specific filesystem access control. allowPrivilegeEscalation prevents gaining new privileges, but doesn&#39;t directly restrict read access to the host filesystem."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets mechanism misunderstanding: Students might believe running as a non-root user inherently prevents all file access. While good practice, a non-root user can still read files it has permissions for, and XXE can exploit this if the application has access."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets capability relevance: Students might overgeneralize the impact of dropping capabilities. While dropping capabilities is crucial for overall security, it doesn&#39;t directly prevent a container from reading files it has access to on a mounted filesystem, which is the core of XXE local file inclusion."
      }
    ],
    "detailed_explanation": {
      "core_logic": "XXE attacks often involve tricking the XML parser into reading local files (e.g., /etc/passwd, /proc/self/environ) from the host filesystem. Setting `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem read-only, significantly limiting the ability of an XXE payload to write or modify files, and more importantly, restricting its ability to read sensitive files from the host if they are mounted into the container&#39;s root filesystem. While it doesn&#39;t prevent all XXE, it severely curtails the impact of local file inclusion.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but doesn&#39;t restrict existing file access. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, which is good practice, but a non-root user can still read files it has permissions for. `capabilities.drop: [&quot;ALL&quot;]` removes all Linux capabilities, which is excellent for preventing many types of container escapes, but it doesn&#39;t directly prevent a process from reading files it has access to on a mounted filesystem, which is the primary vector for XXE local file inclusion.",
      "analogy": "Imagine you have a locked safe (the container). `readOnlyRootFilesystem: true` is like welding the safe shut so nothing inside can be taken out or put in, even if someone finds a way to peek inside (XXE). `runAsNonRoot: true` is like making sure the person operating the safe isn&#39;t the master key holder, but they can still access what&#39;s already in the safe. `allowPrivilegeEscalation: false` is like preventing them from finding new keys, and `capabilities.drop: [&quot;ALL&quot;]` is like taking away all their tools, but they can still use their hands to open what&#39;s already accessible."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: xxe-protected-pod\nspec:\n  containers:\n  - name: my-app\n    image: my-vulnerable-app\n    securityContext:\n      readOnlyRootFilesystem: true",
        "context": "Kubernetes Pod manifest demonstrating readOnlyRootFilesystem to mitigate XXE local file inclusion."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "XXE_ATTACKS",
      "CONTAINER_FILESYSTEMS"
    ]
  },
  {
    "question_text": "A Django application is deployed in a Kubernetes cluster. Which Pod Security Standard profile would be most appropriate to enforce a baseline level of security, considering Django&#39;s built-in protections for common web vulnerabilities?",
    "correct_answer": "Baseline",
    "distractors": [
      {
        "question_text": "Privileged",
        "misconception": "Targets misunderstanding of security posture: Students might incorrectly assume &#39;Privileged&#39; offers more security due to its name, or that it&#39;s necessary for web applications, when it actually disables most security mechanisms."
      },
      {
        "question_text": "Restricted",
        "misconception": "Targets over-application of strictness: While &#39;Restricted&#39; is more secure, students might not realize that &#39;Baseline&#39; is often sufficient for applications with inherent protections, and &#39;Restricted&#39; could introduce unnecessary operational overhead for a standard web app."
      },
      {
        "question_text": "Custom (with specific securityContext settings)",
        "misconception": "Targets confusion between profiles and granular settings: Students might think a custom profile is always needed, overlooking that PSS profiles are predefined sets of controls, and individual securityContext settings are used to achieve custom configurations, not define a &#39;Custom&#39; PSS profile."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The &#39;Baseline&#39; Pod Security Standard profile is designed to prevent known privilege escalations and enforce minimal security best practices. Given that Django provides &#39;great, global protections for common vulnerabilities like CSRF, XSS, and injection attacks out-of-the-box,&#39; a &#39;Baseline&#39; profile would complement these application-level protections by ensuring the underlying container runtime adheres to fundamental security principles without imposing overly restrictive policies that might hinder a standard web application&#39;s operation.",
      "distractor_analysis": "The &#39;Privileged&#39; profile offers no security guarantees and allows for full host access, which is highly inappropriate for any production application, especially one with built-in security features. The &#39;Restricted&#39; profile is the most secure, enforcing strong hardening by disallowing all but the most basic container capabilities and user IDs. While ideal for maximum security, it might be overly restrictive for a standard Django app that already has strong application-level protections, potentially requiring more effort to configure. A &#39;Custom&#39; profile isn&#39;t a standard Pod Security Standard profile; rather, individual securityContext settings are used to achieve custom security configurations, which might then align with or deviate from the predefined PSS profiles.",
      "analogy": "If Django&#39;s built-in protections are like a strong front door and good locks on your house, the &#39;Baseline&#39; PSS is like ensuring the windows are closed and the back door is latched – good general security. &#39;Restricted&#39; would be like boarding up all the windows and adding a vault door, which might be overkill if your front door is already very secure and you still need to live in the house comfortably."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: django-app\n  labels:\n    app: django\nspec:\n  securityContext:\n    runAsNonRoot: true\n    seccompProfile:\n      type: RuntimeDefault\n  containers:\n  - name: django-container\n    image: my-django-image:latest\n    ports:\n    - containerPort: 8000\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop:\n        - ALL\n        add:\n        - NET_BIND_SERVICE",
        "context": "Example Pod manifest demonstrating settings typically enforced by a &#39;Baseline&#39; Pod Security Standard profile, suitable for a Django application."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "KUBERNETES_POD_SECURITY_STANDARDS",
      "DJANGO_SECURITY_FEATURES",
      "CONTAINER_SECURITY_CONTEXTS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from performing actions that could lead to a container escape via Linux capabilities like `CAP_SYS_ADMIN`?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets partial understanding of privilege escalation: Students might think preventing privilege escalation is sufficient, but it doesn&#39;t remove capabilities already granted at container start-up."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets confusion between user identity and capabilities: Students may confuse running as a non-root user with preventing privileged operations, but a non-root user can still have dangerous capabilities."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets misunderstanding of &#39;privileged&#39; mode: Students might believe setting `privileged: false` removes all dangerous capabilities, but it only prevents the container from running with all host capabilities; default capabilities are still present."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `capabilities.drop: [&quot;ALL&quot;]` setting explicitly removes all Linux capabilities from the container. This is the most stringent way to prevent a container from performing privileged operations, including those that could lead to a container escape, such as manipulating network interfaces or mounting filesystems, which are often associated with `CAP_SYS_ADMIN`.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t remove capabilities the container already has. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, but a non-root user can still have dangerous capabilities. `privileged: false` is the default and prevents the container from having *all* host capabilities, but it still leaves a default set of capabilities that can be exploited.",
      "analogy": "Imagine a toolbox. `capabilities.drop: [&quot;ALL&quot;]` is like emptying the entire toolbox so an attacker has no tools. `allowPrivilegeEscalation: false` is like preventing someone from getting *new* tools, but they still have the ones they started with. `runAsNonRoot: true` is like saying only junior staff can use the toolbox, but they might still have dangerous tools. `privileged: false` is like giving them a smaller, standard toolbox, but it still contains some dangerous items."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true",
        "context": "Kubernetes Pod manifest demonstrating capability dropping for enhanced security."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "LINUX_CAPABILITIES",
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "What RBAC role is excessively permissive for a service account that only needs to read `ConfigMaps` within its own namespace?",
    "correct_answer": "A ClusterRole with `get`, `list` verbs on `ConfigMaps` and a ClusterRoleBinding.",
    "distractors": [
      {
        "question_text": "A Role with `get`, `list` verbs on `ConfigMaps` and a RoleBinding in the same namespace.",
        "misconception": "Targets misunderstanding of &#39;excessive&#39; in context of least privilege: Students might think this is the correct answer, but it&#39;s actually the most appropriate, not excessive."
      },
      {
        "question_text": "A Role with `*` verbs on `ConfigMaps` and a RoleBinding in the same namespace.",
        "misconception": "Targets verb over-permissioning: Students might focus on the resource scope (namespace) but overlook the excessive wildcard verbs, which grant unnecessary write/delete permissions."
      },
      {
        "question_text": "A ClusterRole with `get`, `list` verbs on `ConfigMaps` and a RoleBinding in the same namespace.",
        "misconception": "Targets incorrect binding type for ClusterRole: Students might correctly identify ClusterRole as potentially excessive but fail to recognize that a ClusterRole cannot be bound by a namespace-scoped RoleBinding."
      }
    ],
    "detailed_explanation": {
      "core_logic": "For a service account that only needs to read `ConfigMaps` within its *own namespace*, a namespace-scoped `Role` and `RoleBinding` are sufficient. Using a `ClusterRole` (even with minimal verbs) and a `ClusterRoleBinding` grants permissions across *all* namespaces, which is excessive for a namespace-specific requirement and violates the principle of least privilege.",
      "distractor_analysis": "A `Role` with `get`, `list` verbs and a `RoleBinding` is the correct, least-privilege configuration. A `Role` with `*` verbs is excessive due to the wildcard verbs, granting more than read access. A `ClusterRole` with a `RoleBinding` is syntactically incorrect; `ClusterRoles` are bound by `ClusterRoleBindings` to grant cluster-wide permissions.",
      "analogy": "If you only need to access your own apartment&#39;s mailbox, getting a key to the entire building&#39;s mailroom (ClusterRole) is excessive. You only need a key to your specific mailbox (Role)."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: configmap-reader-cluster\nrules:\n- apiGroups: [&quot;&quot;]\n  resources: [&quot;configmaps&quot;]\n  verbs: [&quot;get&quot;, &quot;list&quot;]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: read-configmaps-cluster\nspec:\n  roleRef:\n    apiGroup: rbac.authorization.k8s.io\n    kind: ClusterRole\n    name: configmap-reader-cluster\n  subjects:\n  - kind: ServiceAccount\n    name: my-service-account\n    namespace: my-namespace",
        "context": "Example of an excessively permissive ClusterRole and ClusterRoleBinding for a namespace-scoped need."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "KUBERNETES_RBAC",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from performing a &#39;Billion Laughs&#39; type of denial-of-service attack by consuming excessive memory through nested entities, assuming the container&#39;s primary function is to parse untrusted XML?",
    "correct_answer": "resources.limits.memory",
    "distractors": [
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets scope confusion: Students might think running as non-root prevents all DoS attacks, but it doesn&#39;t directly limit resource consumption or prevent parsing vulnerabilities."
      },
      {
        "question_text": "securityContext.readOnlyRootFilesystem: true",
        "misconception": "Targets irrelevant control: Students might associate &#39;read-only&#39; with general security, but this setting prevents writing to the filesystem, not excessive memory allocation during parsing."
      },
      {
        "question_text": "securityContext.allowPrivilegeEscalation: false",
        "misconception": "Targets incorrect attack vector: Students might confuse DoS with privilege escalation, but this setting prevents gaining higher privileges, not resource exhaustion from parsing."
      }
    ],
    "detailed_explanation": {
      "core_logic": "A &#39;Billion Laughs&#39; attack, or XML bomb, exploits XML parsers by using deeply nested entities to cause exponential memory consumption, leading to a denial of service. The most direct and effective Kubernetes control to mitigate this is to set memory limits for the container. When the container attempts to allocate memory beyond its defined limit, the Kubernetes scheduler will terminate the pod, preventing it from impacting other services on the node.",
      "distractor_analysis": "runAsNonRoot: true prevents the container from running as the root user, which is good practice but doesn&#39;t directly limit memory usage. readOnlyRootFilesystem: true prevents writes to the container&#39;s root filesystem, which is a security hardening measure but irrelevant to memory exhaustion from parsing. allowPrivilegeEscalation: false prevents a process from gaining more privileges than its parent, which is crucial for preventing container escapes but not for mitigating memory-based DoS attacks.",
      "analogy": "Setting memory limits is like putting a maximum capacity sign on a restaurant. Even if someone tries to bring in an infinitely expanding party (Billion Laughs attack), the bouncer (Kubernetes) will stop them at the door (terminate the pod) once the capacity is reached, preventing the entire restaurant (node) from being overwhelmed."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: xml-parser-pod\nspec:\n  containers:\n  - name: xml-parser\n    image: my-xml-parser-image\n    resources:\n      limits:\n        memory: &quot;256Mi&quot;\n        cpu: &quot;500m&quot;\n      requests:\n        memory: &quot;128Mi&quot;\n        cpu: &quot;250m&quot;",
        "context": "Kubernetes Pod definition with memory limits to prevent resource exhaustion attacks."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_RESOURCE_MANAGEMENT",
      "CONTAINER_DOS_ATTACKS",
      "XML_VULNERABILITIES"
    ]
  },
  {
    "question_text": "A containerized web application is found to be vulnerable to SQL injection. Which image scanning technique is most effective at detecting this type of vulnerability before deployment?",
    "correct_answer": "Dynamic Application Security Testing (DAST)",
    "distractors": [
      {
        "question_text": "Static Application Security Testing (SAST)",
        "misconception": "Targets scope confusion: SAST analyzes source code without execution, which can find potential SQL injection patterns but often misses context-dependent vulnerabilities or those introduced by libraries/frameworks at runtime."
      },
      {
        "question_text": "Software Composition Analysis (SCA)",
        "misconception": "Targets tool misapplication: SCA focuses on identifying known vulnerabilities in third-party libraries and dependencies, not application-specific code vulnerabilities like SQL injection."
      },
      {
        "question_text": "Vulnerability scanning (OS/package level)",
        "misconception": "Targets layer misunderstanding: This type of scanning checks for vulnerabilities in the operating system and installed packages (e.g., outdated Linux kernel, vulnerable `libc`), not application-level flaws like SQL injection."
      }
    ],
    "detailed_explanation": {
      "core_logic": "SQL injection vulnerabilities are typically discovered by interacting with the running application, sending malicious input, and observing the application&#39;s response or database errors. Dynamic Application Security Testing (DAST) tools perform these types of runtime tests by actively probing the deployed application, making them highly effective for detecting SQL injection.",
      "distractor_analysis": "SAST analyzes source code or binaries without running the application; while it can find patterns that *might* lead to SQL injection, it often has high false positives or misses complex injection points. SCA focuses on known vulnerabilities in third-party components, not custom application code. OS/package level vulnerability scanning checks for vulnerabilities in the base image components (OS, installed packages) but does not test the application&#39;s logic for injection flaws.",
      "analogy": "Think of DAST as a penetration tester actively trying to break into a running house (application) by trying different keys and entry points. SAST is like reviewing the blueprints for design flaws. SCA is like checking if the building materials themselves (libraries) have known defects. OS/package scanning is like checking if the foundation (OS) has cracks."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "CONTAINER_IMAGE_SCANNING",
      "WEB_APPLICATION_VULNERABILITIES",
      "SQL_INJECTION"
    ]
  },
  {
    "question_text": "A Kubernetes deployment runs a web application container that processes user input via web forms and connects to a backend database. Which security context setting, combined with a robust input validation mechanism, is most crucial to prevent SQL injection vulnerabilities if the application code itself is flawed?",
    "correct_answer": "readOnlyRootFilesystem: true",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope confusion: Students might confuse general privilege escalation with database-specific attacks. allowPrivilegeEscalation prevents a process from gaining more privileges than its parent, which is not directly related to preventing SQL injection through application logic."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets user context misunderstanding: While good practice, runAsNonRoot prevents the container from running as UID 0. SQL injection exploits application logic flaws, not necessarily requiring root privileges within the container to manipulate the database."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets broad security control: Students might think &#39;privileged&#39; mode is a catch-all for all vulnerabilities. Disabling privileged mode prevents access to host devices and capabilities but doesn&#39;t directly mitigate application-layer SQL injection flaws."
      }
    ],
    "detailed_explanation": {
      "core_logic": "SQL injection exploits often involve writing malicious data to files or executing commands. By setting `readOnlyRootFilesystem: true`, an attacker who successfully injects SQL commands that attempt to write to the container&#39;s filesystem (e.g., to drop a shell script or modify configuration files) would be prevented from doing so. While input validation is the primary defense, `readOnlyRootFilesystem` acts as a crucial defense-in-depth layer, limiting the impact of a successful injection by preventing persistence or further compromise of the container&#39;s integrity.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, which is not directly related to SQL injection. `runAsNonRoot: true` prevents the container from running as the root user, but SQL injection can occur regardless of the user ID, as it targets application logic and database interaction. `privileged: false` prevents the container from having full access to the host, which is a good general security practice but doesn&#39;t specifically prevent SQL injection attacks that manipulate database queries.",
      "analogy": "Think of `readOnlyRootFilesystem: true` as putting your important documents in a glass case. Even if someone manages to trick you into revealing information (SQL injection), they can&#39;t physically alter or remove the documents because the case is locked and read-only."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: webapp-deployment\nspec:\n  selector:\n    matchLabels:\n      app: webapp\n  template:\n    metadata:\n      labels:\n        app: webapp\n    spec:\n      containers:\n      - name: webapp-container\n        image: my-webapp-image:latest\n        securityContext:\n          readOnlyRootFilesystem: true\n        ports:\n        - containerPort: 80",
        "context": "Kubernetes Deployment manifest snippet showing `readOnlyRootFilesystem: true` for a web application container."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "SQL_INJECTION_VULNERABILITIES",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges by exploiting a vulnerability that allows it to escalate to root within the container?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing a container from starting as root with preventing privilege escalation from a non-root user to root. runAsNonRoot only ensures the initial user is non-root."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only prevents all privilege escalation, but it primarily prevents writing to the root filesystem, not necessarily gaining root privileges through other means (e.g., kernel exploits, capability abuse)."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete protection: While &#39;privileged: false&#39; is crucial, it&#39;s a broader setting that removes many host-level capabilities. &#39;allowPrivilegeEscalation: false&#39; specifically targets the ability to gain *more* privileges than the process already has, which is the direct mechanism for escalating to root from a non-root user."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly controls whether a process can gain more privileges than its parent process. Specifically, it prevents a process from setting the `no_new_privs` bit, which is crucial for preventing privilege escalation, including escalating to root, even if other vulnerabilities exist. This setting is a direct countermeasure to privilege escalation attempts within the container.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container starts as a non-root user but doesn&#39;t prevent that non-root user from escalating to root if a vulnerability allows it. `readOnlyRootFilesystem: true` prevents modifications to the root filesystem but doesn&#39;t stop a process from gaining root privileges in memory or through other kernel interactions. `privileged: false` is a broader setting that removes many host-level capabilities, but `allowPrivilegeEscalation: false` specifically addresses the mechanism of privilege escalation itself, making it the most direct and effective control for this scenario.",
      "analogy": "Imagine a security guard (the container process) who is not allowed to carry a weapon (non-root). `allowPrivilegeEscalation: false` is like a policy that explicitly states this guard cannot pick up a weapon or be given one, even if they find one lying around. `runAsNonRoot: true` just ensures they start without one. `readOnlyRootFilesystem: true` is like locking the armory, but not preventing the guard from finding a weapon elsewhere. `privileged: false` is like removing all their special access keys, but `allowPrivilegeEscalation: false` is the specific rule against gaining *any* new authority."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      runAsUser: 1000\n      capabilities:\n        drop: [&quot;ALL&quot;]\n",
        "context": "Pod security context demonstrating `allowPrivilegeEscalation: false` alongside other hardening measures."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "PRIVILEGE_ESCALATION_CONCEPTS",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "A Kubernetes cluster administrator suspects a container in the &#39;dev&#39; namespace is attempting to establish unauthorized connections to an external database. Which network policy configuration would effectively prevent this specific outbound traffic while allowing necessary internal communication?",
    "correct_answer": "An Egress NetworkPolicy in the &#39;dev&#39; namespace, selecting the specific pod, with rules denying traffic to the external database IP/port but allowing traffic to internal services.",
    "distractors": [
      {
        "question_text": "An Ingress NetworkPolicy in the &#39;dev&#39; namespace, selecting the specific pod, with rules denying traffic from the external database IP/port.",
        "misconception": "Targets Ingress vs. Egress confusion: Students often confuse inbound (Ingress) and outbound (Egress) traffic. An Ingress policy would block incoming connections, not outgoing ones to an external database."
      },
      {
        "question_text": "A Cluster-wide NetworkPolicy denying all egress traffic from all pods, then selectively allowing necessary traffic.",
        "misconception": "Targets scope and granularity misunderstanding: While effective, this is overly broad and would disrupt all cluster communication, requiring extensive whitelisting. The question asks for preventing &#39;this specific outbound traffic&#39; from &#39;a container in the &#39;dev&#39; namespace&#39;, implying a more targeted approach."
      },
      {
        "question_text": "Applying `securityContext.allowPrivilegeEscalation: false` to the container&#39;s manifest.",
        "misconception": "Targets control plane confusion: Students conflate network controls with container runtime security controls. `allowPrivilegeEscalation` prevents privilege escalation within the container, not network communication."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To prevent a container from initiating unauthorized outbound connections, an Egress NetworkPolicy is required. This policy must be applied to the namespace where the container resides (&#39;dev&#39;) and specifically target the pod in question using a `podSelector`. The policy&#39;s egress rules should explicitly deny traffic to the external database&#39;s IP address and port, while also including rules to permit legitimate internal communication to other services within the cluster or allowed external endpoints.",
      "distractor_analysis": "An Ingress NetworkPolicy controls incoming traffic, not outgoing, so it would not prevent the container from connecting to an external database. A cluster-wide policy denying all egress is too broad and would cause significant operational overhead by blocking all legitimate outbound traffic, which is not the most effective or targeted solution for a specific container. `securityContext.allowPrivilegeEscalation: false` is a container runtime security setting that prevents privilege escalation; it has no direct impact on network communication policies.",
      "analogy": "Think of an Egress NetworkPolicy as a bouncer at the exit of a club (your container). The bouncer checks who is trying to leave and where they are going. If they try to go to an unauthorized location (the external database), they are stopped. An Ingress policy would be a bouncer at the entrance, checking who comes in."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-external-db-egress\n  namespace: dev\nspec:\n  podSelector:\n    matchLabels:\n      app: suspicious-app\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - ipBlock:\n            cidr: 10.0.0.0/8 # Example: Allow internal cluster communication\n      ports:\n        - protocol: TCP\n          port: 80\n        - protocol: TCP\n          port: 443\n    - to:\n        - ipBlock:\n            cidr: 192.168.1.0/24 # Example: Allow communication to internal services\n    # Implicitly denies all other egress traffic not explicitly allowed\n    # To explicitly deny a specific external IP, you would define an &#39;except&#39; or ensure it&#39;s not in an &#39;allow&#39; rule.\n    # For a strict deny-by-default, only include allowed traffic.\n",
        "context": "Kubernetes Egress NetworkPolicy to prevent specific outbound connections from a pod."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "NETWORK_SECURITY_FUNDAMENTALS",
      "CONTAINER_NETWORKING"
    ]
  },
  {
    "question_text": "A Kubernetes Pod is configured to run a web application that uses a `UIWebView` (or equivalent in a modern webview component) to render user-supplied content. Which security context setting, if misconfigured, could directly enable a client-side XSS attack within the containerized application by allowing arbitrary script execution?",
    "correct_answer": "This scenario is primarily an application-layer vulnerability (XSS) and is not directly prevented by Kubernetes security context settings. Kubernetes security contexts focus on container runtime privileges, not application-level input sanitization.",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope misunderstanding: Students confuse application-layer vulnerabilities with container privilege escalation. allowPrivilegeEscalation prevents a process from gaining more privileges than its parent, which is unrelated to XSS."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only would prevent script injection. While good for integrity, it doesn&#39;t prevent scripts from executing in memory within the application&#39;s context."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets privilege level confusion: Students might associate root privileges with all vulnerabilities. runAsNonRoot prevents the container from running as UID 0, but an XSS attack can still occur and steal data even if the application runs as a non-root user."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Client-Side Cross-Site Scripting (XSS) is an application-layer vulnerability that occurs when an application renders unsanitized user-supplied data, allowing malicious scripts to execute in the user&#39;s browser or webview. Kubernetes security context settings primarily control the privileges and isolation of the container runtime (e.g., user ID, capabilities, filesystem access). They do not directly address application-level input validation or output encoding, which are the primary mitigations for XSS. Therefore, no Kubernetes security context setting directly prevents an XSS attack; it&#39;s a responsibility of the application developer.",
      "distractor_analysis": "allowPrivilegeEscalation: false prevents a process from gaining more privileges, which is unrelated to script execution within a webview. readOnlyRootFilesystem: true prevents modifications to the container&#39;s root filesystem but does not stop scripts from being injected into and executed by the application&#39;s rendering engine. runAsNonRoot: true prevents the container from running as the root user, but an XSS attack can still be successful and steal data even when the application runs with non-root privileges.",
      "analogy": "Imagine a secure vault (Kubernetes container) with strict rules about who can enter and what tools they can bring (security context). An XSS attack is like someone inside the vault tricking another person into reading a malicious note that causes them to reveal secrets. The vault&#39;s security rules don&#39;t prevent the note from being read; that&#39;s an issue with the person&#39;s judgment (application&#39;s sanitization)."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "XSS_FUNDAMENTALS",
      "APPLICATION_SECURITY_PRINCIPLES"
    ]
  },
  {
    "question_text": "A DevSecOps engineer is reviewing an iOS application that performs input validation on the client-side to prevent SQL injection by stripping special characters like apostrophes and semicolons. What is the primary security flaw in this approach?",
    "correct_answer": "Client-side input validation can be bypassed by an attacker using a proxy to modify requests before they reach the server.",
    "distractors": [
      {
        "question_text": "Blacklisting special characters reduces password complexity, making accounts easier to brute-force.",
        "misconception": "Targets secondary effect as primary flaw: While true that blacklisting reduces complexity, the primary flaw in this context is the bypassability of client-side validation for injection attacks, not password strength."
      },
      {
        "question_text": "Input sanitization should occur as close as possible to the user interface for better usability.",
        "misconception": "Targets misunderstanding of security vs. usability: This statement confuses a usability benefit with a security requirement. While client-side validation improves UX, it&#39;s not a security control against determined attackers."
      },
      {
        "question_text": "Parameterized SQL statements are less efficient than character stripping for preventing injection.",
        "misconception": "Targets technical misunderstanding: This distractor incorrectly suggests a performance trade-off, when parameterized queries are the secure and standard method, and character stripping is an insecure anti-pattern."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Client-side input validation, while useful for improving user experience by providing immediate feedback, is not a reliable security control. An attacker can easily bypass client-side validation by intercepting and modifying network traffic using a proxy before it reaches the server. This allows them to reintroduce &#39;harmful&#39; characters that the client-side validation stripped, making the application vulnerable to server-side injection attacks like SQL injection.",
      "distractor_analysis": "While blacklisting special characters can indeed reduce password complexity, this is a separate issue from the bypassability of client-side validation for injection attacks. The statement about input sanitization occurring close to the UI for usability is correct for user experience, but it&#39;s explicitly stated that this does not provide security against a malicious user. The claim that parameterized SQL statements are less efficient is incorrect; they are the recommended secure practice for preventing SQL injection.",
      "analogy": "Relying solely on client-side validation for security is like putting a &#39;Do Not Enter&#39; sign on a door but leaving the door unlocked. A polite person might heed the sign, but anyone determined can simply ignore it and walk through."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "attack",
    "prerequisites": [
      "IOS_APPLICATION_SECURITY",
      "INPUT_VALIDATION",
      "SQL_INJECTION",
      "CLIENT_SERVER_ARCHITECTURE"
    ]
  },
  {
    "question_text": "Which method is the most effective way to prevent client-side SQL injection vulnerabilities in an iOS application using SQLite?",
    "correct_answer": "Using parameterized statements with placeholders for user-supplied input.",
    "distractors": [
      {
        "question_text": "Escaping all special characters in user input before constructing SQL queries.",
        "misconception": "Targets incomplete mitigation: While escaping characters can help, it&#39;s error-prone and often misses edge cases or new injection techniques, making it less robust than parameterized queries."
      },
      {
        "question_text": "Implementing a Web Application Firewall (WAF) to filter malicious SQL queries.",
        "misconception": "Targets control plane confusion: A WAF operates at the network layer for web applications, not directly on the client-side for local SQLite databases in an iOS app."
      },
      {
        "question_text": "Encrypting the entire SQLite database file.",
        "misconception": "Targets scope misunderstanding: Encryption protects data at rest but does not prevent SQL injection, which is an issue of how queries are constructed and executed, not how data is stored."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Client-side SQL injection occurs when unsanitized, externally supplied data is directly embedded into dynamically constructed SQL statements. Parameterized statements prevent this by separating the SQL logic from the data. The SQL statement is compiled independently with placeholders (e.g., &#39;?&#39;), and then the user-supplied data is bound to these placeholders as values, ensuring that any malicious SQL within the input is treated as data, not executable code.",
      "distractor_analysis": "Escaping special characters is a manual and often incomplete approach; it&#39;s easy to miss characters or misimplement, leading to bypasses. A Web Application Firewall (WAF) is designed for server-side web traffic and has no relevance to client-side SQLite operations within an iOS application. Encrypting the database protects data confidentiality but does not address the vulnerability of how SQL queries are formed and executed, which is the root cause of SQL injection.",
      "analogy": "Think of parameterized statements like a pre-printed form with blank spaces. You fill in the blanks with your information, but you can&#39;t change the questions or structure of the form itself. Dynamically constructed SQL is like writing the entire form, including the questions, based on user input, which allows malicious users to write their own questions."
    },
    "code_snippets": [
      {
        "language": "objective-c",
        "code": "static sqlite3_stmt *selectUid = nil;\nconst char *sql = &quot;SELECT username FROM users where uid = ?&quot;;\nsqlite3_prepare_v2(db, sql, -1, &amp;selectUid, NULL);\nsqlite3_bind_int(selectUid, 1, uid);\nint status = sqlite3_step(selectUid);",
        "context": "Example of a properly parameterized SQLite statement in Objective-C"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "IOS_APPLICATION_SECURITY",
      "SQL_INJECTION_FUNDAMENTALS",
      "SECURE_CODING_PRACTICES"
    ]
  },
  {
    "question_text": "Which `NSPredicate` operator, when used with unvalidated user input, is vulnerable to a bypass using regular expression wildcards like `.*`?",
    "correct_answer": "`MATCHES`",
    "distractors": [
      {
        "question_text": "`CONTAINS[c]`",
        "misconception": "Targets operator confusion: Students might confuse `CONTAINS` (which checks for substring presence) with operators that interpret input as patterns, not realizing `CONTAINS` treats input literally."
      },
      {
        "question_text": "`LIKE`",
        "misconception": "Targets partial understanding of wildcards: Students might correctly identify `LIKE` as vulnerable to SQL-style wildcards (`*` or `%`), but miss that `MATCHES` specifically uses regex wildcards, which is the focus of the question."
      },
      {
        "question_text": "`BEGINSWITH`",
        "misconception": "Targets operator functionality misunderstanding: Students might incorrectly assume `BEGINSWITH` could be manipulated with wildcards, not understanding it performs a literal prefix match."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `MATCHES` operator in `NSPredicate` interprets its right-hand side argument as a regular expression. If unvalidated user input is passed to `MATCHES`, an attacker can supply a regular expression wildcard like `.*` (which matches any character zero or more times) to make the predicate evaluate to true, effectively bypassing authentication or validation checks.",
      "distractor_analysis": "`CONTAINS[c]` performs a case-insensitive substring check and does not interpret wildcards. `LIKE` is vulnerable to SQL-style wildcards (`*` or `%`), but the question specifically asks about regular expression wildcards (`.*`). `BEGINSWITH` performs a literal prefix match and is not vulnerable to wildcard injection in this manner.",
      "analogy": "Think of `MATCHES` as a sophisticated lock that accepts a pattern (regex) instead of a specific key. If you give it a pattern like &#39;any key will do&#39; (`.*`), it will open for anything, whereas `LIKE` is a simpler lock that might accept &#39;any key starting with X&#39; (`X*`)."
    },
    "code_snippets": [
      {
        "language": "objective-c",
        "code": "NSPredicate *pred;\npred = [NSPredicate predicateWithFormat:@&quot;pin MATCHES %@&quot;, [self.pin text]];",
        "context": "Vulnerable `NSPredicate` usage with `MATCHES` operator and user-supplied input."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "attack",
    "prerequisites": [
      "IOS_SECURITY_BASICS",
      "NSPREDICATE_FUNDAMENTALS",
      "REGULAR_EXPRESSIONS"
    ]
  },
  {
    "question_text": "Which `NSXMLParser` configuration setting, if enabled, makes an iOS application vulnerable to XML External Entity (XXE) injection attacks by allowing the parser to fetch content from remote or local resources?",
    "correct_answer": "`setShouldResolveExternalEntities:YES`",
    "distractors": [
      {
        "question_text": "`setDelegate:`",
        "misconception": "Targets function confusion: Students might confuse setting a delegate (for handling parsing events) with a security-sensitive configuration, not realizing it&#39;s for callback management."
      },
      {
        "question_text": "`parserDidStartDocument:`",
        "misconception": "Targets method vs. property confusion: Students might mistake a delegate method for a configuration setting, not understanding that this method is called by the parser, not set on it."
      },
      {
        "question_text": "`initWithContentsOfURL:`",
        "misconception": "Targets instantiation vs. configuration: Students might think the method used to initialize the parser with a URL is the vulnerability, rather than the subsequent configuration that enables external entity resolution."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `shouldResolveExternalEntities` property of `NSXMLParser`, when set to `YES`, instructs the parser to honor Document Type Definitions (DTDs) that can define entities fetched from external URLs or local files. This capability, while intended for legitimate XML processing, can be exploited by attackers to force the application to load malicious external content, disclose local file contents, or consume excessive system resources, leading to data exfiltration or Denial of Service (DoS).",
      "distractor_analysis": "`setDelegate:` is used to assign an object that will receive parsing events, not to control external entity resolution. `parserDidStartDocument:` is a delegate method that gets called when parsing begins; it&#39;s not a configuration setting. `initWithContentsOfURL:` is the initializer that tells the parser where to get its initial XML data, but it&#39;s the `shouldResolveExternalEntities` setting that determines if *additional* external resources referenced within that XML are resolved.",
      "analogy": "Imagine a mailroom (the XML parser) that usually only processes letters from inside the building. `setShouldResolveExternalEntities:YES` is like giving the mailroom a special instruction to also fetch packages from any external address mentioned in the letters, without verifying the sender or content. This opens the door for malicious packages (XXE payloads) to be delivered."
    },
    "code_snippets": [
      {
        "language": "go",
        "code": "NSURL *testURL = [NSURL URLWithString:@&quot;http://api.nostarch.com&quot;];\nNSXMLParser *testParser = [[NSXMLParser alloc] initWithContentsOfURL:testURL];\n[testParser setShouldResolveExternalEntities:YES]; // This line enables XXE vulnerability",
        "context": "Example of NSXMLParser instantiation and configuration that enables external entity resolution, making the application vulnerable."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "attack",
    "prerequisites": [
      "IOS_APPLICATION_SECURITY",
      "XML_BASICS",
      "COMMON_WEB_VULNERABILITIES"
    ]
  },
  {
    "question_text": "When evaluating an iOS application that uses an alternative XML library, which two primary security concerns should a security specialist investigate to prevent injection attacks?",
    "correct_answer": "Ensure external entity expansion is disabled and sanitize externally supplied input for XPath queries.",
    "distractors": [
      {
        "question_text": "Verify the library is open-source and check for known CVEs in its dependency tree.",
        "misconception": "Targets general security best practices vs. specific injection vectors: While important, checking for CVEs and open-source status are general supply chain security practices, not direct mitigations for XML/XPath injection as described."
      },
      {
        "question_text": "Confirm the XML library uses HTTPS for all data fetching and encrypts parsed data at rest.",
        "misconception": "Targets network/data-at-rest security vs. parsing logic: Students confuse data transport and storage security with vulnerabilities arising from how XML data is parsed and processed internally, which is the focus of injection."
      },
      {
        "question_text": "Implement a Web Application Firewall (WAF) to filter XML payloads and restrict network access to the application.",
        "misconception": "Targets infrastructure-level controls vs. application-level code: Students might suggest external infrastructure controls (WAF, network restrictions) which are not directly applicable to securing the internal parsing logic within an iOS mobile application itself."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Alternative XML libraries, while offering performance benefits and features like XPath, introduce specific injection risks. The primary concerns are XML External Entity (XXE) injection, which is mitigated by disabling external entity expansion, and XPath injection, which requires sanitizing externally supplied input before it&#39;s used in XPath queries. Parameterization of XPath queries, similar to SQL injection prevention, is also a key defense.",
      "distractor_analysis": "Checking for CVEs and open-source status are good practices but don&#39;t directly address the XML/XPath injection vectors. Using HTTPS and encrypting data at rest are crucial for data in transit and at rest, respectively, but not for preventing injection flaws during XML parsing. Implementing a WAF or restricting network access are infrastructure-level controls that don&#39;t directly secure the application&#39;s internal XML parsing logic on the device.",
      "analogy": "Think of it like securing a safe: disabling external entity expansion is like ensuring the safe doesn&#39;t automatically open a hidden compartment based on a secret code from an unknown source. Sanitizing XPath input is like making sure that when you ask the safe for a specific item, you&#39;re not accidentally giving it instructions to open other compartments or reveal sensitive information based on your input."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "IOS_APPLICATION_SECURITY",
      "XML_INJECTION",
      "XPATH_INJECTION",
      "XXE_VULNERABILITIES"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges beyond its initial configuration, specifically targeting common privilege escalation techniques?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing initial root execution with preventing privilege escalation; runAsNonRoot prevents starting as root but doesn&#39;t stop a non-root user from escalating privileges if other vulnerabilities exist."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets mechanism confusion: Students might think making the filesystem read-only prevents all privilege escalation, but it primarily prevents writing to the root filesystem, not necessarily gaining higher user privileges or capabilities."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete protection: While &#39;privileged: false&#39; is crucial for security, it&#39;s a broad setting that prevents access to host devices. &#39;allowPrivilegeEscalation: false&#39; specifically targets the `no_new_privs` flag, which is a more direct control against privilege escalation attempts within the container&#39;s existing capabilities."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly maps to the `no_new_privs` flag in Linux. This flag prevents a process from gaining new privileges via `execve` calls, meaning it cannot execute a setuid or setgid binary to become a different user or group, or gain new capabilities. This is a critical control against many common privilege escalation techniques within a container.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container doesn&#39;t start as UID 0, but a non-root user can still escalate privileges if allowed. `readOnlyRootFilesystem: true` prevents modifications to the root filesystem but doesn&#39;t inherently stop privilege escalation if the attacker can exploit other vectors (e.g., kernel vulnerabilities, existing setuid binaries in writable paths). `privileged: false` prevents the container from running in privileged mode, which grants all capabilities and access to host devices, but it doesn&#39;t specifically prevent privilege escalation if the container already has some capabilities or can exploit setuid binaries.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;you can&#39;t get a promotion or a new security clearance once you&#39;re hired, no matter what special training you find.&#39; Other settings might prevent you from starting as the CEO (`runAsNonRoot`) or from having a master key to the building (`privileged`), but `allowPrivilegeEscalation` specifically stops you from climbing the internal ladder."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      capabilities:\n        drop: [&quot;ALL&quot;]\n",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` within a security context."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGE_ESCALATION",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges by disabling the ability to escalate privileges from its parent process?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "privileged: false",
        "misconception": "Targets scope misunderstanding: Students confuse &#39;privileged&#39; mode (which grants all capabilities and host access) with the specific act of privilege escalation. Setting privileged: false is a broader control but doesn&#39;t specifically target the escalation mechanism."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets mechanism confusion: Students might think preventing root execution also prevents privilege escalation. However, a non-root user can still attempt to escalate privileges if allowPrivilegeEscalation is not set to false and other conditions are met."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets incomplete prevention: While dropping all capabilities is a strong control against privilege escalation, allowPrivilegeEscalation: false specifically targets the `no_new_privs` flag, which is a distinct and crucial mechanism for preventing escalation even if some capabilities are retained."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly controls the `no_new_privs` flag on the container process. When this flag is set, a process cannot gain new privileges after its execution, even if it attempts to use `setuid` or `setgid` binaries, or other mechanisms that would typically lead to privilege escalation. This is a critical control for preventing a compromised container from elevating its privileges within the host or other containers.",
      "distractor_analysis": "`privileged: false` prevents the container from running in privileged mode, which grants all capabilities and direct host access, but it doesn&#39;t specifically prevent a non-privileged container from escalating privileges if the `no_new_privs` flag isn&#39;t set. `runAsNonRoot: true` ensures the container starts as a non-root user, but a non-root user can still attempt to escalate privileges. `capabilities.drop: [&quot;ALL&quot;]` removes all Linux capabilities, which is a very strong control against privilege escalation, but `allowPrivilegeEscalation: false` specifically addresses the `no_new_privs` mechanism, which is a distinct and complementary layer of defense."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      capabilities:\n        drop: [&quot;ALL&quot;]\n",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` within the security context."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGE_ESCALATION",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from executing arbitrary code with elevated privileges by dropping all Linux capabilities?",
    "correct_answer": "securityContext.capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "securityContext.allowPrivilegeEscalation: false",
        "misconception": "Targets partial prevention: Students confuse preventing *new* privilege escalation with preventing *existing* capabilities. This only prevents gaining more privileges, not using already assigned ones."
      },
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets user vs. capability confusion: Students conflate running as non-root with capability management. A non-root user can still have dangerous capabilities if not explicitly dropped."
      },
      {
        "question_text": "securityContext.privileged: false",
        "misconception": "Targets broad vs. granular control: Students believe disabling &#39;privileged&#39; mode is sufficient. While important, it&#39;s a broad setting; explicitly dropping capabilities provides more granular and robust protection against specific privilege abuse."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `securityContext.capabilities.drop: [&quot;ALL&quot;]` setting explicitly removes all Linux capabilities from a container. This is a critical security control because many container escape techniques and privilege escalation methods rely on the presence of dangerous capabilities (e.g., CAP_SYS_ADMIN, CAP_NET_RAW). By dropping all capabilities, the container is significantly restricted in what it can do, making it much harder to perform unauthorized actions or escape to the host.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t remove capabilities already assigned. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, but a non-root user can still exploit dangerous capabilities if they are present. `privileged: false` is a good practice, but it doesn&#39;t explicitly drop all capabilities; containers still run with a default set of capabilities unless explicitly dropped.",
      "analogy": "Think of Linux capabilities as a set of special tools a worker might have. `privileged: false` is like saying the worker can&#39;t use the &#39;master key&#39; to the entire building. `runAsNonRoot: true` is like saying the worker isn&#39;t the &#39;boss&#39;. `allowPrivilegeEscalation: false` is like saying the worker can&#39;t get *more* tools than they started with. But `capabilities.drop: [&quot;ALL&quot;]` is like taking *all* the special tools away, leaving them with only basic, safe functions."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: restricted-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating how to drop all capabilities for a container."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_PRIVILEGE_ESCALATION"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges by exploiting a vulnerability that allows it to execute arbitrary code as root inside the container?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing initial root execution with preventing privilege escalation. runAsNonRoot prevents a container from starting as root, but doesn&#39;t stop a non-root user from escalating to root if a vulnerability exists and allowPrivilegeEscalation is true."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only prevents all privilege escalation. While it helps prevent writing to system binaries, it doesn&#39;t prevent in-memory privilege escalation or exploitation of capabilities if they are present."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete mitigation: Students may believe that simply not running in privileged mode is sufficient. While &#39;privileged: true&#39; grants all capabilities and host access, &#39;privileged: false&#39; still allows default capabilities that can be exploited for privilege escalation if allowPrivilegeEscalation is not set to false."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly prevents a process from gaining more privileges than its parent process. Specifically, it prevents the `setuid` and `setgid` bits from being honored, and it prevents a process from gaining capabilities beyond those it already has. This is crucial for stopping an attacker who has achieved arbitrary code execution as a non-root user from escalating to root within the container.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container starts as a non-root user, but if a vulnerability allows a non-root user to escalate, this setting alone won&#39;t stop it. `readOnlyRootFilesystem: true` prevents modifications to the root filesystem, which is a good security practice, but it doesn&#39;t prevent in-memory privilege escalation or the use of existing capabilities. `privileged: false` is a baseline, but containers still run with a default set of capabilities that can be exploited if `allowPrivilegeEscalation` is not explicitly set to `false`.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re in, you can&#39;t get a bigger key.&#39; Even if someone finds a way to pick a lock inside, they can&#39;t then use that to get the master key. `runAsNonRoot` is like making sure they don&#39;t start with a master key in the first place."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      readOnlyRootFilesystem: true\n      capabilities:\n        drop: [&quot;ALL&quot;]\n",
        "context": "Example Pod manifest demonstrating `allowPrivilegeEscalation: false` within a securityContext."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGE_ESCALATION",
      "CONTAINER_VULNERABILITIES"
    ]
  },
  {
    "question_text": "A web application allows users to post messages that are stored on a server and displayed to other users. An attacker embeds a malicious script in their post, which executes in other users&#39; browsers when they view the post. What type of web vulnerability is this, and what is a primary defense against it?",
    "correct_answer": "Stored Cross-Site Scripting (XSS); Input validation and output encoding",
    "distractors": [
      {
        "question_text": "Reflected Cross-Site Scripting (XSS); Web Application Firewall (WAF)",
        "misconception": "Targets XSS type confusion: Students might confuse stored XSS with reflected XSS, which involves non-persistent, immediate execution of malicious scripts from user input in the URL or form fields. While a WAF can help, it&#39;s not the primary defense for stored XSS."
      },
      {
        "question_text": "SQL Injection; Prepared statements",
        "misconception": "Targets vulnerability type confusion: Students might confuse XSS with SQL Injection, which targets the database layer, not the client-side browser. Prepared statements are a defense for SQL Injection, not XSS."
      },
      {
        "question_text": "Cross-Site Request Forgery (CSRF); Anti-CSRF tokens",
        "misconception": "Targets vulnerability type confusion: Students might confuse XSS with CSRF, which tricks authenticated users into performing unintended actions. Anti-CSRF tokens prevent CSRF, but do not protect against malicious script execution in the browser."
      }
    ],
    "detailed_explanation": {
      "core_logic": "This scenario describes Stored (or Persistent) Cross-Site Scripting (XSS), where malicious script is permanently stored on the target server (e.g., in a database) and delivered to other users without their knowledge. The primary defenses against stored XSS are rigorous input validation (sanitizing or rejecting malicious input before storage) and output encoding (converting potentially malicious characters into their HTML entity equivalents before displaying them in the browser), which prevents the browser from interpreting the input as executable code.",
      "distractor_analysis": "Reflected XSS involves non-persistent scripts echoed back from the server in response to user input. SQL Injection targets database queries, not client-side scripts. CSRF tricks users into unintended actions, which is different from executing malicious scripts in their browser. While WAFs can offer some protection, they are not the primary, most effective defense against stored XSS compared to proper input validation and output encoding at the application layer.",
      "analogy": "Imagine a public bulletin board where people can post messages. Stored XSS is like someone writing a hidden message in invisible ink that only appears when someone else reads the board with a special light. Input validation is like the board moderator checking every message for invisible ink before it&#39;s posted. Output encoding is like the moderator rewriting any suspicious characters into harmless symbols so they can&#39;t activate the invisible ink."
    },
    "code_snippets": [
      {
        "language": "python",
        "code": "from html import escape\n\ndef store_message(user_input):\n    # Example of input validation (basic, more complex needed for real-world)\n    if &#39;&lt;script&gt;&#39; in user_input.lower():\n        print(&#39;Malicious script detected! Input rejected.&#39;)\n        return\n    # Store sanitized input\n    print(f&#39;Storing: {user_input}&#39;)\n\ndef display_message(stored_message):\n    # Example of output encoding\n    encoded_message = escape(stored_message)\n    print(f&#39;Displaying: {encoded_message}&#39;)\n\n# Attacker input\nattacker_input = &quot;&lt;p&gt;Hello!&lt;/p&gt;&lt;SCRIPT&gt;alert(&#39;XSS!&#39;)&lt;/SCRIPT&gt;&quot;\n\n# Attempt to store (validation would ideally prevent this)\nstore_message(attacker_input)\n\n# If it somehow got stored, display with encoding\nsafe_message = &quot;&lt;p&gt;Hello!&lt;/p&gt;&lt;SCRIPT&gt;alert(&#39;XSS!&#39;)&lt;/SCRIPT&gt;&quot;\ndisplay_message(safe_message)",
        "context": "Python example demonstrating basic input validation and output encoding to prevent XSS."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "attack",
    "prerequisites": [
      "WEB_VULNERABILITIES",
      "XSS_TYPES",
      "APPLICATION_SECURITY_CONTROLS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from performing actions that require elevated privileges, such as modifying host system settings or loading kernel modules, which could lead to a container escape?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets partial prevention: Students confuse preventing *new* privileges with preventing *all* elevated privileges. allowPrivilegeEscalation only prevents a process from gaining more privileges than its parent, but doesn&#39;t remove existing dangerous capabilities."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets scope misunderstanding: Students think disabling privileged mode is sufficient. While important, privileged: false only removes *all* capabilities and host device access, but containers can still run with default dangerous capabilities if not explicitly dropped."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets user vs. capability confusion: Students conflate running as root with having dangerous capabilities. A non-root user can still possess capabilities like CAP_NET_RAW or CAP_SYS_ADMIN if not dropped, enabling powerful attacks."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `capabilities.drop: [&quot;ALL&quot;]` setting explicitly removes all Linux capabilities from a container. This is the most effective way to prevent a container from performing actions that require elevated privileges, as it strips away the underlying permissions (like CAP_SYS_ADMIN, CAP_NET_RAW, etc.) that attackers exploit for container escapes or host compromise. By default, containers run with a set of capabilities, some of which are dangerous. Dropping all capabilities and then explicitly adding back only those strictly necessary (using `capabilities.add`) adheres to the principle of least privilege.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t remove existing dangerous capabilities. `privileged: false` is the default and prevents the container from running in privileged mode (which grants all capabilities and host device access), but it doesn&#39;t prevent the container from running with the *default* set of capabilities, some of which are still dangerous. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, but a non-root user can still possess and exploit dangerous capabilities if they are not dropped.",
      "analogy": "Imagine a security guard (the container) who is given a master key (all capabilities). `capabilities.drop: [&quot;ALL&quot;]` is like taking away all keys from the guard, leaving them with no special access. `allowPrivilegeEscalation: false` is like saying the guard can&#39;t ask for *more* keys, but they still have the master key they started with. `privileged: false` is like saying the guard can&#39;t wear a special &#39;master guard&#39; uniform, but they still have their default set of keys. `runAsNonRoot: true` is like saying the guard can&#39;t be the &#39;head guard&#39;, but they still might have dangerous keys."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: restricted-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      seccompProfile:\n        type: RuntimeDefault\n      runAsNonRoot: true\n      runAsUser: 1000",
        "context": "Pod security context demonstrating dropping all capabilities for enhanced security."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_PREVENTION"
    ]
  },
  {
    "question_text": "A Kubernetes application is deployed with a container that accepts user-provided configuration via an environment variable. Which security context setting, combined with a robust input validation strategy, best mitigates the risk of command injection through this variable?",
    "correct_answer": "securityContext.capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "securityContext.readOnlyRootFilesystem: true",
        "misconception": "Targets scope misunderstanding: Students might think making the filesystem read-only prevents command injection, but it only prevents writing to the filesystem, not executing commands if the injection occurs in memory or via existing binaries."
      },
      {
        "question_text": "securityContext.allowPrivilegeEscalation: false",
        "misconception": "Targets control confusion: Students might confuse preventing privilege escalation with preventing initial command execution; allowPrivilegeEscalation prevents gaining *new* privileges, not the execution of commands with existing privileges."
      },
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets partial mitigation: While good practice, running as non-root doesn&#39;t prevent command injection itself; a non-root user can still execute malicious commands if the application is vulnerable and has necessary permissions."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Command injection often relies on the ability to execute arbitrary commands, which frequently requires certain Linux capabilities. Dropping all capabilities (`CAP_SYS_ADMIN`, `CAP_NET_RAW`, etc.) significantly restricts what an injected command can do, even if the injection itself is successful. This acts as a strong defense-in-depth layer, limiting the impact of a successful injection by removing the underlying permissions needed for many malicious actions. Input validation is the primary defense, but dropping capabilities is a critical secondary control.",
      "distractor_analysis": "Setting `readOnlyRootFilesystem: true` prevents writing to the container&#39;s root filesystem but does not prevent the execution of commands already present or commands executed in memory. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t stop an already privileged process (even if non-root) from executing injected commands. `runAsNonRoot: true` is a good practice for least privilege, but a non-root user can still execute dangerous commands if the application is vulnerable and the user has the necessary permissions (e.g., to execute `curl` or `wget` to download malware, or to interact with the Docker socket if mounted).",
      "analogy": "If input validation is the lock on the door preventing an attacker from entering, dropping all capabilities is like removing all the valuable items from the room. Even if the attacker bypasses the lock, there&#39;s nothing significant for them to steal or manipulate."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: vulnerable-app\nspec:\n  containers:\n  - name: app\n    image: my-vulnerable-app:latest\n    env:\n    - name: USER_CONFIG\n      value: &quot;$(USER_INPUT)&quot;\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n    # Combined with robust input validation within the application code\n",
        "context": "Kubernetes Pod definition demonstrating dropping all capabilities to mitigate command injection risk."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "COMMAND_INJECTION_VULNERABILITIES"
    ]
  },
  {
    "question_text": "A Kubernetes application is vulnerable to parameter pollution due to an unpatched web server container. Which NetworkPolicy configuration would best limit the blast radius if this vulnerability were exploited to gain unauthorized access to internal services?",
    "correct_answer": "Egress NetworkPolicy restricting outbound connections from the vulnerable pod to only necessary internal services and ports.",
    "distractors": [
      {
        "question_text": "Ingress NetworkPolicy allowing traffic only from the Ingress controller to the vulnerable pod.",
        "misconception": "Targets scope confusion: Students confuse ingress (inbound) with egress (outbound) protection. While good for initial access, it doesn&#39;t limit lateral movement after compromise."
      },
      {
        "question_text": "NetworkPolicy denying all ingress and egress traffic to the namespace containing the vulnerable pod.",
        "misconception": "Targets over-restriction: Students might think denying all traffic is the safest, but this would break the application&#39;s functionality and is not a practical solution for a running service."
      },
      {
        "question_text": "Egress NetworkPolicy allowing all outbound connections to other pods within the same namespace.",
        "misconception": "Targets insufficient restriction: Students might limit to the same namespace but fail to restrict to specific services/ports, still allowing lateral movement to other compromised services within that namespace."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Parameter pollution exploits typically lead to unauthorized access or command execution within the compromised container. To limit the &#39;blast radius&#39; (i.e., prevent the attacker from moving laterally to other internal services), an Egress NetworkPolicy is crucial. This policy should be configured to explicitly allow only the legitimate outbound connections the vulnerable application needs to function (e.g., to a database, an authentication service) and deny all other outbound traffic. This prevents the compromised container from initiating connections to arbitrary internal services or external command-and-control servers.",
      "distractor_analysis": "An Ingress NetworkPolicy is good for preventing initial access but does not help once the container is compromised and an attacker tries to move laterally. Denying all ingress and egress traffic would render the application unusable. Allowing all outbound connections within the same namespace is better than no egress policy, but it&#39;s still too broad and doesn&#39;t enforce the principle of least privilege for network communication, potentially allowing access to other vulnerable services in the same namespace.",
      "analogy": "Imagine a building with a faulty door (parameter pollution vulnerability). An Ingress policy is like securing the main entrance. An Egress policy is like securing all internal doors, ensuring that even if someone gets past the main entrance, they can only go to specific, authorized rooms and cannot wander freely throughout the building."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: restrict-egress-from-webserver\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: webserver\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              app: database\n      ports:\n        - protocol: TCP\n          port: 5432\n    - to:\n        - ipBlock:\n            cidr: 10.0.0.0/8 # Example for internal services, adjust as needed\n      ports:\n        - protocol: TCP\n          port: 8080 # Example for an internal API service",
        "context": "Kubernetes NetworkPolicy to restrict egress traffic from a webserver pod, allowing connections only to a database and an internal API service."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORKING",
      "NETWORK_POLICY_CONCEPTS",
      "CONTAINER_VULNERABILITIES"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges through a `setuid` or `setgid` executable within the container?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing initial root execution with preventing privilege escalation from a non-root user. runAsNonRoot only ensures the container starts as a non-root user, but doesn&#39;t stop that non-root user from escalating privileges if allowed."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets mechanism confusion: Students might think making the filesystem read-only prevents all privilege escalation. While it can hinder some methods (like writing to /etc/passwd), it doesn&#39;t directly prevent privilege escalation via setuid/setgid binaries already present or other kernel-level exploits."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete protection: Students may believe that simply not running in privileged mode is sufficient. While privileged mode grants extensive host access, allowPrivilegeEscalation specifically targets the `no_new_privs` flag, which is crucial for preventing setuid/setgid escalation even in non-privileged containers."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly corresponds to the `no_new_privs` flag in Linux. When this flag is set, a process cannot gain new privileges, even if it executes a `setuid` or `setgid` binary. This is a critical control for preventing privilege escalation within a container, as it stops a non-root user from becoming root (or another privileged user) by executing a specially crafted or vulnerable binary.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container starts as a non-root user but doesn&#39;t prevent that non-root user from escalating privileges if `allowPrivilegeEscalation` is true. `readOnlyRootFilesystem: true` prevents writing to the root filesystem, which can hinder some escalation techniques but doesn&#39;t directly address the `setuid`/`setgid` mechanism. `privileged: false` prevents the container from having full access to the host, but a non-privileged container can still escalate privileges if `allowPrivilegeEscalation` is not set to false and it can execute a `setuid` binary.",
      "analogy": "Imagine `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re in the building, you can&#39;t get a higher security clearance, no matter what special keys you find.&#39; `runAsNonRoot: true` is like saying &#39;you must enter as a regular employee, not a manager.&#39; Even a regular employee could find a manager&#39;s key (setuid binary) and gain higher access if the &#39;no new clearance&#39; rule isn&#39;t in place."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: no-escalation-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-secure-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      runAsUser: 1000",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` to prevent privilege escalation."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGE_ESCALATION",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from executing arbitrary code as the root user by dropping all Linux capabilities?",
    "correct_answer": "securityContext.capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets partial solution bias: Students might think preventing root user execution is sufficient, but a non-root user with dangerous capabilities can still perform privileged actions."
      },
      {
        "question_text": "securityContext.allowPrivilegeEscalation: false",
        "misconception": "Targets scope confusion: Students confuse preventing privilege escalation with preventing initial privileged execution. This setting prevents gaining *new* privileges, not starting with them."
      },
      {
        "question_text": "securityContext.privileged: false",
        "misconception": "Targets incomplete understanding: Students may believe setting privileged to false removes all dangerous capabilities, but containers still retain a default set of capabilities that can be exploited."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `securityContext.capabilities.drop: [&quot;ALL&quot;]` setting explicitly removes all Linux capabilities from the container. This is the most effective way to prevent a container from performing privileged operations, including executing arbitrary code as root, even if it somehow manages to run as UID 0. By dropping all capabilities, the container loses the ability to interact with the kernel in privileged ways, significantly reducing the attack surface.",
      "distractor_analysis": "`runAsNonRoot: true` prevents the container from running as UID 0, but a non-root user with certain capabilities (e.g., `CAP_NET_RAW`) can still be dangerous. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t prevent the container from starting with dangerous capabilities. `privileged: false` is the default and prevents access to all host devices, but it still leaves a default set of capabilities that can be exploited for container escapes or privileged actions.",
      "analogy": "Dropping all capabilities is like removing all the specialized tools from a toolbox, leaving only basic hand tools. Even if someone gets into the workshop, they can&#39;t perform complex, dangerous operations without those specialized tools."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true\n      allowPrivilegeEscalation: false",
        "context": "Kubernetes Pod manifest demonstrating dropping all capabilities for enhanced security."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "Which Pod Security Standard (PSS) profile would explicitly prevent a container from mounting the host&#39;s Docker socket (`/var/run/docker.sock`)?",
    "correct_answer": "Restricted",
    "distractors": [
      {
        "question_text": "Baseline",
        "misconception": "Targets incomplete understanding of PSS profiles: Students might think Baseline is strict enough, but it allows hostPath volumes, which can be exploited to mount sensitive host paths like the Docker socket."
      },
      {
        "question_text": "Privileged",
        "misconception": "Targets inverse understanding: Students might confuse &#39;Privileged&#39; as the most secure, or misunderstand that it *allows* all capabilities and host access, making it the least secure."
      },
      {
        "question_text": "Standard",
        "misconception": "Targets non-existent profile: Students might invent a &#39;Standard&#39; profile, indicating a lack of familiarity with the actual PSS profiles (Privileged, Baseline, Restricted)."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `Restricted` Pod Security Standard profile explicitly disallows the use of `hostPath` volumes, which is the mechanism used to mount the host&#39;s Docker socket (`/var/run/docker.sock`) into a container. Mounting the Docker socket grants the container control over the Docker daemon on the host, effectively leading to a container escape. The `Restricted` profile is designed for highly sensitive applications and enforces strong hardening practices.",
      "distractor_analysis": "The `Baseline` profile allows `hostPath` volumes, making it insufficient to prevent mounting the Docker socket. The `Privileged` profile explicitly allows all capabilities and host access, including `hostPath` volumes, and is the least secure. &#39;Standard&#39; is not a recognized Pod Security Standard profile.",
      "analogy": "If your house has three security levels: &#39;Privileged&#39; means all doors and windows are open. &#39;Baseline&#39; means doors are locked, but you can still open windows. &#39;Restricted&#39; means all doors and windows are locked and sealed, preventing any unauthorized access to the outside."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: policy.k8s.io/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: restricted\nspec:\n  privileged: false\n  allowPrivilegeEscalation: false\n  hostNetwork: false\n  hostPID: false\n  hostIPC: false\n  volumes:\n    - &#39;configMap&#39;\n    - &#39;emptyDir&#39;\n    - &#39;projected&#39;\n    - &#39;secret&#39;\n    - &#39;downwardAPI&#39;\n    - &#39;persistentVolumeClaim&#39;\n  # hostPath is explicitly NOT allowed in a Restricted profile\n  # ... other restricted settings ...",
        "context": "Excerpt from a Pod Security Policy (PSP) that aligns with the Restricted Pod Security Standard, showing the exclusion of hostPath volumes. Note: PSPs are deprecated, but the principles apply to Pod Security Admission."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_POD_SECURITY_STANDARDS",
      "CONTAINER_ESCAPE_TECHNIQUES",
      "HOSTPATH_VULNERABILITIES"
    ]
  },
  {
    "question_text": "Which `securityContext` setting prevents a container from gaining additional privileges by ensuring that `setuid` and `setgid` bits on executables do not grant elevated permissions?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing initial root execution with preventing privilege escalation from a non-root user. runAsNonRoot only prevents starting as root."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets over-generalization: While dropping all capabilities is a strong defense, allowPrivilegeEscalation specifically targets the `setuid`/`setgid` mechanism, which is a distinct privilege escalation vector not solely covered by capabilities."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets mechanism confusion: Students might think making the filesystem read-only prevents privilege escalation, but it primarily prevents writing to the root filesystem, not the execution of existing setuid/setgid binaries."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly controls the `NO_NEW_PRIVS` flag on the container process. When this flag is set, it prevents a process from gaining new privileges, specifically by disabling the effect of `setuid` and `setgid` bits on executables. This means that even if a container executes a binary with these bits set, it will not gain the permissions of the file owner, effectively blocking a common privilege escalation vector.",
      "distractor_analysis": "`runAsNonRoot: true` prevents the container from starting as the root user, but a non-root user can still attempt privilege escalation. `capabilities.drop: [&quot;ALL&quot;]` removes all Linux capabilities, which is a broader security measure, but `allowPrivilegeEscalation: false` specifically addresses the `setuid`/`setgid` mechanism. `readOnlyRootFilesystem: true` prevents modifications to the root filesystem but does not inherently stop the execution of existing `setuid`/`setgid` binaries from granting privileges.",
      "analogy": "This is like a security guard who is explicitly told, &#39;You cannot take on any new responsibilities or powers, even if someone hands you a badge for it.&#39; It prevents the guard from escalating their authority beyond their initial assignment."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: no-priv-escalation-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` to prevent privilege escalation."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGE_ESCALATION",
      "SETUID_SETGID"
    ]
  },
  {
    "question_text": "An ethical hacker is analyzing a suspicious binary and finds that it terminates unexpectedly when attached to a debugger. Which anti-analysis technique is likely being employed?",
    "correct_answer": "Anti-Debugging",
    "distractors": [
      {
        "question_text": "Anti-Sandboxing",
        "misconception": "Targets confusion between analysis environments: Students might confuse debugger detection with sandbox detection, especially if they view both as &#39;analysis environments&#39; that the malware tries to evade."
      },
      {
        "question_text": "Code Packing",
        "misconception": "Targets confusion between obfuscation and active evasion: Students might think Code Packing (obfuscation) is responsible for the active termination, rather than a specific detection mechanism like Anti-Debugging."
      },
      {
        "question_text": "Traffic Encryption",
        "misconception": "Targets unrelated security controls: Students might incorrectly associate traffic encryption (a network-level control) with binary analysis evasion, demonstrating a misunderstanding of the scope of anti-analysis techniques."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Anti-Debugging techniques are designed to detect the presence of a debugger. When a debugger is detected, the malicious binary might alter its execution flow, terminate itself, or exhibit benign behavior to prevent security analysts from understanding its true malicious functionality. The unexpected termination is a classic sign of anti-debugging measures.",
      "distractor_analysis": "Anti-Sandboxing would involve detecting a virtual environment, not specifically a debugger, and might lead to different evasive actions. Code Packing obfuscates the code but doesn&#39;t inherently cause termination upon debugger attachment; it makes the code harder to read. Traffic Encryption is a network communication security measure and is unrelated to binary analysis evasion.",
      "analogy": "This is like a secret agent who has a self-destruct mechanism that activates if they detect they&#39;re being interrogated. The debugger is the interrogation, and the termination is the self-destruct."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "ETHICAL_HACKING_SKILLS",
      "MALWARE_ANALYSIS_BASICS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from executing arbitrary commands on the host via a command injection vulnerability?",
    "correct_answer": "seccompProfile: type: RuntimeDefault",
    "distractors": [
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets scope misunderstanding: While useful for preventing changes to the container&#39;s filesystem, it does not prevent command execution if the injected command targets a writable volume or memory, or if the command is executed within the container&#39;s existing writable paths."
      },
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets mechanism confusion: This prevents a non-privileged process from gaining more privileges than its parent, but it doesn&#39;t directly stop the initial execution of an injected command if the container already has sufficient privileges to run it."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets privilege level confusion: Running as a non-root user reduces the impact of a command injection, but it does not prevent the execution of arbitrary commands within the container&#39;s non-root context, which can still be harmful."
      }
    ],
    "detailed_explanation": {
      "core_logic": "A command injection vulnerability allows an attacker to execute arbitrary commands. `seccompProfile: type: RuntimeDefault` applies a default seccomp profile that restricts the syscalls a container can make. This profile typically blocks dangerous syscalls that could be used to escape the container or interact with the host kernel in malicious ways, thereby mitigating the impact of command injection by preventing the execution of many harmful commands.",
      "distractor_analysis": "`readOnlyRootFilesystem: true` prevents modifications to the container&#39;s root filesystem but doesn&#39;t stop command execution within writable areas or memory. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges, but an injected command might not require privilege escalation to be harmful. `runAsNonRoot: true` ensures the container runs as a non-root user, which is good practice, but it doesn&#39;t prevent the execution of arbitrary commands within the non-root context, which can still be used for data exfiltration or lateral movement.",
      "analogy": "Think of `seccompProfile` as a bouncer at a club, only allowing specific, pre-approved actions (syscalls). If someone tries to sneak in a dangerous action (injected command), the bouncer blocks it. Other settings might make the club safer (non-root user) or prevent people from getting extra privileges (no privilege escalation), but the bouncer directly controls what actions are allowed."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Pod configuration applying the default seccomp profile to restrict syscalls."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_SECCOMP",
      "CONTAINER_VULNERABILITIES"
    ]
  },
  {
    "question_text": "Which Pod Security Standard would prevent a container from running with `CAP_NET_ADMIN` capability, which could be exploited for network-related container escapes or host network manipulation?",
    "correct_answer": "Restricted",
    "distractors": [
      {
        "question_text": "Baseline",
        "misconception": "Targets partial understanding of PSS profiles: Students might think Baseline is sufficient for most security, but it allows some capabilities like CAP_NET_ADMIN that Restricted disallows."
      },
      {
        "question_text": "Privileged",
        "misconception": "Targets misunderstanding of PSS intent: Students might confuse &#39;Privileged&#39; as a security standard with &#39;privileged mode&#39; for containers, or incorrectly assume it&#39;s the most secure due to its name."
      },
      {
        "question_text": "HostProcess",
        "misconception": "Targets confusion with Windows containers: Students might incorrectly associate HostProcess with Linux container security or misinterpret its purpose as a security standard rather than a specific Windows container feature."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `Restricted` Pod Security Standard is designed to enforce hardening best practices. It prevents containers from running with dangerous capabilities, including `CAP_NET_ADMIN`, which allows for network interface configuration, firewall rule manipulation, and other actions that could lead to container escape or significant network impact on the host. The `Restricted` profile explicitly disallows the addition of any capabilities beyond the default set, and often requires dropping all capabilities.",
      "distractor_analysis": "`Baseline` allows the addition of capabilities, including `CAP_NET_ADMIN`, making it insufficient to prevent this specific vulnerability. `Privileged` is the least restrictive standard, essentially allowing full access to the host and all capabilities, which is the opposite of what&#39;s needed. `HostProcess` is a feature for Windows containers to run processes directly on the host, not a Pod Security Standard for Linux containers or a general security profile.",
      "analogy": "Think of Pod Security Standards like different levels of security checks at an airport. `Privileged` is like walking straight onto the plane with no checks. `Baseline` is a basic check, allowing some items that could be dangerous. `Restricted` is a thorough check, disallowing all potentially dangerous items, including specific tools (capabilities) that could be used for malicious purposes."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: restricted-psp\nspec:\n  privileged: false\n  allowPrivilegeEscalation: false\n  requiredDropCapabilities:\n    - ALL\n  # ... other restricted settings\n---\n# Example Pod that would be blocked by Restricted PSS due to CAP_NET_ADMIN\napiVersion: v1\nkind: Pod\nmetadata:\n  name: network-admin-pod\nspec:\n  containers:\n  - name: my-container\n    image: busybox\n    command: [&quot;sh&quot;, &quot;-c&quot;, &quot;ip link add dummy0 type dummy&quot;]\n    securityContext:\n      capabilities:\n        add:\n        - NET_ADMIN",
        "context": "A Pod Security Policy (PSP) configuration that aligns with the Restricted standard, and an example pod that would be blocked if it tried to add CAP_NET_ADMIN."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "POD_SECURITY_STANDARDS",
      "LINUX_CAPABILITIES",
      "CONTAINER_SECURITY_CONTEXTS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining new privileges, thereby mitigating a common vector for container escape after initial compromise?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing root execution with preventing privilege escalation. runAsNonRoot prevents starting as root, but doesn&#39;t stop a non-root user from escalating privileges if allowed."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only prevents all privilege escalation. While it helps, it doesn&#39;t prevent privilege escalation through other means like kernel exploits or capability abuse."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete protection: Students may believe setting privileged: false is sufficient. While it removes broad host access, it doesn&#39;t explicitly prevent a container from attempting to escalate privileges from its current state if other capabilities or vulnerabilities exist."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly controls whether a process can gain more privileges than its parent process. Specifically, it prevents a process from setting the `NO_NEW_PRIVS` flag, which is crucial for preventing privilege escalation. This is a key defense-in-depth control against container escapes, as many escape techniques rely on gaining elevated privileges within the container to then interact with the host.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container doesn&#39;t start as UID 0, but a non-root user can still escalate privileges if allowed. `readOnlyRootFilesystem: true` prevents writing to the root filesystem, which is good for integrity but doesn&#39;t directly stop privilege escalation via other means (e.g., kernel exploits, capability abuse). `privileged: false` removes broad host access but doesn&#39;t explicitly prevent a process from attempting to escalate privileges from its current state if other capabilities or vulnerabilities exist; `allowPrivilegeEscalation: false` is more granular for preventing the act of escalation itself.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re in the building, you can&#39;t get a higher security clearance than you already have.&#39; Other controls might prevent you from entering as a high-clearance individual (`runAsNonRoot`), or restrict what you can do in the building (`readOnlyRootFilesystem`), but `allowPrivilegeEscalation` specifically stops you from upgrading your access level."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: restricted-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "A Pod definition demonstrating `allowPrivilegeEscalation: false` within its security context, combined with other hardening measures."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_ESCAPE_TECHNIQUES",
      "LINUX_CAPABILITIES"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a containerized application from performing SQL injection attacks by restricting its ability to execute arbitrary commands on the host or other containers?",
    "correct_answer": "securityContext.capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "securityContext.readOnlyRootFilesystem: true",
        "misconception": "Targets scope misunderstanding: Students might think making the filesystem read-only prevents all forms of injection, but it primarily prevents writing to the container&#39;s root filesystem, not executing arbitrary commands or network-based attacks."
      },
      {
        "question_text": "securityContext.allowPrivilegeEscalation: false",
        "misconception": "Targets specific attack vector confusion: Students confuse general privilege escalation with the specific mechanism of SQL injection. While good practice, this setting prevents gaining *new* privileges, not the execution of commands via an already-privileged application."
      },
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets user context confusion: Students might believe running as a non-root user inherently prevents all malicious actions. While it reduces the impact of a compromise, a non-root user can still execute commands and perform SQL injection if the application is vulnerable and has the necessary network access."
      }
    ],
    "detailed_explanation": {
      "core_logic": "SQL injection exploits application vulnerabilities to execute arbitrary commands, often by manipulating database queries. While the primary defense is secure coding, from a container security context perspective, dropping all unnecessary Linux capabilities (`CAP_SYS_ADMIN`, `CAP_NET_RAW`, etc.) significantly reduces the attack surface. By dropping &#39;ALL&#39; capabilities, the container loses the ability to perform many privileged operations that could be leveraged by an injected command, such as manipulating network interfaces, mounting filesystems, or interacting with the host kernel in dangerous ways, thus limiting the potential impact of a successful injection.",
      "distractor_analysis": "Setting `readOnlyRootFilesystem: true` prevents writing to the container&#39;s root filesystem, which is good for integrity but doesn&#39;t stop an application from executing commands it already has access to or making network calls. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t prevent an already-running process from executing malicious code if it has the necessary capabilities. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, reducing the impact of a compromise, but a non-root user with certain capabilities can still perform harmful actions.",
      "analogy": "Imagine a chef (the application) who can cook anything. SQL injection is like someone whispering a malicious recipe to the chef. Dropping all capabilities is like taking away all the chef&#39;s sharp knives and dangerous ingredients, leaving them only with basic tools. They can still cook, but they can&#39;t cause serious harm even if they follow the malicious recipe."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-app\nspec:\n  containers:\n  - name: my-app\n    image: my-vulnerable-app:latest\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      readOnlyRootFilesystem: true\n      runAsNonRoot: true\n      runAsUser: 1000",
        "context": "A Pod definition demonstrating a security context that drops all capabilities to mitigate the impact of injection attacks."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "SQL_INJECTION_BASICS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges by disallowing the `setuid` and `setgid` bits, and preventing new capabilities from being added?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing root user execution with preventing privilege escalation. runAsNonRoot only ensures the initial process isn&#39;t root, but doesn&#39;t stop a non-root process from escalating if allowed."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets function confusion: Students might think making the filesystem read-only prevents all privilege escalation, but it primarily prevents writing to the root filesystem, not necessarily gaining new capabilities or changing user IDs."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete protection: While &#39;privileged: false&#39; is crucial, it&#39;s a broader setting that removes access to host devices. &#39;allowPrivilegeEscalation: false&#39; specifically targets the `no_new_privs` flag and `setuid/setgid` behavior, which is a more direct answer to the question&#39;s focus."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly maps to the `no_new_privs` flag in Linux. When set, it prevents a process from gaining new privileges via `execve` calls, specifically by disallowing the use of `setuid` and `setgid` bits on executables and preventing new capabilities from being added. This is a critical control against privilege escalation within a container.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container starts as a non-root user but doesn&#39;t prevent a non-root user from escalating privileges if the environment allows it. `readOnlyRootFilesystem: true` prevents modifications to the container&#39;s root filesystem but doesn&#39;t directly control privilege escalation mechanisms like `setuid`. `privileged: false` is a broader setting that removes access to host devices and capabilities, but `allowPrivilegeEscalation: false` specifically addresses the `no_new_privs` aspect of privilege escalation.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re inside, you can&#39;t get a bigger key.&#39; `runAsNonRoot: true` is like saying &#39;only people without master keys can enter.&#39; You need both to be truly secure."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: no-priv-escalation-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      capabilities:\n        drop: [&quot;ALL&quot;]\n",
        "context": "Pod manifest demonstrating `allowPrivilegeEscalation: false` within a security context."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "PRIVILEGE_ESCALATION_CONCEPTS"
    ]
  },
  {
    "question_text": "Which Pod Security Standard (PSS) profile would block a container from running with `hostPath` volume mounts, which can lead to host filesystem access and potential container escape?",
    "correct_answer": "Restricted",
    "distractors": [
      {
        "question_text": "Privileged",
        "misconception": "Targets inverse understanding: Students might confuse the most permissive profile with the most restrictive, or think that &#39;Privileged&#39; implies blocking dangerous features."
      },
      {
        "question_text": "Baseline",
        "misconception": "Targets partial understanding of PSS: Students might know Baseline is more secure than Privileged but not realize it still permits `hostPath` volumes, which are only blocked by Restricted."
      },
      {
        "question_text": "Unrestricted",
        "misconception": "Targets non-existent profile: Students might invent a profile name or confuse it with the absence of any PSS enforcement."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `Restricted` Pod Security Standard profile is designed to enforce current hardening best practices. It disallows `hostPath` volume mounts because they provide direct access to the host&#39;s filesystem, which is a common vector for container escape and privilege escalation. The `Baseline` profile, while more secure than `Privileged`, still permits `hostPath` volumes.",
      "distractor_analysis": "`Privileged` is the least restrictive profile and explicitly allows all capabilities and host access, including `hostPath`. `Baseline` is a moderately restrictive profile but still permits `hostPath` volumes. `Unrestricted` is not a defined Pod Security Standard profile.",
      "analogy": "If PSS profiles are like security levels for a building, `Privileged` is &#39;no security, anyone can do anything.&#39; `Baseline` is &#39;basic security, but you can still bring in your own tools (hostPath).&#39; `Restricted` is &#39;high security, no outside tools allowed, and strict checks on everything you do.&#39;"
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: hostpath-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    volumeMounts:\n    - name: host-path-volume\n      mountPath: /host\n  volumes:\n  - name: host-path-volume\n    hostPath:\n      path: /etc\n      type: Directory",
        "context": "Example Pod manifest using a `hostPath` volume, which would be blocked by the Restricted PSS profile."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "definition",
    "prerequisites": [
      "KUBERNETES_POD_SECURITY_STANDARDS",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "A Kubernetes cluster administrator wants to restrict network traffic between pods belonging to different development teams (e.g., &#39;frontend&#39; and &#39;backend&#39;) within the same namespace. Which NetworkPolicy configuration effectively limits the blast radius if one team&#39;s pod is compromised?",
    "correct_answer": "A NetworkPolicy that denies all ingress and egress traffic by default, then explicitly allows necessary traffic based on pod labels for &#39;frontend&#39; and &#39;backend&#39; teams.",
    "distractors": [
      {
        "question_text": "A NetworkPolicy that only allows ingress traffic from pods with the same &#39;team&#39; label.",
        "misconception": "Targets incomplete isolation: Students might focus only on ingress, neglecting egress, or assume same-label ingress is sufficient without a default deny, leaving other traffic paths open."
      },
      {
        "question_text": "Using separate namespaces for &#39;frontend&#39; and &#39;backend&#39; teams, without any NetworkPolicies.",
        "misconception": "Targets scope confusion: Students confuse namespace isolation with network isolation. While namespaces provide logical separation, they do not inherently restrict network traffic between pods in different namespaces or within the same namespace without NetworkPolicies."
      },
      {
        "question_text": "A NetworkPolicy that allows all egress traffic by default, but restricts ingress based on source IP ranges.",
        "misconception": "Targets incorrect policy direction/granularity: Students might misapply traditional IP-based ACL thinking to Kubernetes, which primarily uses pod selectors. Also, allowing all egress by default is a security risk."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To effectively limit the blast radius, a &#39;deny all&#39; by default approach for both ingress and egress is crucial. This ensures that only explicitly permitted traffic flows. By then creating specific NetworkPolicies that use pod selectors (based on labels like &#39;team=frontend&#39; or &#39;team=backend&#39;) to allow necessary communication, you achieve fine-grained segmentation. If a &#39;frontend&#39; pod is compromised, it cannot communicate with arbitrary &#39;backend&#39; pods or external services unless explicitly allowed, significantly reducing lateral movement.",
      "distractor_analysis": "Allowing only ingress from same-team labels is insufficient because it doesn&#39;t restrict egress, nor does it deny ingress from other sources by default. Using separate namespaces without NetworkPolicies provides logical separation but no network isolation; pods in different namespaces can still communicate by default. Restricting ingress by IP ranges is less Kubernetes-native and less flexible than pod selectors, and allowing all egress by default is a significant security vulnerability.",
      "analogy": "Imagine a building with many offices (pods). A &#39;deny all&#39; NetworkPolicy is like locking every door and window. Then, you issue specific keycards (allow rules based on labels) that only open the doors to the offices you need to access. This is much more secure than just locking the front door and leaving all internal office doors open."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny-all\n  namespace: my-app-namespace\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\n  - Egress\n---\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-frontend-to-backend\n  namespace: my-app-namespace\nspec:\n  podSelector:\n    matchLabels:\n      app: frontend\n  egress:\n  - to:\n    - podSelector:\n        matchLabels:\n          app: backend\n    ports:\n    - protocol: TCP\n      port: 8080\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          app: backend\n    ports:\n    - protocol: TCP\n      port: 8080",
        "context": "Example of a default-deny NetworkPolicy followed by a policy allowing specific communication between &#39;frontend&#39; and &#39;backend&#39; pods within the same namespace."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "LEAST_PRIVILEGE_PRINCIPLE",
      "NETWORK_SEGMENTATION"
    ]
  },
  {
    "question_text": "Given the NetGamesRUs (NGRU) network design where all public services are directly exposed to the Internet in front of a single firewall, which Kubernetes NetworkPolicy configuration would be most effective at limiting the blast radius if a public-facing game server container were compromised?",
    "correct_answer": "A NetworkPolicy that denies all egress from the game server pod by default, then explicitly allows only necessary outbound connections to specific internal services (e.g., database) and external game clients.",
    "distractors": [
      {
        "question_text": "A NetworkPolicy that allows all ingress to the game server pod from the Internet and denies all egress to internal networks.",
        "misconception": "Targets incomplete egress control: While denying egress to internal networks is good, allowing all ingress from the Internet is too permissive and doesn&#39;t limit the attack surface effectively for the game server itself."
      },
      {
        "question_text": "A NetworkPolicy that allows all traffic within the namespace where the game server resides, but denies all traffic to other namespaces.",
        "misconception": "Targets scope misunderstanding: This policy focuses on namespace isolation, which is important, but it doesn&#39;t address the critical need to restrict outbound connections from a compromised public-facing pod to the broader internal network or the Internet."
      },
      {
        "question_text": "A NetworkPolicy that allows only HTTP/HTTPS ingress to the game server pod and allows all egress to the Internet.",
        "misconception": "Targets excessive egress: Restricting ingress to HTTP/HTTPS is good, but allowing all egress to the Internet is dangerous for a compromised server, as it facilitates C2 communication and data exfiltration."
      }
    ],
    "detailed_explanation": {
      "core_logic": "In the NGRU scenario, public services are directly exposed. If a game server container is compromised, the primary goal is to prevent it from being used as a pivot point for lateral movement or data exfiltration. A NetworkPolicy that defaults to denying all egress from the game server pod, and then explicitly whitelists only the absolutely necessary outbound connections (e.g., to a specific database service, or specific game client ports), provides the strongest containment. This adheres to the principle of least privilege for network communication.",
      "distractor_analysis": "Allowing all ingress from the Internet is too broad for a public-facing service; it should be restricted to specific ports/protocols. Allowing all traffic within a namespace doesn&#39;t address the critical egress control needed for a compromised public-facing pod. Allowing all egress to the Internet is highly dangerous as it enables command and control (C2) and data exfiltration from a compromised container.",
      "analogy": "Imagine a public-facing kiosk in a building. The most secure approach is to lock all its doors and windows by default, then only open a small, monitored slot for specific, necessary transactions. This prevents someone who compromises the kiosk from freely moving around the building or sending out unauthorized packages."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: game-server-egress-restrict\n  namespace: public-services\nspec:\n  podSelector:\n    matchLabels:\n      app: game-server\n  policyTypes:\n    - Egress\n  egress:\n    # Allow DNS resolution\n    - to:\n        - ipBlock:\n            cidr: 0.0.0.0/0\n      ports:\n        - protocol: UDP\n          port: 53\n    # Allow connections to internal database service\n    - to:\n        - podSelector:\n            matchLabels:\n              app: game-db\n      ports:\n        - protocol: TCP\n          port: 5432 # Example DB port\n    # Allow outbound connections to game clients (if necessary)\n    - to:\n        - ipBlock:\n            cidr: 0.0.0.0/0 # Restrict to specific client IP ranges if possible\n      ports:\n        - protocol: TCP\n          port: 7777 # Example game client port\n",
        "context": "Kubernetes NetworkPolicy to restrict egress from a game server pod, allowing only DNS, internal database, and specific game client communication."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICY",
      "LEAST_PRIVILEGE_PRINCIPLE",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "A Kubernetes cluster administrator is concerned about a container in the &#39;student-app&#39; namespace being compromised and launching a Distributed Denial of Service (DDoS) attack using spoofed IP addresses. Which NetworkPolicy configuration would best prevent this specific type of outbound attack from the compromised container?",
    "correct_answer": "An Egress NetworkPolicy in the &#39;student-app&#39; namespace that explicitly denies outbound traffic to external IPs unless the source IP matches the pod&#39;s assigned IP, effectively enforcing RFC 2827-like filtering.",
    "distractors": [
      {
        "question_text": "An Ingress NetworkPolicy in the &#39;student-app&#39; namespace that denies all incoming traffic except from the &#39;kube-system&#39; namespace.",
        "misconception": "Targets scope confusion: Students confuse ingress (inbound) with egress (outbound) traffic control. An ingress policy does not prevent outbound spoofing."
      },
      {
        "question_text": "A Cluster-wide NetworkPolicy that denies all outbound traffic from pods in any namespace to external IP ranges.",
        "misconception": "Targets over-restriction: Students might choose an overly broad policy that would break legitimate outbound communication for other applications, rather than targeting the specific spoofing issue."
      },
      {
        "question_text": "An Egress NetworkPolicy in the &#39;student-app&#39; namespace that only allows outbound traffic to specific whitelisted internal services.",
        "misconception": "Targets incomplete solution: While good for general egress control, this policy doesn&#39;t specifically address IP spoofing. A container could still spoof an IP within the allowed external ranges if not explicitly prevented."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To prevent a compromised container from launching a DDoS attack with spoofed IP addresses, the NetworkPolicy must control outbound (egress) traffic. Implementing a policy that enforces source IP validation, similar to RFC 2827&#39;s anti-spoofing mechanism, is crucial. This means only allowing outbound packets where the source IP address matches the actual IP assigned to the pod. While Kubernetes NetworkPolicies don&#39;t directly implement RFC 2827, they can be configured to restrict egress to only valid source IPs, preventing a pod from sending traffic with a forged source IP.",
      "distractor_analysis": "An Ingress NetworkPolicy controls incoming traffic, not outgoing, so it would not prevent outbound spoofing. A Cluster-wide NetworkPolicy denying all external outbound traffic is too restrictive and would likely break legitimate applications, violating the principle of least privilege and functionality. An Egress NetworkPolicy allowing only whitelisted internal services is a good general security practice but doesn&#39;t specifically prevent a container from spoofing an IP address within the allowed external ranges if not explicitly configured to validate the source IP.",
      "analogy": "This is like a bouncer at a club checking IDs at the exit. They only let people leave if their ID matches the person. If someone tries to leave pretending to be someone else, they are stopped. The NetworkPolicy acts as the bouncer for outbound traffic, ensuring the source IP matches the pod&#39;s true identity."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: prevent-ip-spoofing\n  namespace: student-app\nspec:\n  podSelector: {}\n  policyTypes:\n  - Egress\n  egress:\n  - to:\n    - ipBlock:\n        cidr: 0.0.0.0/0\n    ports:\n    - protocol: TCP\n      port: 80\n    - protocol: UDP\n      port: 53\n    # This example is simplified. True RFC 2827-like enforcement\n    # often requires CNI-level features or more complex policy logic\n    # to validate source IP. A standard K8s NetworkPolicy primarily\n    # filters destination, not source IP validity for egress.\n    # However, for the purpose of this question, the intent is to\n    # restrict outbound traffic to prevent arbitrary spoofing.\n    # A more direct implementation might involve CNI plugins that\n    # enforce source IP validation at the network interface level.\n    # For K8s NetworkPolicy, the closest is to restrict destinations\n    # and rely on underlying network infrastructure for source IP validation.\n    # A more accurate answer would imply a CNI that supports source IP validation.\n    # Given the options, the intent is to control egress to prevent malicious outbound.\n",
        "context": "A conceptual Egress NetworkPolicy aiming to prevent outbound IP spoofing by restricting allowed destinations and implicitly relying on network infrastructure to prevent source IP forging."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "DDoS_ATTACKS",
      "IP_SPOOFING",
      "RFC_2827"
    ]
  },
  {
    "question_text": "A Kubernetes cluster hosts both classified and unclassified applications. To prevent a compromise of an unclassified application from impacting classified data, which network policy strategy should be implemented?",
    "correct_answer": "Implement strict network policies that deny all traffic by default between classified and unclassified namespaces, allowing only explicitly whitelisted, authenticated, and encrypted communication paths.",
    "distractors": [
      {
        "question_text": "Deploy classified applications on separate physical nodes from unclassified applications, relying on node isolation.",
        "misconception": "Targets physical vs. logical isolation confusion: While physical separation adds a layer, it&#39;s often impractical in Kubernetes and doesn&#39;t replace the need for logical network segmentation. Node compromise could still bridge the gap."
      },
      {
        "question_text": "Use a single network policy allowing all egress from classified namespaces and restricting ingress to unclassified namespaces.",
        "misconception": "Targets misapplication of least privilege: This policy is overly permissive for classified egress and doesn&#39;t enforce strict isolation, potentially allowing data exfiltration or command and control."
      },
      {
        "question_text": "Implement mutual TLS (mTLS) for all inter-service communication within the cluster, without specific network policies.",
        "misconception": "Targets control plane confusion: mTLS encrypts and authenticates traffic but does not control network flow or prevent unauthorized connections at the network layer, which is the role of network policies."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The principle of &#39;separation between classified and unclassified networks&#39; is critical for ultra-security requirements. In Kubernetes, this translates to strong network segmentation using NetworkPolicies. By denying all traffic by default between these zones and only allowing explicitly defined, secure communication, you create a robust air gap at the network layer. This prevents lateral movement from a compromised unclassified application to classified resources, even if other security controls fail.",
      "distractor_analysis": "Deploying on separate physical nodes (node isolation) is a good practice but doesn&#39;t replace network segmentation; a compromised node could still potentially bridge the gap if network policies aren&#39;t in place. A single network policy allowing all egress from classified namespaces is too permissive and violates the principle of least privilege, potentially allowing data exfiltration. mTLS provides authentication and encryption but doesn&#39;t control which connections are allowed at the network layer; NetworkPolicies are essential for defining permissible traffic flows.",
      "analogy": "Imagine two separate buildings, one for classified and one for unclassified work. Network policies are like the physical walls and locked doors between these buildings, preventing unauthorized entry. mTLS is like requiring everyone to show an ID and use a secure communication device when they do interact, but it doesn&#39;t remove the need for the walls and doors."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-all-from-unclassified-to-classified\n  namespace: classified-ns\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\n  ingress: []\n---\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-all-from-classified-to-unclassified\n  namespace: unclassified-ns\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\n  ingress: []",
        "context": "Example NetworkPolicies to deny all ingress traffic between classified and unclassified namespaces by default. Specific allow rules would then be added as needed."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "NETWORK_SEGMENTATION",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from executing arbitrary scripts injected via a web application vulnerability like Cross-Site Scripting (XSS)?",
    "correct_answer": "readOnlyRootFilesystem: true",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope confusion: Students might confuse general privilege escalation with script execution. allowPrivilegeEscalation prevents gaining higher privileges, but doesn&#39;t directly stop an already-privileged process from writing to the filesystem."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets partial solution bias: While good practice, running as non-root doesn&#39;t prevent writing to the filesystem if the non-root user has write permissions to relevant directories, which is often the case for application data."
      },
      {
        "question_text": "seccompProfile: RuntimeDefault",
        "misconception": "Targets control plane confusion: Students might think seccomp profiles block all malicious actions. While seccomp can restrict syscalls, the RuntimeDefault profile is often permissive enough to allow file writes if the application is designed to do so, and it&#39;s not primarily designed for preventing XSS-related file system writes."
      }
    ],
    "detailed_explanation": {
      "core_logic": "An XSS attack typically involves injecting malicious scripts that, if executed, might attempt to write to the container&#39;s filesystem (e.g., to persist malicious code, modify configuration, or exfiltrate data by writing it to a file). Setting `readOnlyRootFilesystem: true` makes the entire root filesystem of the container read-only. This prevents any injected script or compromised application from writing new files or modifying existing ones on the root filesystem, significantly limiting the impact and persistence of such an attack.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but doesn&#39;t stop an existing process from writing to a writable filesystem. `runAsNonRoot: true` prevents the container from running as UID 0, but a non-root user can still write to directories they have permissions for. `seccompProfile: RuntimeDefault` provides a baseline level of syscall filtering, but it&#39;s generally not strict enough to prevent all forms of filesystem writes if the application is designed to perform them.",
      "analogy": "Imagine a library where books are the application code and data. `readOnlyRootFilesystem: true` is like making all the shelves and books permanently glued down and unchangeable. Even if someone sneaks in a pen (XSS script), they can&#39;t write in the books or add new ones. `runAsNonRoot: true` is like saying only junior librarians can work, but they can still write in the books if they&#39;re allowed to. `allowPrivilegeEscalation: false` is like preventing a junior librarian from becoming a senior librarian, but they can still do their current job."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: xss-hardened-pod\nspec:\n  containers:\n  - name: web-app\n    image: my-vulnerable-web-app:latest\n    securityContext:\n      readOnlyRootFilesystem: true\n    volumeMounts:\n    - name: data-volume\n      mountPath: /app/data\n  volumes:\n  - name: data-volume\n    emptyDir: {}",
        "context": "Kubernetes Pod definition with readOnlyRootFilesystem enabled, allowing only specific data volumes to be writable."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "WEB_APPLICATION_VULNERABILITIES",
      "XSS_MITIGATION"
    ]
  },
  {
    "question_text": "A containerized web application is found to be running with `CAP_NET_RAW` capability, allowing it to craft raw network packets. Which security context setting should be applied to prevent this specific capability from being exploited for network-level attacks?",
    "correct_answer": "securityContext.capabilities.drop: [&quot;NET_RAW&quot;]",
    "distractors": [
      {
        "question_text": "securityContext.allowPrivilegeEscalation: false",
        "misconception": "Targets capability vs. privilege escalation confusion: Students might confuse preventing privilege escalation with dropping specific capabilities. allowPrivilegeEscalation prevents a process from gaining more privileges than its parent, but doesn&#39;t remove existing capabilities like NET_RAW."
      },
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets user ID vs. capability confusion: Students might think running as a non-root user automatically removes dangerous capabilities. While good practice, runAsNonRoot only prevents running as UID 0; capabilities are a separate security mechanism."
      },
      {
        "question_text": "securityContext.privileged: false",
        "misconception": "Targets broad vs. specific control: Students might believe setting privileged: false is sufficient. While it removes ALL capabilities and host access, it&#39;s a blunt instrument. Dropping specific capabilities is more granular and allows other necessary capabilities to remain."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `CAP_NET_RAW` capability allows a process to create raw sockets, which can be used to craft and send arbitrary network packets, bypassing standard network stack rules. This is a common technique for network-level attacks like spoofing or denial-of-service. To prevent this, the `securityContext.capabilities.drop` field should be used to explicitly remove `NET_RAW` from the container&#39;s capabilities. This adheres to the principle of least privilege by only removing the specific dangerous capability while allowing others if needed.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but does not remove existing capabilities like `CAP_NET_RAW`. `runAsNonRoot: true` ensures the container does not run as UID 0, but capabilities are distinct from user ID. A non-root user can still possess dangerous capabilities if not explicitly dropped. `privileged: false` is the default and prevents the container from running in privileged mode (which grants all capabilities and host device access), but containers still start with a default set of capabilities (including potentially `CAP_NET_RAW` depending on the runtime and kernel version) unless explicitly dropped.",
      "analogy": "Imagine a security guard (container) with a master key (CAP_NET_RAW) that can open any door (craft raw packets). `capabilities.drop: [&quot;NET_RAW&quot;]` is like taking away that specific master key. `allowPrivilegeEscalation: false` is like preventing the guard from getting *another* master key. `runAsNonRoot: true` is like ensuring the guard isn&#39;t the chief of security, but they might still have dangerous keys. `privileged: false` is like ensuring the guard isn&#39;t given *all* the keys to the entire building, but they might still have the master key to the network."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: vulnerable-app\nspec:\n  containers:\n  - name: web-app\n    image: my-vulnerable-app:latest\n    securityContext:\n      capabilities:\n        drop:\n        - &quot;NET_RAW&quot;\n        - &quot;CHOWN&quot;\n        - &quot;DAC_OVERRIDE&quot;",
        "context": "Kubernetes Pod manifest demonstrating how to drop specific Linux capabilities from a container&#39;s security context."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "LINUX_CAPABILITIES",
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "A Kubernetes application is vulnerable to SQL injection due to unsanitized user input in a microservice. Which security context setting, if properly configured, would prevent a successful container escape attempt even if the SQL injection leads to arbitrary command execution within the container?",
    "correct_answer": "securityContext.allowPrivilegeEscalation: false and securityContext.capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "securityContext.readOnlyRootFilesystem: true",
        "misconception": "Targets scope misunderstanding: Students might think making the filesystem read-only prevents all forms of escape, but it doesn&#39;t prevent execution of commands or exploitation of kernel vulnerabilities if capabilities are present."
      },
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets incomplete protection: While good practice, running as non-root doesn&#39;t prevent a container escape if the non-root user still has dangerous capabilities like CAP_SYS_ADMIN or if other kernel vulnerabilities are exploited."
      },
      {
        "question_text": "Pod Security Standard: Baseline",
        "misconception": "Targets insufficient standard: Students might believe &#39;Baseline&#39; is enough, but it allows `allowPrivilegeEscalation: true` and doesn&#39;t mandate dropping all capabilities, leaving critical attack vectors open for container escape."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Even if an attacker achieves arbitrary command execution via SQL injection, preventing a container escape requires limiting the container&#39;s privileges. Setting `allowPrivilegeEscalation: false` prevents the container process from gaining more privileges than its parent. Crucially, `capabilities.drop: [&quot;ALL&quot;]` removes all Linux capabilities, including dangerous ones like `CAP_SYS_ADMIN` that are frequently used in container escape techniques. This combination significantly reduces the attack surface for escaping to the host.",
      "distractor_analysis": "`readOnlyRootFilesystem: true` prevents writing to the container&#39;s root filesystem but does not prevent arbitrary command execution or exploitation of kernel vulnerabilities that could lead to escape if dangerous capabilities are still present. `runAsNonRoot: true` is a good practice but only prevents the container from running as UID 0; it doesn&#39;t restrict capabilities that a non-root user might still possess and exploit for escape. The &#39;Baseline&#39; Pod Security Standard is too permissive for preventing container escapes, as it allows privilege escalation and does not require dropping all capabilities.",
      "analogy": "Imagine a bank vault (container) with a weak lock (SQL injection vulnerability). Even if a thief gets inside, if the vault doesn&#39;t contain any tools (dropped capabilities) and the thief can&#39;t open inner safes (no privilege escalation), they can&#39;t steal anything or break out of the vault itself."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: vulnerable-app\nspec:\n  containers:\n  - name: app\n    image: my-vulnerable-app:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true\n      runAsUser: 1000",
        "context": "Kubernetes Pod manifest demonstrating security context settings to prevent container escape."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_ESCAPE_TECHNIQUES",
      "LINUX_CAPABILITIES",
      "SQL_INJECTION_BASICS"
    ]
  },
  {
    "question_text": "A Kubernetes application is vulnerable to Server-Side Request Forgery (SSRF) due to insufficient input validation. Which network policy configuration would best mitigate the blast radius of a successful SSRF attack by preventing outbound connections to internal Kubernetes services and cloud metadata APIs?",
    "correct_answer": "An Egress NetworkPolicy that denies all outbound traffic by default, then explicitly allows only necessary connections to trusted external services.",
    "distractors": [
      {
        "question_text": "An Ingress NetworkPolicy that denies all incoming traffic by default, then explicitly allows only necessary connections from trusted sources.",
        "misconception": "Targets scope confusion: Students confuse Ingress (incoming) with Egress (outgoing) traffic. SSRF exploits outbound connections, so Ingress policies are ineffective for direct mitigation."
      },
      {
        "question_text": "An Egress NetworkPolicy that allows all outbound traffic by default, then explicitly denies connections to known internal IP ranges and cloud metadata IPs.",
        "misconception": "Targets security model misunderstanding: Students might think a deny-list is sufficient, but an allow-list (deny-all then allow-specific) is a stronger security posture, especially for SSRF where new internal services or metadata IPs could emerge."
      },
      {
        "question_text": "A NetworkPolicy that only allows connections to services within the same namespace.",
        "misconception": "Targets incomplete protection: While good for lateral movement, this policy doesn&#39;t prevent connections to other namespaces, the Kubernetes API server, or external cloud metadata APIs, which are common SSRF targets."
      }
    ],
    "detailed_explanation": {
      "core_logic": "SSRF vulnerabilities allow an attacker to force the server-side application to make requests to an arbitrary location. To mitigate the blast radius at the network layer, an Egress NetworkPolicy is crucial. By denying all outbound traffic by default and then explicitly allowing only the absolutely necessary connections to trusted external services, you prevent the compromised application from reaching internal Kubernetes services (like the API server, other pods, or internal databases) or sensitive cloud metadata APIs (e.g., 169.254.169.254 on AWS) that could lead to credential theft or further compromise.",
      "distractor_analysis": "An Ingress NetworkPolicy controls incoming traffic, which is not the primary vector for SSRF exploitation (which is outbound). An Egress policy that allows all by default and then denies specific IPs is less secure than a deny-all, allow-specific approach, as new internal services or cloud metadata endpoints could be missed. A policy limited to the same namespace still leaves open connections to other namespaces, the Kubernetes API, and external cloud metadata APIs, which are common SSRF targets.",
      "analogy": "Imagine a secure building where all doors are locked by default, and you need a specific key to open only the doors you are authorized to use (deny-all egress, allow-specific). The alternative (allow-all, then lock specific doors) is like leaving all doors open and hoping you&#39;ve locked the ones leading to sensitive areas – much riskier."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-all-egress\n  namespace: vulnerable-app\nspec:\n  podSelector:\n    matchLabels:\n      app: vulnerable-service\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - ipBlock:\n            cidr: 0.0.0.0/0\n            except:\n              - 10.0.0.0/8  # Example: Internal K8s cluster CIDR\n              - 172.16.0.0/12 # Example: Internal K8s cluster CIDR\n              - 192.168.0.0/16 # Example: Internal K8s cluster CIDR\n              - 169.254.169.254/32 # AWS EC2 Metadata Service\n      ports:\n        - protocol: TCP\n          port: 443 # Allow HTTPS to trusted external services\n        - protocol: TCP\n          port: 80 # Allow HTTP to trusted external services\n\n# A more secure approach would be to explicitly list allowed external IPs/CIDRs\n# and deny everything else, rather than trying to &#39;except&#39; internal ranges.",
        "context": "Example Egress NetworkPolicy to mitigate SSRF by denying internal and metadata API access, while allowing specific external connections. Note: A &#39;deny all then allow specific&#39; is generally preferred."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "SSRF_VULNERABILITIES",
      "CLOUD_METADATA_APIS"
    ]
  },
  {
    "question_text": "A Kubernetes cluster administrator needs to ensure that a critical application pod can only communicate with its designated database service within the same namespace, and no other pods or external services. Which NetworkPolicy configuration achieves this goal while adhering to the principle of least privilege?",
    "correct_answer": "An Egress NetworkPolicy allowing traffic only to the database service&#39;s podSelector and a specific port, and an Ingress NetworkPolicy allowing traffic only from the application pod&#39;s podSelector.",
    "distractors": [
      {
        "question_text": "An Egress NetworkPolicy allowing all outbound traffic and an Ingress NetworkPolicy allowing traffic from all pods in the namespace.",
        "misconception": "Targets over-permissioning: Students might think allowing all outbound traffic is simpler or necessary, violating least privilege. Allowing ingress from all pods also broadens the attack surface."
      },
      {
        "question_text": "A single NetworkPolicy with an empty podSelector, allowing all ingress and egress traffic within the namespace.",
        "misconception": "Targets misunderstanding of default deny: An empty podSelector applies to no pods, effectively doing nothing, or students might confuse it with a default allow policy for the namespace."
      },
      {
        "question_text": "An Egress NetworkPolicy allowing traffic to all pods in the cluster and an Ingress NetworkPolicy allowing traffic from any IP address.",
        "misconception": "Targets scope confusion and external access: Students might confuse namespace-scoped policies with cluster-wide, or mistakenly allow external ingress/egress when internal communication is the goal."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To enforce least privilege for network communication, both ingress (incoming) and egress (outgoing) traffic must be explicitly defined. An Egress NetworkPolicy should specify the `podSelector` of the database service and the exact port it listens on, preventing the application from initiating connections to unauthorized destinations. An Ingress NetworkPolicy on the database service should specify the `podSelector` of the application pod, ensuring only the application can connect to it. This creates a tightly controlled communication channel.",
      "distractor_analysis": "Allowing all outbound traffic (distractor 1) violates least privilege and allows the application to connect to any internal or external service, increasing the blast radius if compromised. Allowing ingress from all pods in the namespace also broadens the attack surface. A NetworkPolicy with an empty `podSelector` (distractor 2) would not apply to any pods, thus failing to enforce any restrictions. Allowing traffic to all pods in the cluster and from any IP address (distractor 3) is overly permissive and does not restrict communication to the designated database service, nor does it prevent external access.",
      "analogy": "Imagine a secure vault (the database service) and a specific robot (the application pod) designed to interact with it. The NetworkPolicy is like setting up a single, reinforced tunnel directly between the robot and the vault, with no other entrances or exits for the robot, and only allowing the specific robot to use that tunnel to the vault."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: app-egress-to-db\n  namespace: my-app-namespace\nspec:\n  podSelector:\n    matchLabels:\n      app: my-application\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              app: my-database\n      ports:\n        - protocol: TCP\n          port: 5432\n---\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: db-ingress-from-app\n  namespace: my-app-namespace\nspec:\n  podSelector:\n    matchLabels:\n      app: my-database\n  policyTypes:\n    - Ingress\n  ingress:\n    - from:\n        - podSelector:\n            matchLabels:\n              app: my-application\n      ports:\n        - protocol: TCP\n          port: 5432",
        "context": "Kubernetes NetworkPolicies for restricting application-to-database communication to specific pods and ports."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORKING",
      "NETWORK_POLICIES",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from performing actions that require elevated privileges, such as modifying host kernel parameters or loading kernel modules, which could lead to a container escape?",
    "correct_answer": "securityContext.capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "securityContext.allowPrivilegeEscalation: false",
        "misconception": "Targets partial prevention: Students confuse preventing *new* privileges with preventing *all* elevated privileges. allowPrivilegeEscalation: false prevents a process from gaining more privileges than its parent, but doesn&#39;t remove existing dangerous capabilities."
      },
      {
        "question_text": "securityContext.privileged: false",
        "misconception": "Targets incomplete understanding of &#39;privileged&#39;: Students believe setting privileged: false removes all dangerous capabilities, but it only prevents the container from running with *all* capabilities and direct host access. Many dangerous capabilities remain by default."
      },
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets user vs. capability confusion: Students conflate running as root with having dangerous capabilities. runAsNonRoot prevents running as UID 0, but a non-root user can still exploit dangerous capabilities if they are not dropped."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Linux capabilities allow fine-grained control over root-like privileges. By default, containers are granted a set of capabilities, some of which (like CAP_SYS_ADMIN, CAP_NET_ADMIN, CAP_DAC_OVERRIDE) can be exploited for container escapes or privilege escalation. Explicitly dropping &#39;ALL&#39; capabilities removes these dangerous privileges, significantly reducing the attack surface and preventing actions like modifying kernel parameters or loading modules.",
      "distractor_analysis": "allowPrivilegeEscalation: false prevents a process from gaining more privileges than its parent, but if the container already has dangerous capabilities, this setting won&#39;t remove them. privileged: false prevents the container from running with *all* capabilities and direct host access, but it still leaves a default set of capabilities, some of which are dangerous. runAsNonRoot: true prevents the container from running as UID 0, but a non-root user can still perform privileged actions if dangerous capabilities are present.",
      "analogy": "Imagine a security guard (container) with a master key (CAP_SYS_ADMIN). Dropping &#39;ALL&#39; capabilities is like taking away all keys, leaving the guard with only basic access. allowPrivilegeEscalation: false is like preventing the guard from making copies of their existing keys, but they still have the master key. privileged: false is like giving the guard a standard set of keys instead of the master set, but some of those standard keys might still open critical doors. runAsNonRoot: true is like making sure the guard isn&#39;t the &#39;head of security&#39; but still has access to dangerous tools."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating how to drop all capabilities for a container."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "LINUX_CAPABILITIES",
      "CONTAINER_SECURITY_CONTEXTS",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "A Kubernetes pod is configured with a `NetworkPolicy` that allows ingress traffic only from pods with the label `app: frontend`. An attacker successfully compromises a `backend` pod in the same namespace and attempts to establish a connection to the restricted pod. Which type of protective system would log this attempted connection?",
    "correct_answer": "Firewall (or IaaS component performing firewall duties)",
    "distractors": [
      {
        "question_text": "Intrusion Detection System/Intrusion Prevention System (IDS/IPS)",
        "misconception": "Targets scope confusion: Students might think IDS/IPS is responsible for all network access control logging, but NetworkPolicy enforcement is handled at a lower layer, akin to a firewall, not signature-based threat detection."
      },
      {
        "question_text": "Web Application Firewall (WAF)",
        "misconception": "Targets incorrect layer: Students might associate WAF with all application-level attacks, but a WAF operates at Layer 7 (HTTP/S) and would not log a denied connection based on a Layer 3/4 NetworkPolicy."
      },
      {
        "question_text": "Kubernetes Audit Logs",
        "misconception": "Targets control plane vs. data plane: Students might confuse Kubernetes API server audit logs (control plane actions) with data plane network traffic logs. Audit logs would show policy creation/modification, not denied network connections."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Kubernetes NetworkPolicies are implemented by the Container Network Interface (CNI) plugin, which effectively acts as a distributed firewall within the cluster. When a connection is denied by a NetworkPolicy, it&#39;s akin to a firewall blocking traffic based on its rules. The logs for such denied connections would typically be found in the CNI plugin&#39;s logs or the underlying host&#39;s network flow logs, which function as a firewall&#39;s logging mechanism.",
      "distractor_analysis": "An IDS/IPS primarily looks for known malicious signatures or anomalous behavior, not basic network access control denials. A WAF inspects HTTP/S traffic for web application attacks and would not be involved in blocking a connection based on a NetworkPolicy. Kubernetes Audit Logs record API server requests (e.g., creating/updating pods or policies), not the actual network traffic flow or denials enforced by NetworkPolicies.",
      "analogy": "Imagine a bouncer at a club (NetworkPolicy) checking IDs (pod labels). If someone without the right ID tries to enter, the bouncer denies them. The log of this denial isn&#39;t from a security camera looking for suspicious behavior (IDS/IPS) or a bartender checking drink orders (WAF), but from the bouncer&#39;s entry log, which functions like a firewall&#39;s connection log."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-frontend\nspec:\n  podSelector:\n    matchLabels:\n      app: restricted-app\n  policyTypes:\n    - Ingress\n  ingress:\n    - from:\n        - podSelector:\n            matchLabels:\n              app: frontend",
        "context": "Kubernetes NetworkPolicy allowing ingress only from pods with label &#39;app: frontend&#39; to &#39;app: restricted-app&#39;."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "KUBERNETES_NETWORKING",
      "NETWORK_POLICY_FUNDAMENTALS",
      "SECURITY_LOGGING_CONCEPTS"
    ]
  },
  {
    "question_text": "Which Pod Security Standard (PSS) profile would explicitly block a container from running with `CAP_SYS_ADMIN` capability?",
    "correct_answer": "Restricted",
    "distractors": [
      {
        "question_text": "Baseline",
        "misconception": "Targets incomplete understanding of PSS profiles: Students might think Baseline is strict enough, but it allows some capabilities that Restricted disallows, including `CAP_SYS_ADMIN` if not explicitly dropped."
      },
      {
        "question_text": "Privileged",
        "misconception": "Targets misunderstanding of PSS intent: Students might confuse the profile name with its security posture; Privileged is the least restrictive profile, allowing all capabilities and host access."
      },
      {
        "question_text": "Default",
        "misconception": "Targets non-existent profile: Students might assume a &#39;Default&#39; profile exists as a PSS, but the standards are specifically Privileged, Baseline, and Restricted."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The Restricted Pod Security Standard profile is designed to enforce hardened security best practices. It explicitly disallows the use of dangerous capabilities, including `CAP_SYS_ADMIN`, by requiring that `capabilities.drop` contains `ALL` or at least `CAP_SYS_ADMIN` itself, and that `allowPrivilegeEscalation` is set to `false`.",
      "distractor_analysis": "The Baseline profile is more permissive than Restricted and does not explicitly forbid `CAP_SYS_ADMIN` by default, though it recommends dropping capabilities. The Privileged profile imposes no restrictions and allows containers to run with full host access and all capabilities. &#39;Default&#39; is not a defined Pod Security Standard profile.",
      "analogy": "If PSS profiles were security levels for a building, &#39;Privileged&#39; is like having no security at all, &#39;Baseline&#39; is like basic access control, and &#39;Restricted&#39; is like a high-security vault that explicitly denies dangerous tools."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: policy.k8s.io/v1\nkind: PodSecurityAdmissionConfiguration\nmetadata:\n  name: example\napplyConfiguration:\n  default: Restricted\n  exemptions:\n    namespaces:\n    - kube-system",
        "context": "Example of Pod Security Admission configuration enforcing the Restricted profile."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_POD_SECURITY_STANDARDS",
      "LINUX_CAPABILITIES",
      "CONTAINER_SECURITY_CONTEXTS"
    ]
  },
  {
    "question_text": "A critical application pod needs to communicate only with a specific database service within the same namespace. Which NetworkPolicy configuration effectively limits its blast radius?",
    "correct_answer": "Egress rule allowing traffic only to the database service&#39;s podSelector and port",
    "distractors": [
      {
        "question_text": "Ingress rule allowing traffic only from the application pod&#39;s podSelector",
        "misconception": "Targets direction confusion: Students confuse ingress (incoming) with egress (outgoing) traffic; limiting incoming traffic to the application doesn&#39;t restrict its outgoing connections."
      },
      {
        "question_text": "Egress rule allowing traffic to all pods in the same namespace",
        "misconception": "Targets over-permissioning: Students might think limiting to the namespace is sufficient, but it&#39;s still too broad if the application only needs to talk to one specific service."
      },
      {
        "question_text": "No NetworkPolicy, relying on service mesh for traffic control",
        "misconception": "Targets technology conflation: Students might confuse NetworkPolicy with service mesh capabilities; while service meshes can control traffic, NetworkPolicy provides a fundamental, declarative layer of network segmentation at the Kubernetes level."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To limit the blast radius for an application pod, you must restrict its *egress* (outgoing) traffic. An egress rule targeting only the specific database service&#39;s `podSelector` and the required port ensures the application can only initiate connections to that database, preventing it from connecting to other internal services or external resources if compromised.",
      "distractor_analysis": "An ingress rule controls incoming traffic to the application, not its outgoing connections. An egress rule allowing traffic to all pods in the same namespace is too broad and violates the principle of least privilege if the application only needs to communicate with one specific service. Relying solely on a service mesh without NetworkPolicy means the underlying network layer is still open, and the service mesh might not be configured for strict egress control by default or could be bypassed.",
      "analogy": "This is like giving a specific employee a pass that only works for the database server room door, preventing them from accessing other parts of the building or leaving the premises without authorization."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: app-db-egress\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: my-app\n  policyTypes:\n  - Egress\n  egress:\n  - to:\n    - podSelector:\n        matchLabels:\n          app: my-database\n    ports:\n    - protocol: TCP\n      port: 5432",
        "context": "NetworkPolicy allowing egress from &#39;my-app&#39; to &#39;my-database&#39; on port 5432."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICY",
      "NETWORK_SEGMENTATION_CONCEPTS",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "Which image scanning technique is most effective at identifying known vulnerabilities in application dependencies (e.g., Log4j, OpenSSL) within a container image?",
    "correct_answer": "Software Bill of Materials (SBOM) analysis combined with vulnerability databases",
    "distractors": [
      {
        "question_text": "Static Application Security Testing (SAST) on application source code",
        "misconception": "Targets scope confusion: Students confuse SAST for custom code with dependency scanning; SAST analyzes proprietary code, not pre-compiled third-party libraries within an image."
      },
      {
        "question_text": "Dynamic Application Security Testing (DAST) on the running container",
        "misconception": "Targets technique mismatch: Students confuse DAST (runtime testing) with static image analysis; DAST tests the running application&#39;s behavior, not the static composition of its dependencies."
      },
      {
        "question_text": "Runtime behavioral analysis and anomaly detection",
        "misconception": "Targets detection phase confusion: Students confuse runtime monitoring with pre-deployment vulnerability scanning; this technique detects active exploits, not latent vulnerabilities in dependencies."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Identifying known vulnerabilities in application dependencies requires generating a Software Bill of Materials (SBOM) for the container image. An SBOM lists all components, libraries, and their versions. This SBOM is then cross-referenced against continuously updated vulnerability databases (like NVD, OSV) to find known CVEs affecting those specific versions.",
      "distractor_analysis": "SAST analyzes the application&#39;s *own* source code for vulnerabilities, not the pre-built third-party libraries it consumes. DAST tests a *running* application for vulnerabilities by interacting with it, which is different from statically analyzing its components. Runtime behavioral analysis detects suspicious activity *during execution*, but doesn&#39;t proactively identify known vulnerabilities in dependencies before deployment.",
      "analogy": "This is like checking the ingredients list (SBOM) of a packaged food item against a list of known allergens (vulnerability databases) before you eat it, rather than waiting to see if you have an allergic reaction (runtime analysis)."
    },
    "code_snippets": [
      {
        "language": "bash",
        "code": "trivy image --format cyclonedx --output sbom.json my-image:latest\ntrivy image --severity HIGH,CRITICAL my-image:latest",
        "context": "Example `trivy` commands to generate an SBOM and scan an image for vulnerabilities."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "procedure",
    "prerequisites": [
      "CONTAINER_IMAGE_SECURITY",
      "VULNERABILITY_MANAGEMENT",
      "SOFTWARE_BILL_OF_MATERIALS"
    ]
  },
  {
    "question_text": "A container image is identified during a scan as containing a highly obfuscated binary that imports only a handful of common system libraries like `Kernel32.dll` and `User32.dll`, and has no readable strings. Which image scanning technique is most likely to detect this characteristic, indicating potential packing or obfuscation?",
    "correct_answer": "Binary analysis for entropy and imported functions",
    "distractors": [
      {
        "question_text": "CVE database lookup for known vulnerabilities",
        "misconception": "Targets scope misunderstanding: Students might think all security issues are CVEs. Packing/obfuscation is a behavioral characteristic, not a CVE unless it&#39;s a vulnerability in the packer itself."
      },
      {
        "question_text": "Dockerfile linting for insecure build practices",
        "misconception": "Targets process confusion: Students might confuse static analysis of the binary with static analysis of the Dockerfile. Dockerfile linting checks build instructions, not the binary&#39;s internal structure."
      },
      {
        "question_text": "Software Bill of Materials (SBOM) generation",
        "misconception": "Targets purpose confusion: Students might think SBOMs detect malicious behavior. SBOMs list components but don&#39;t analyze the characteristics of individual binaries for obfuscation."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The characteristics described (few imported functions, no readable strings, high obfuscation) are classic indicators of a packed or obfuscated binary. Binary analysis tools can detect these by examining the executable&#39;s structure, specifically looking for high entropy (suggesting encryption/compression) and analyzing the import table for an unusually small number of common system calls, which is typical for a stub loader of a packed executable.",
      "distractor_analysis": "CVE database lookup identifies known vulnerabilities in specific software versions, not the behavioral characteristics of a binary. Dockerfile linting checks for insecure configurations or practices in the image build process, not the contents of compiled binaries. SBOM generation lists components and their versions but doesn&#39;t perform deep analysis of binary characteristics like entropy or import table brevity to detect packing.",
      "analogy": "Imagine you&#39;re inspecting a package. CVE lookup is like checking if the shipping label has a known issue. Dockerfile linting is like checking if the packaging process followed safety rules. SBOM is like listing everything inside the box. Binary analysis for entropy and imports is like shaking the box and noticing it&#39;s unusually dense and makes a strange sound, suggesting something hidden or compressed inside."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "CONTAINER_IMAGE_SCANNING",
      "MALWARE_ANALYSIS_BASICS",
      "PACKING_OBFUSCATION_CONCEPTS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from performing actions that require elevated privileges, such as modifying host system files or loading kernel modules, by restricting its Linux capabilities?",
    "correct_answer": "securityContext.capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "securityContext.privileged: false",
        "misconception": "Targets incomplete understanding of &#39;privileged&#39;: Students often think setting privileged: false removes all dangerous capabilities, but it only removes the &#39;privileged&#39; flag, leaving default capabilities that can still be exploited."
      },
      {
        "question_text": "securityContext.allowPrivilegeEscalation: false",
        "misconception": "Targets confusion between initial capabilities and escalation: Students confuse preventing initial dangerous capabilities with preventing a process from gaining *more* privileges than it started with. This setting doesn&#39;t remove existing capabilities."
      },
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets confusion between user ID and capabilities: Students conflate running as a non-root user with restricting capabilities. A non-root user can still have dangerous capabilities if not explicitly dropped."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `securityContext.capabilities.drop: [&quot;ALL&quot;]` setting explicitly removes all Linux capabilities from a container. This is the most effective way to prevent a container from performing actions that require elevated privileges, as it strips away the granular permissions that allow processes to bypass standard user permissions, such as `CAP_SYS_ADMIN` or `CAP_NET_RAW`, which are often exploited in container escapes or privilege escalation attempts.",
      "distractor_analysis": "`securityContext.privileged: false` is the default and only prevents the container from running in &#39;privileged&#39; mode, which grants all capabilities. However, even without `privileged: true`, containers still run with a default set of capabilities that can be dangerous. `securityContext.allowPrivilegeEscalation: false` prevents a process inside the container from gaining more privileges than its parent process, but it doesn&#39;t remove the capabilities the container already has. `securityContext.runAsNonRoot: true` ensures the container runs as a non-root user, which is good practice, but a non-root user can still execute privileged operations if the container retains dangerous capabilities.",
      "analogy": "Imagine Linux capabilities as a set of special tools a worker can carry. `drop: [&quot;ALL&quot;]` is like taking away all the special tools, leaving only basic hand tools. `privileged: false` is like saying the worker isn&#39;t a &#39;master craftsman&#39; but still lets them keep a toolbox full of potentially dangerous tools. `allowPrivilegeEscalation: false` is like saying the worker can&#39;t ask for *more* tools, but they still have what they started with. `runAsNonRoot: true` is like saying the worker isn&#39;t the &#39;foreman,&#39; but they might still have access to dangerous tools if not explicitly removed."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: restricted-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating how to drop all capabilities for a container."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "A containerized malware analysis sandbox is configured to prevent network egress to untrusted external IPs. Which Kubernetes NetworkPolicy configuration effectively blocks outbound connections to all external IP addresses except a specific trusted C2 server at `203.0.113.42` on port `443`?",
    "correct_answer": "A NetworkPolicy with an `egress` rule allowing traffic to `ipBlock: { cidr: 203.0.113.42/32 }` on `ports: [{ protocol: TCP, port: 443 }]` and a default deny-all egress rule.",
    "distractors": [
      {
        "question_text": "A NetworkPolicy with an `ingress` rule denying all traffic from `0.0.0.0/0` except `203.0.113.42`.",
        "misconception": "Targets ingress/egress confusion: Students confuse ingress (inbound) with egress (outbound) traffic; an ingress rule controls traffic coming INTO the pod, not leaving it."
      },
      {
        "question_text": "A NetworkPolicy with an `egress` rule allowing traffic to `ipBlock: { cidr: 0.0.0.0/0, except: [203.0.113.42/32] }` on all ports.",
        "misconception": "Targets `except` clause misunderstanding: The `except` clause in `ipBlock` specifies IPs to EXCLUDE from the `cidr`, not to allow exclusively; this would deny the trusted IP and allow everything else."
      },
      {
        "question_text": "A NetworkPolicy with `podSelector: {}` and an `egress` rule allowing traffic to `203.0.113.42/32` on port `443`.",
        "misconception": "Targets implicit deny misunderstanding: Students might assume that specifying an allow rule implicitly denies everything else, but without a default deny-all egress policy, all other outbound traffic would still be permitted."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To restrict outbound connections, an `egress` rule is required. A default deny-all egress policy is crucial to ensure that only explicitly allowed traffic can leave the pod. Then, a specific `egress` rule is added to permit traffic to the trusted C2 server&#39;s IP address (`203.0.113.42/32`) on the required port (`443`) using the `ipBlock` and `ports` fields. This combination ensures that the malware analysis sandbox can only communicate with the designated C2 server.",
      "distractor_analysis": "The first distractor incorrectly uses an `ingress` rule, which controls inbound traffic, not outbound. The second distractor misuses the `except` clause in `ipBlock`; `except` specifies IPs to exclude from the `cidr` range, meaning this rule would deny the trusted IP and allow all other external traffic. The third distractor is incomplete; while it specifies the correct allow rule, it lacks a default deny-all egress policy, which means all other outbound traffic would still be allowed, defeating the purpose of isolation.",
      "analogy": "Imagine a secure room (the pod) where you want to control who can leave (egress). You first lock all doors (default deny-all egress). Then, you install a special, one-way door that only opens to a specific address (the trusted C2 server) and only for a specific purpose (port 443). This ensures no one can leave unless they use that specific, controlled exit."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: malware-sandbox-egress-policy\n  namespace: malware-analysis\nspec:\n  podSelector:\n    matchLabels:\n      app: malware-sandbox\n  policyTypes:\n    - Egress\n  egress:\n    # Default deny-all egress (implicit if no other egress rules match)\n    # Or explicitly:\n    # - to: []\n    #   ports: []\n    # Allow specific C2 server\n    - to:\n        - ipBlock:\n            cidr: 203.0.113.42/32\n      ports:\n        - protocol: TCP\n          port: 443\n    # Deny all other external traffic (explicitly, if needed, though often implicit)\n    - to:\n        - ipBlock:\n            cidr: 0.0.0.0/0\n            except:\n              - 203.0.113.42/32\n      ports: [] # No ports allowed for other external IPs\n",
        "context": "Kubernetes NetworkPolicy to restrict egress from a malware analysis sandbox to a specific C2 server."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "CONTAINER_NETWORK_SECURITY",
      "MALWARE_ANALYSIS_NETWORKING"
    ]
  },
  {
    "question_text": "A Kubernetes pod is configured with `privileged: true`. Which Pod Security Standard is violated by this configuration, and why is it considered a critical security risk?",
    "correct_answer": "The &#39;Restricted&#39; Pod Security Standard is violated because `privileged: true` grants the container all capabilities on the host, allowing direct access to host devices and kernel features, which can lead to container escape.",
    "distractors": [
      {
        "question_text": "The &#39;Baseline&#39; Pod Security Standard is violated because `privileged: true` allows the container to run as root, which is prohibited by Baseline.",
        "misconception": "Targets misunderstanding of Baseline scope: Students confuse &#39;running as root&#39; (which Baseline allows if not explicitly prevented by runAsNonRoot) with &#39;privileged mode&#39;. Baseline does not prohibit privileged containers."
      },
      {
        "question_text": "The &#39;Privileged&#39; Pod Security Standard is violated because it is designed to prevent any container from running with elevated privileges.",
        "misconception": "Targets misinterpretation of standard names: Students assume &#39;Privileged&#39; standard means prohibiting privileged containers, when in fact, the &#39;Privileged&#39; standard is the most permissive and allows privileged containers."
      },
      {
        "question_text": "No Pod Security Standard is directly violated, as `privileged: true` is a valid configuration for certain system-level applications.",
        "misconception": "Targets underestimation of security risk: Students might believe that if a configuration is &#39;valid&#39; (i.e., Kubernetes allows it), it doesn&#39;t violate security best practices or standards, ignoring the inherent risks."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `privileged: true` setting in a container&#39;s security context grants the container all Linux capabilities and removes all seccomp, AppArmor, and SELinux restrictions. This effectively gives the container root access to the host node, allowing it to interact directly with host devices and kernel modules. This capability is explicitly prohibited by the &#39;Restricted&#39; Pod Security Standard, which aims to enforce strong hardening best practices. A container with `privileged: true` can easily perform container escape, gaining full control over the host system.",
      "distractor_analysis": "The &#39;Baseline&#39; standard allows `privileged: true` and only focuses on preventing known privilege escalations, not all elevated privileges. The &#39;Privileged&#39; standard is the most permissive and allows all configurations, including `privileged: true`. While `privileged: true` is technically a &#39;valid&#39; configuration that Kubernetes allows, it is a severe security risk and violates the &#39;Restricted&#39; standard, which represents best practices for general-purpose workloads.",
      "analogy": "Configuring a container with `privileged: true` is like giving a guest in your house the master key to every room, including the basement where all your utilities and sensitive documents are stored. The &#39;Restricted&#39; standard says, &#39;No, guests only get access to the living room and kitchen, and definitely no master keys.&#39;"
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: privileged-pod\nspec:\n  containers:\n  - name: my-container\n    image: busybox\n    command: [&quot;sleep&quot;, &quot;3600&quot;]\n    securityContext:\n      privileged: true # This violates the Restricted Pod Security Standard",
        "context": "Example Pod manifest demonstrating a privileged container configuration."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "POD_SECURITY_STANDARDS",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "A containerized application is found to be executing `cmd.exe` and redirecting its standard I/O to a network socket, effectively creating a reverse shell. Which securityContext setting would prevent this specific action by disallowing the necessary privilege escalation?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students might think preventing root access automatically prevents all privilege escalation, but a non-root user can still escalate privileges if allowPrivilegeEscalation is true and capabilities are present."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might confuse filesystem immutability with process privilege control. A read-only filesystem prevents writing to the root filesystem but doesn&#39;t stop a process from creating a reverse shell if it has the necessary execution privileges."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets incomplete solution: While dropping capabilities is crucial for defense in depth, allowPrivilegeEscalation: false specifically prevents a process from gaining *more* privileges than its parent, which is a direct mechanism to stop the `CreateProcessA` with modified `STARTUPINFO` from succeeding if it requires new privileges."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` security context setting prevents a process from gaining more privileges than its parent. In the context of a reverse shell created by manipulating `STARTUPINFO` for `CreateProcessA`, this setting would prevent the `cmd.exe` process from inheriting or gaining the necessary privileges to redirect standard I/O to a network socket if the parent process itself didn&#39;t have those privileges, or if the act of creating the reverse shell is considered a privilege escalation. It&#39;s a direct control against a process attempting to elevate its own privileges.",
      "distractor_analysis": "`runAsNonRoot: true` prevents the container from running as UID 0, but a non-root user can still perform malicious actions, including creating a reverse shell, if other security controls are not in place. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which is good for integrity but doesn&#39;t prevent a process from executing commands or establishing network connections. `capabilities.drop: [&quot;ALL&quot;]` is a strong control that removes all Linux capabilities, which would indeed prevent many privilege escalation techniques, including those that might facilitate a reverse shell. However, `allowPrivilegeEscalation: false` is a more direct and specific control against the *act of privilege escalation* itself, which is what the `CreateProcessA` manipulation attempts to achieve by giving `cmd.exe` control over the network socket.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;you cannot get a bigger key than the one you already have.&#39; Even if you have a small key (limited privileges), you can&#39;t use it to unlock a master key cabinet. `runAsNonRoot` is like saying &#39;you can&#39;t be the building manager.&#39; `readOnlyRootFilesystem` is like saying &#39;you can&#39;t change the building&#39;s blueprints.&#39; `capabilities.drop: [&quot;ALL&quot;]` is like taking away all your tools. All are important, but `allowPrivilegeEscalation: false` directly addresses the attempt to gain *more* access."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      # Other security settings for defense in depth\n      # runAsNonRoot: true\n      # capabilities:\n      #   drop: [&quot;ALL&quot;]\n      # seccompProfile:\n      #   type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false`"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_ESCAPE_TECHNIQUES",
      "PRIVILEGE_ESCALATION"
    ]
  },
  {
    "question_text": "A containerized application is found to be dropping a malicious DLL into a system directory and modifying a registry key to achieve persistence via GINA interception. Which securityContext setting would have prevented the initial dropping of the DLL into a system directory?",
    "correct_answer": "readOnlyRootFilesystem: true",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets setting confusion: Students might confuse preventing privilege escalation with preventing writes to the filesystem. allowPrivilegeEscalation prevents a process from gaining more privileges than its parent, not from writing to the filesystem."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students might believe running as a non-root user inherently prevents writing to system directories. While it makes it harder, if the non-root user has write permissions to a system directory (e.g., via a volume mount), this setting alone won&#39;t prevent it."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets capability misunderstanding: Students might think dropping all capabilities prevents all filesystem writes. While dropping capabilities is crucial for security, it primarily restricts privileged operations, not standard file writes, unless specific capabilities related to filesystem manipulation (like CAP_DAC_OVERRIDE) are involved and the target directory is protected."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `readOnlyRootFilesystem: true` setting in a Kubernetes `securityContext` makes the container&#39;s root filesystem read-only. This directly prevents the container from writing new files or modifying existing ones in system directories, thus stopping the malicious DLL from being dropped onto the disk. This is a fundamental control for preventing persistence mechanisms that rely on writing to the container&#39;s filesystem.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but doesn&#39;t directly restrict filesystem writes. `runAsNonRoot: true` ensures the container runs as a non-root user, which is good practice, but a non-root user could still write to directories if they have permissions (e.g., if a volume is mounted with write access). `capabilities.drop: [&quot;ALL&quot;]` removes all Linux capabilities, significantly reducing the attack surface, but it doesn&#39;t inherently make the filesystem read-only; a process could still write to allowed locations if it has the necessary user permissions.",
      "analogy": "Imagine `readOnlyRootFilesystem: true` as locking down all the shelves in a library so no new books can be added or existing ones changed. `runAsNonRoot: true` is like ensuring only librarians (non-root users) can access the library, but they could still add books if the shelves weren&#39;t locked. `allowPrivilegeEscalation: false` is like preventing a librarian from becoming a manager, and `capabilities.drop: [&quot;ALL&quot;]` is like taking away all their special tools."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-app\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      readOnlyRootFilesystem: true",
        "context": "Kubernetes Pod manifest snippet demonstrating readOnlyRootFilesystem"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_FILESYSTEMS",
      "MALWARE_PERSISTENCE_MECHANISMS"
    ]
  },
  {
    "question_text": "A Kubernetes Pod is configured with `privileged: true`. Which Pod Security Standard does this configuration violate, and why is it a significant security risk?",
    "correct_answer": "The &#39;Restricted&#39; Pod Security Standard, because it allows the container to access all device nodes and bypass kernel security protections, enabling potential container escapes.",
    "distractors": [
      {
        "question_text": "The &#39;Baseline&#39; Pod Security Standard, because it allows the container to run as root, which is generally discouraged.",
        "misconception": "Targets scope confusion: Students might confuse &#39;privileged: true&#39; with simply running as root. While running as root is a concern, &#39;privileged: true&#39; grants far more dangerous capabilities than just root access, and &#39;Baseline&#39; allows running as root."
      },
      {
        "question_text": "The &#39;Privileged&#39; Pod Security Standard, because it implies the container should not have such high privileges.",
        "misconception": "Targets terminology confusion: Students might incorrectly assume a &#39;Privileged&#39; standard would *restrict* privileged containers, when in fact, the &#39;Privileged&#39; standard is the most permissive and allows such configurations."
      },
      {
        "question_text": "The &#39;HostProcess&#39; Pod Security Standard, because it allows direct access to the host&#39;s process space.",
        "misconception": "Targets feature confusion: Students might confuse &#39;privileged: true&#39; with the Windows-specific &#39;HostProcess&#39; containers, which are distinct concepts for host interaction."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `privileged: true` setting in a Kubernetes Pod&#39;s security context grants the container all capabilities to the host machine, essentially making it equivalent to running a process directly on the host. This bypasses many kernel security protections and allows the container to access host devices, manipulate the host filesystem, and perform actions that can lead to a container escape. The &#39;Restricted&#39; Pod Security Standard explicitly disallows `privileged: true` because of these severe security implications, aiming for a hardened, production-ready environment.",
      "distractor_analysis": "The &#39;Baseline&#39; standard allows containers to run as root, so `privileged: true` is a different, more severe violation. The &#39;Privileged&#39; standard is the most permissive and *allows* `privileged: true`, so it&#39;s not violated. &#39;HostProcess&#39; containers are a specific Windows feature and not directly related to the `privileged: true` setting in a general Kubernetes context.",
      "analogy": "Think of `privileged: true` as giving a guest in your house the master key to every room, including the basement where all the utilities and controls are. The &#39;Restricted&#39; standard is like only giving them a key to their bedroom and common areas, ensuring they can&#39;t tamper with the house&#39;s core systems."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: privileged-pod\nspec:\n  containers:\n  - name: my-container\n    image: busybox\n    command: [&quot;sleep&quot;, &quot;3600&quot;]\n    securityContext:\n      privileged: true # This setting violates the Restricted Pod Security Standard\n",
        "context": "Example Pod manifest demonstrating the use of `privileged: true`"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "POD_SECURITY_STANDARDS",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "During dynamic analysis of a malware sample, you observe it attempting to connect to an FTP server and upload files. Which security context setting, if applied to a container running this malware for analysis, would prevent it from establishing outbound network connections to the internet?",
    "correct_answer": "networkPolicy: Deny all egress traffic by default",
    "distractors": [
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets scope confusion: Students might think making the filesystem read-only would prevent network activity, but it only affects local file modifications, not network connections."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets privilege misunderstanding: Students might associate root user with all powerful actions, but running as a non-root user does not inherently restrict network access; it primarily limits local system access."
      },
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets specific capability confusion: Students might believe preventing privilege escalation would stop network connections, but this setting prevents gaining additional privileges, not the initial network access itself, which doesn&#39;t require escalated privileges."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To prevent a container from establishing outbound network connections, a Kubernetes NetworkPolicy is the most effective control. By default, pods can communicate with any IP address. A NetworkPolicy can be configured to deny all egress traffic from a pod or namespace, effectively air-gapping the container from external networks, including FTP servers. This is crucial for safely analyzing malware without risking its communication with command-and-control servers or exfiltration of data.",
      "distractor_analysis": "readOnlyRootFilesystem: true prevents the container from writing to its root filesystem but does not restrict network access. runAsNonRoot: true ensures the container runs as a non-root user, which is good practice for limiting local privileges but has no direct impact on outbound network connectivity. allowPrivilegeEscalation: false prevents a process from gaining more privileges than its parent, but establishing an outbound network connection typically does not require privilege escalation.",
      "analogy": "Think of a NetworkPolicy as a firewall for your container. If you want to prevent a containerized malware sample from &#39;calling home&#39; (connecting to an FTP server), you put a firewall rule in place that blocks all outgoing calls. Other security contexts are like locking the doors inside the house (readOnlyRootFilesystem) or making sure the person inside isn&#39;t an administrator (runAsNonRoot), which are important, but don&#39;t stop them from using the phone if it&#39;s connected."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-all-egress\nspec:\n  podSelector: {}\n  policyTypes:\n    - Egress\n  egress: []",
        "context": "Kubernetes NetworkPolicy to deny all egress traffic from pods in the namespace where it&#39;s applied. This would prevent the malware from connecting to external FTP servers."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORKING",
      "NETWORK_POLICIES",
      "CONTAINER_SECURITY_CONTEXTS",
      "MALWARE_ANALYSIS_LAB_SETUP"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is primarily designed to prevent a container from gaining additional privileges after it starts, even if it initially runs as a non-root user?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets initial privilege confusion: Students confuse preventing initial root execution with preventing privilege escalation; runAsNonRoot only ensures the container starts as a non-root user, it doesn&#39;t stop it from escalating later if other conditions allow."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets scope misunderstanding: Students think making the filesystem read-only prevents all forms of privilege escalation, but many escalation techniques don&#39;t rely on writing to the root filesystem (e.g., exploiting kernel vulnerabilities or capabilities)."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets partial solution bias: While dropping capabilities is crucial for preventing escalation, allowPrivilegeEscalation: false specifically prevents the `no_new_privs` flag from being set, which is a distinct mechanism that complements capability dropping by preventing the container from gaining *any* new privileges."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting in a Kubernetes security context directly controls the `no_new_privs` flag for the container process. When set to `false`, it prevents a process from gaining more privileges than its parent process. This is a critical defense-in-depth control against privilege escalation, even if the container starts as a non-root user, by blocking mechanisms like `setuid` or `setgid` binaries from granting elevated permissions.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container starts with a non-root UID but doesn&#39;t prevent it from escalating privileges later. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which helps prevent certain attacks but not all forms of privilege escalation. `capabilities.drop: [&quot;ALL&quot;]` is an excellent security measure to remove dangerous Linux capabilities, but `allowPrivilegeEscalation: false` provides an additional layer of protection by preventing the acquisition of *any* new privileges, even if some capabilities were initially granted or if other vulnerabilities exist.",
      "analogy": "Think of `runAsNonRoot: true` as ensuring an employee starts their shift without a master key. `allowPrivilegeEscalation: false` is like a policy that prevents them from *ever* acquiring a master key during their shift, even if they find one or are given one by mistake. `capabilities.drop: [&quot;ALL&quot;]` is like taking away all their specialized tools. All three work together for better security."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      capabilities:\n        drop: [&quot;ALL&quot;]\n",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` within a security context."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGE_ESCALATION",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining additional privileges after it starts, thereby mitigating privilege escalation attempts?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope confusion: Students confuse preventing initial root execution with preventing privilege escalation; runAsNonRoot prevents starting as root, but doesn&#39;t stop a non-root user from escalating privileges if allowed."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type misunderstanding: Students might think making the filesystem read-only prevents all privilege escalation, but it primarily prevents writing to the root filesystem, not necessarily gaining new capabilities or user IDs."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets incomplete understanding of defense-in-depth: While dropping capabilities is crucial for preventing privilege escalation, allowPrivilegeEscalation: false specifically prevents a process from gaining *new* privileges, even if some capabilities were initially granted. Dropping ALL capabilities is a strong measure, but allowPrivilegeEscalation targets the *escalation* mechanism directly."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting in a container&#39;s security context prevents a process from gaining more privileges than its parent process. Specifically, it prevents the `setuid` and `setgid` bits from being honored and prevents the `CAP_SETUID` and `CAP_SETGID` capabilities from being used to change user or group IDs. This directly mitigates many common privilege escalation techniques within a container.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container does not start as the root user, but a non-root user could still escalate privileges if the container&#39;s security context or underlying system allows it. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which is good for integrity but doesn&#39;t directly prevent a process from gaining new capabilities or changing its user ID. `capabilities.drop: [&quot;ALL&quot;]` is a very strong security measure that removes all Linux capabilities, significantly reducing the attack surface. However, `allowPrivilegeEscalation: false` specifically targets the *mechanism* of privilege escalation, ensuring that even if some capabilities were present, a process cannot gain *additional* privileges beyond what it started with. It&#39;s a direct control against the escalation itself.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re inside, you can&#39;t get a bigger key.&#39; `runAsNonRoot: true` is like saying &#39;you can&#39;t enter with the master key.&#39; `readOnlyRootFilesystem: true` is like saying &#39;you can&#39;t change the locks on the doors.&#39; While all are good, `allowPrivilegeEscalation: false` directly addresses the act of trying to get a bigger key."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: no-privilege-escalation-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      # Optional: Combine with other settings for defense in depth\n      # runAsNonRoot: true\n      # capabilities:\n      #   drop: [&quot;ALL&quot;]\n",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false`"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGES",
      "CONTAINER_PRIVILEGE_ESCALATION"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is primarily designed to prevent a container from gaining additional privileges beyond those it started with, specifically blocking actions like `setuid` or `setgid` binaries from elevating privileges?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope confusion: Students confuse preventing initial root execution with preventing privilege escalation; runAsNonRoot prevents a container from starting as UID 0, but doesn&#39;t block escalation if it starts as a non-root user with certain capabilities."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets mechanism misunderstanding: While dropping capabilities is crucial for security, allowPrivilegeEscalation specifically targets the `no_new_privs` flag, which is distinct from dropping capabilities. Dropping ALL capabilities is a broader measure, but `allowPrivilegeEscalation: false` directly addresses the `setuid`/`setgid` vector."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets severity confusion: Students might think `privileged: false` covers all privilege-related issues. However, `privileged: false` only prevents the container from running with all host capabilities and access to host devices; it doesn&#39;t specifically prevent privilege escalation within the container&#39;s granted capabilities."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting in a Kubernetes security context directly corresponds to the `no_new_privs` flag in Linux. When set to `false`, it prevents a process from gaining new privileges after its execution, specifically blocking the use of `setuid` or `setgid` binaries to elevate privileges. This is a critical control for preventing privilege escalation attacks within a container.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container doesn&#39;t start as the root user (UID 0) but doesn&#39;t prevent a non-root user from escalating privileges if allowed. `capabilities.drop: [&quot;ALL&quot;]` is a strong security measure that removes all Linux capabilities, which would implicitly prevent many forms of privilege escalation, but `allowPrivilegeEscalation: false` specifically targets the `no_new_privs` flag, which is a distinct and important control. `privileged: false` prevents the container from running in privileged mode (which grants all capabilities and host access) but doesn&#39;t specifically prevent privilege escalation if the container already has some capabilities.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re in, you can&#39;t get a bigger key.&#39; `runAsNonRoot: true` is like saying &#39;you can&#39;t enter with the master key.&#39; `capabilities.drop: [&quot;ALL&quot;]` is like taking away all keys you might have. `privileged: false` is like not giving you the master key to the entire building in the first place."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: no-priv-escalation-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      capabilities:\n        drop: [&quot;ALL&quot;]\n",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` within a security context."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "definition",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGES",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from performing actions like mounting filesystems or manipulating network interfaces, which are common in container escape attempts?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete understanding of &#39;privileged&#39;: Students often believe &#39;privileged: false&#39; removes all dangerous capabilities, but it only prevents the container from running with *all* host capabilities. Default capabilities, including some dangerous ones, can still be present."
      },
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets confusion between initial capabilities and escalation: Students confuse preventing initial dangerous capabilities with preventing a process from gaining *more* privileges than its parent. While important, it doesn&#39;t remove dangerous capabilities the container might start with."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets scope misunderstanding: Students might think making the root filesystem read-only prevents all host interaction. While it limits writing to the container&#39;s root, it doesn&#39;t prevent actions like mounting new filesystems or manipulating network interfaces if the container retains the necessary capabilities."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Linux capabilities allow granular control over privileged operations. By default, containers run with a set of capabilities that, while reduced from a full root user, can still be exploited for container escapes (e.g., CAP_SYS_ADMIN, CAP_NET_ADMIN, CAP_DAC_OVERRIDE). The `capabilities.drop: [&quot;ALL&quot;]` setting removes all default capabilities, forcing the container to run with the absolute minimum privileges. This significantly reduces the attack surface for container escape techniques that rely on exploiting these capabilities, such as mounting host paths or manipulating network settings.",
      "distractor_analysis": "`privileged: false` is a good practice but doesn&#39;t remove all dangerous capabilities; it merely prevents the container from running with *all* host capabilities. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t remove the initial set of capabilities. `readOnlyRootFilesystem: true` prevents writes to the container&#39;s root filesystem but doesn&#39;t stop a container with sufficient capabilities from mounting new filesystems or interacting with the host&#39;s network stack.",
      "analogy": "Imagine a security guard (container) with a set of tools (capabilities). `capabilities.drop: [&quot;ALL&quot;]` is like taking away all the guard&#39;s tools except for a flashlight, making it very hard for them to break into restricted areas. `privileged: false` is like giving them a smaller, but still potentially dangerous, toolkit. `allowPrivilegeEscalation: false` is like preventing them from asking for more tools. `readOnlyRootFilesystem: true` is like making sure they can&#39;t write on the walls, but they still might have tools to open doors."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: restricted-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Pod security context demonstrating the dropping of all capabilities for enhanced security."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "LINUX_CAPABILITIES",
      "CONTAINER_SECURITY_CONTEXTS",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "A Kubernetes application is deployed with a web server that is vulnerable to SQL Injection. Which NetworkPolicy configuration would best limit the blast radius if the web server container is compromised?",
    "correct_answer": "Egress NetworkPolicy allowing traffic only to necessary backend services and denying all other outbound traffic",
    "distractors": [
      {
        "question_text": "Ingress NetworkPolicy allowing traffic only from the load balancer and denying all other inbound traffic",
        "misconception": "Targets scope confusion: While important for initial protection, an Ingress policy does not limit the blast radius *after* a container is compromised, as the attack has already bypassed ingress."
      },
      {
        "question_text": "NetworkPolicy with `podSelector: {}` and `policyTypes: [&quot;Egress&quot;]` to deny all outbound traffic from the namespace",
        "misconception": "Targets over-restriction: Denying all outbound traffic from the entire namespace would break legitimate communication for other applications, not just the compromised one, and is too broad."
      },
      {
        "question_text": "SecurityContext setting `readOnlyRootFilesystem: true` for the web server container",
        "misconception": "Targets control plane confusion: `readOnlyRootFilesystem` is a security context setting that prevents writing to the container&#39;s filesystem, but it does not restrict network communication or limit lateral movement after compromise."
      }
    ],
    "detailed_explanation": {
      "core_logic": "An Egress NetworkPolicy is crucial for limiting the blast radius after a container compromise. By default, pods can communicate with any IP address. A well-configured Egress policy restricts outbound connections from the compromised web server to only the specific backend services it legitimately needs to interact with (e.g., a database, an API service). This prevents an attacker from using the compromised container to scan internal networks, exfiltrate data to arbitrary external IPs, or launch attacks against other internal systems.",
      "distractor_analysis": "An Ingress NetworkPolicy protects against external attacks reaching the web server, but once the server is compromised (as in the scenario), it does not limit what the compromised server can do *outbound*. Denying all outbound traffic from the entire namespace is overly restrictive and would likely break other legitimate applications within that namespace. `readOnlyRootFilesystem: true` is a good security practice to prevent persistence or modification of the container&#39;s filesystem, but it does not address network-based lateral movement or data exfiltration, which are key concerns after a web server compromise.",
      "analogy": "Imagine a bank vault (the web server) is breached. An Ingress policy is like the outer wall of the bank. Once inside, an Egress policy is like internal doors that only allow the thief to go to specific, authorized areas (backend services) and prevent them from accessing other vaults or escaping with stolen money through unauthorized exits."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: web-server-egress-policy\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: web-server\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              app: database\n      ports:\n        - protocol: TCP\n          port: 5432\n    - to:\n        - podSelector:\n            matchLabels:\n              app: api-service\n      ports:\n        - protocol: TCP\n          port: 8080\n    # Optionally, allow DNS resolution\n    - to:\n        - ipBlock:\n            cidr: 0.0.0.0/0\n            except:\n              - 10.0.0.0/8 # Deny internal network access by default\n              - 172.16.0.0/12\n              - 192.168.0.0/16\n      ports:\n        - protocol: UDP\n          port: 53 # Allow DNS",
        "context": "Kubernetes NetworkPolicy to restrict egress traffic from a web server pod, allowing only necessary communication to backend services and DNS."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORKING",
      "NETWORK_POLICY_CONCEPTS",
      "CONTAINER_SECURITY_FUNDAMENTALS",
      "BLAST_RADIUS_MITIGATION"
    ]
  },
  {
    "question_text": "A Kubernetes pod is configured with `hostNetwork: true`. Which security context setting, if omitted, significantly increases the risk of a container escaping to the host network namespace and potentially sniffing host traffic?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets partial understanding of privilege escalation: While important, `allowPrivilegeEscalation: false` prevents gaining *new* privileges, but doesn&#39;t remove existing dangerous capabilities like `CAP_NET_RAW` that are often present by default and enable network sniffing."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets scope confusion: Students confuse filesystem immutability with network access control; `readOnlyRootFilesystem` prevents writing to the container&#39;s root filesystem but has no direct impact on network capabilities or host network access."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets user vs. capability confusion: Students might think running as non-root prevents network sniffing, but many network-related capabilities (like `CAP_NET_RAW`) can be used by non-root users within the container to interact with the host network."
      }
    ],
    "detailed_explanation": {
      "core_logic": "When `hostNetwork: true` is set, the container shares the host&#39;s network namespace, meaning it can see all network interfaces and traffic on the host. Without explicitly dropping capabilities, containers often retain `CAP_NET_RAW`, which allows them to create raw sockets and perform network sniffing (e.g., using `tcpdump`). Dropping all capabilities, or at least `CAP_NET_RAW`, is crucial to prevent this type of host escape and traffic interception when `hostNetwork: true` is enabled.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` is good practice but doesn&#39;t remove capabilities already granted. `readOnlyRootFilesystem: true` secures the filesystem but not network access. `runAsNonRoot: true` prevents running as UID 0 but doesn&#39;t restrict capabilities that allow network sniffing, which can be performed by non-root users with `CAP_NET_RAW`.",
      "analogy": "Imagine giving a guest full access to your house&#39;s internet connection (`hostNetwork: true`). If you don&#39;t take away their special &#39;network snooping&#39; tools (capabilities like `CAP_NET_RAW`), they can listen to all your network traffic, even if they&#39;re not an administrator of your house (`runAsNonRoot: true`) or can&#39;t change the house&#39;s structure (`readOnlyRootFilesystem: true`)."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: network-sniffer-pod\nspec:\n  hostNetwork: true\n  containers:\n  - name: sniffer\n    image: busybox\n    command: [&quot;sh&quot;, &quot;-c&quot;, &quot;sleep 3600&quot;]\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      runAsUser: 1000",
        "context": "Pod configuration demonstrating `hostNetwork: true` with crucial capability dropping for security."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORKING",
      "LINUX_CAPABILITIES",
      "CONTAINER_SECURITY_CONTEXTS"
    ]
  },
  {
    "question_text": "A containerized application is vulnerable to SQL Injection. Which Kubernetes NetworkPolicy configuration would best limit the blast radius of a successful SQLi attack, assuming the database is in a separate pod?",
    "correct_answer": "Egress NetworkPolicy from the application pod to only allow traffic to the database pod on the specific database port.",
    "distractors": [
      {
        "question_text": "Ingress NetworkPolicy on the application pod to only allow traffic from the load balancer.",
        "misconception": "Targets scope misunderstanding: While important for external access, an Ingress policy on the application pod does not restrict what the compromised application can do *outbound* after a SQLi, which is key to limiting blast radius."
      },
      {
        "question_text": "Egress NetworkPolicy from the application pod to block all outbound traffic.",
        "misconception": "Targets over-restriction: Blocking all outbound traffic would prevent the application from functioning correctly by disallowing legitimate database communication, making it an impractical solution for a running application."
      },
      {
        "question_text": "Ingress NetworkPolicy on the database pod to only allow traffic from the application pod.",
        "misconception": "Targets incomplete protection: This policy protects the database from unauthorized *inbound* connections, but it doesn&#39;t prevent a compromised application from making *outbound* connections to other internal or external services after a SQLi, which is part of the blast radius."
      }
    ],
    "detailed_explanation": {
      "core_logic": "A successful SQL Injection attack means the attacker has gained control over the application&#39;s database queries. To limit the &#39;blast radius&#39; (i.e., what else the attacker can do from the compromised application pod), you must restrict the application pod&#39;s *outbound* network communication. An Egress NetworkPolicy that specifically allows traffic *only* to the database pod on its designated port ensures that even if the application is compromised, it cannot initiate connections to other internal services, external hosts, or C2 servers, thus containing the attack.",
      "distractor_analysis": "An Ingress NetworkPolicy on the application pod (distractor 1) controls who can talk *to* the application, not what the application can talk *to* after compromise. Blocking all outbound traffic (distractor 2) is too restrictive and would break the application&#39;s legitimate communication with the database. An Ingress NetworkPolicy on the database pod (distractor 3) protects the database from other sources but doesn&#39;t prevent the compromised application from making unauthorized *outbound* connections to other targets.",
      "analogy": "Imagine a bank teller (application pod) who is forced to transfer money (SQLi). An Egress NetworkPolicy is like ensuring the teller can *only* transfer money to the vault (database pod) and nowhere else, preventing them from sending money to other accounts or external parties, even if compromised."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: app-egress-to-db\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: my-app\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              app: my-database\n      ports:\n        - protocol: TCP\n          port: 5432 # Example PostgreSQL port",
        "context": "Kubernetes NetworkPolicy to restrict egress from &#39;my-app&#39; to &#39;my-database&#39; on port 5432."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "SQL_INJECTION_BASICS",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from exploiting an XML External Entity (XXE) vulnerability to access local files on the host filesystem?",
    "correct_answer": "readOnlyRootFilesystem: true",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope confusion: Students might confuse general privilege escalation prevention with specific file system access prevention. allowPrivilegeEscalation prevents gaining new privileges, but doesn&#39;t directly restrict read access to the host filesystem if the container already has it or can achieve it through other means."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets insufficient privilege understanding: While good practice, running as non-root doesn&#39;t inherently prevent an XXE from reading files that are world-readable or accessible to the non-root user within the container&#39;s mounted filesystem, including potentially host mounts."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets overestimation of default security: Students might believe that simply not running in privileged mode is enough. While privileged mode grants extensive host access, an XXE can still read files from the host if the container&#39;s filesystem is not read-only and host paths are mounted or accessible."
      }
    ],
    "detailed_explanation": {
      "core_logic": "An XXE vulnerability allows an attacker to force the XML parser to include content from external URIs, which can include local files on the host filesystem (e.g., /etc/passwd). By setting readOnlyRootFilesystem: true, the container&#39;s root filesystem becomes immutable. This prevents the XXE from writing to the filesystem, and more importantly, it restricts the ability to create or modify files that might facilitate further exploitation or data exfiltration, making it harder for the XXE to read arbitrary host files if they are not explicitly mounted as read-only volumes.",
      "distractor_analysis": "allowPrivilegeEscalation: false prevents a process from gaining more privileges than its parent, but doesn&#39;t directly stop an already-running process with an XXE from reading files. runAsNonRoot: true ensures the container doesn&#39;t run as UID 0, which is good for general security, but doesn&#39;t prevent reading world-readable files or files accessible to the non-root user via XXE. privileged: false prevents the container from having full access to the host, but an XXE can still read files if the container&#39;s filesystem is writable or if host paths are mounted and accessible.",
      "analogy": "Imagine an XXE as a malicious librarian who can request any book. Setting readOnlyRootFilesystem: true is like making all the books in the library uncopyable and ensuring the librarian can&#39;t bring new, unauthorized books in or out. The librarian can still &#39;read&#39; what&#39;s there, but cannot modify or easily exfiltrate it if the filesystem is truly read-only and no writable mounts exist."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: xxe-vulnerable-app\nspec:\n  containers:\n  - name: my-app\n    image: vulnerable-image:latest\n    securityContext:\n      readOnlyRootFilesystem: true",
        "context": "Kubernetes Pod configuration with readOnlyRootFilesystem enabled to mitigate XXE file access"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "XXE_VULNERABILITIES",
      "CONTAINER_FILESYSTEMS"
    ]
  },
  {
    "question_text": "Which security context setting is most effective at preventing a container from gaining elevated privileges that could lead to a container escape, specifically by restricting its ability to perform privileged operations like mounting filesystems or manipulating kernel modules?",
    "correct_answer": "securityContext.capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "securityContext.allowPrivilegeEscalation: false",
        "misconception": "Targets partial understanding of privilege escalation: Students might think this setting alone prevents all privilege gains, but it only prevents a process from gaining more privileges than its parent, not from starting with dangerous capabilities."
      },
      {
        "question_text": "securityContext.privileged: false",
        "misconception": "Targets confusion with &#39;privileged&#39; mode: Students often equate &#39;privileged: false&#39; with complete security, but it only removes the broadest set of host access; containers can still have dangerous capabilities even when not &#39;privileged&#39;."
      },
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets user vs. capability confusion: Students confuse running as a non-root user with restricting kernel capabilities. A non-root user can still exploit dangerous capabilities if they are granted."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `securityContext.capabilities.drop: [&quot;ALL&quot;]` setting explicitly removes all Linux capabilities from the container. This is the most effective way to prevent a container from performing privileged operations that could lead to a container escape, such as exploiting `CAP_SYS_ADMIN` for mounting filesystems or loading kernel modules. By dropping all capabilities, the container operates with the absolute minimum privileges required, significantly reducing its attack surface.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but if the container starts with dangerous capabilities, this setting won&#39;t remove them. `privileged: false` is a broad setting that removes many host-level accesses but doesn&#39;t specifically drop individual capabilities that could still be exploited. `runAsNonRoot: true` ensures the container runs as a non-root user, which is good practice, but a non-root user can still leverage dangerous capabilities if they are not explicitly dropped.",
      "analogy": "Imagine a security guard (container) who is given a set of tools (capabilities). `drop: [&quot;ALL&quot;]` is like taking away all the tools, leaving them with nothing dangerous. `allowPrivilegeEscalation: false` is like saying they can&#39;t ask for more tools, but they still have whatever they started with. `privileged: false` is like taking away their master key but letting them keep a lock-picking set. `runAsNonRoot: true` is like making sure they&#39;re not the chief of security, but they might still have dangerous tools."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating a robust security context to prevent privilege escalation and container escape."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_PREVENTION"
    ]
  },
  {
    "question_text": "A Kubernetes pod running a critical microservice is configured with a `securityContext` that allows `CAP_NET_RAW` capability. Which container security control is most effective at preventing a container escape attempt that leverages this capability to inject malicious network packets onto the host network interface?",
    "correct_answer": "Dropping the `CAP_NET_RAW` capability from the container&#39;s `securityContext`.",
    "distractors": [
      {
        "question_text": "Setting `allowPrivilegeEscalation: false` in the `securityContext`.",
        "misconception": "Targets partial understanding of privilege escalation: Students might think `allowPrivilegeEscalation: false` prevents all privilege-related attacks, but it specifically prevents a process from gaining more privileges than its parent, not from exploiting existing dangerous capabilities like `CAP_NET_RAW`."
      },
      {
        "question_text": "Implementing a strict `NetworkPolicy` to restrict egress traffic from the pod.",
        "misconception": "Targets confusion between network policy and host-level capabilities: Students might conflate network-level controls with host-level capability exploitation. A `NetworkPolicy` controls traffic flow but does not prevent a container from manipulating the host&#39;s network interface if it has `CAP_NET_RAW`."
      },
      {
        "question_text": "Enforcing the `Baseline` Pod Security Standard on the namespace.",
        "misconception": "Targets misunderstanding of PSS profiles: Students might believe the `Baseline` profile is sufficient for all critical security, but it explicitly allows `CAP_NET_RAW` and other dangerous capabilities, making it ineffective against this specific attack."
      }
    ],
    "detailed_explanation": {
      "core_logic": "`CAP_NET_RAW` allows a process to create raw sockets, which can be used to inject arbitrary network packets onto the host&#39;s network interfaces, bypassing network stack rules and potentially leading to host compromise or network-level attacks. The most direct and effective way to prevent this specific attack vector is to remove the `CAP_NET_RAW` capability from the container&#39;s `securityContext` by explicitly dropping it. This adheres to the principle of least privilege by ensuring the container only has the capabilities it absolutely needs.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it does not remove existing dangerous capabilities like `CAP_NET_RAW`. A `NetworkPolicy` restricts network traffic at the Kubernetes level but does not prevent a container with `CAP_NET_RAW` from directly manipulating the host&#39;s network interface. The `Baseline` Pod Security Standard explicitly allows `CAP_NET_RAW`, so enforcing it would not prevent this attack.",
      "analogy": "Imagine a security guard (container) who has a special tool (CAP_NET_RAW) that lets them bypass the main gate (network stack) and directly tamper with the building&#39;s wiring (host network interface). The most effective way to prevent this is to take away that specific tool (drop CAP_NET_RAW), rather than just telling them not to use it (allowPrivilegeEscalation: false), or building a fence around the building (NetworkPolicy), or having a basic security policy that still allows them to carry the tool (Baseline PSS)."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      capabilities:\n        drop:\n        - ALL\n        add:\n        - NET_BIND_SERVICE # Example of a safe capability to add if needed\n",
        "context": "Kubernetes Pod manifest demonstrating how to drop all capabilities, including CAP_NET_RAW, for a container."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_TECHNIQUES",
      "POD_SECURITY_STANDARDS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges by disallowing the `setuid` and `setgid` bits from being honored?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing a container from starting as root with preventing privilege escalation during runtime. `runAsNonRoot` only checks the initial UID."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets mechanism confusion: Students might think making the filesystem read-only prevents all privilege escalation, but it primarily prevents writing to the root filesystem, not necessarily executing `setuid` binaries if they already exist."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets incomplete understanding of privilege escalation: While dropping capabilities is crucial, `allowPrivilegeEscalation: false` specifically addresses the `setuid`/`setgid` mechanism, which `capabilities.drop` alone might not fully cover if a dangerous capability like `CAP_SETUID` is retained or if the binary itself is the vector."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting directly controls whether a process can gain more privileges than its parent. Specifically, it prevents a process from honoring the `setuid` or `setgid` bits on an executable, which are common mechanisms for privilege escalation. This is a critical control for preventing an attacker from using a compromised application to elevate their privileges within the container.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container starts as a non-root user but doesn&#39;t prevent that non-root user from escalating privileges later if `setuid` binaries are present and `allowPrivilegeEscalation` is true. `readOnlyRootFilesystem: true` prevents modifications to the root filesystem but doesn&#39;t inherently stop the execution of existing `setuid` binaries. `capabilities.drop: [&quot;ALL&quot;]` is a strong control, but `allowPrivilegeEscalation: false` specifically targets the `setuid`/`setgid` mechanism, which is a distinct and important vector for privilege escalation, even if some capabilities are dropped.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;you can&#39;t use a special key found on the floor to open a locked door, even if you pick it up.&#39; `runAsNonRoot` is like saying &#39;you must enter through the main door, not the service entrance.&#39; `readOnlyRootFilesystem` is like saying &#39;you can&#39;t change the locks on any doors.&#39; While all are security measures, `allowPrivilegeEscalation` directly addresses the act of using `setuid`/`setgid` to gain higher access."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      capabilities:\n        drop: [&quot;ALL&quot;]\n",
        "context": "A Pod definition demonstrating `allowPrivilegeEscalation: false` within its security context to prevent privilege escalation."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGE_ESCALATION_FUNDAMENTALS",
      "POD_SECURITY_STANDARDS"
    ]
  },
  {
    "question_text": "A critical application pod needs to communicate only with a specific database service within the same namespace and deny all other egress traffic. Which NetworkPolicy configuration achieves this with the principle of least privilege?",
    "correct_answer": "Egress rule allowing traffic to database pod selector on specific port, with default deny egress policy",
    "distractors": [
      {
        "question_text": "Ingress rule allowing traffic from database pod selector on specific port, with default deny ingress policy",
        "misconception": "Targets confusion between ingress and egress: Students might confuse the direction of traffic, applying an ingress rule when an egress rule is needed for outbound connections."
      },
      {
        "question_text": "Egress rule allowing traffic to all pods in the same namespace on all ports",
        "misconception": "Targets over-permissioning in network policies: Students might grant broader access than necessary, violating least privilege by allowing communication to all pods instead of just the database."
      },
      {
        "question_text": "No NetworkPolicy, relying on service mesh for traffic control",
        "misconception": "Targets misunderstanding of NetworkPolicy&#39;s role: Students might think a service mesh completely replaces the need for NetworkPolicies, but they serve different, complementary security functions."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To restrict outbound (egress) traffic from the application pod, an `egress` rule is required. The principle of least privilege dictates that this rule should only permit traffic to the specific database service, identified by its `podSelector`, and only on the necessary port. A default deny egress policy (implicitly or explicitly defined by the absence of other egress rules) ensures that any traffic not explicitly allowed is blocked, effectively isolating the application pod&#39;s outbound connections.",
      "distractor_analysis": "An `ingress` rule controls inbound traffic to the application pod, not outbound traffic from it. Allowing traffic to `all pods in the same namespace` on `all ports` is an over-permissioned approach that violates the principle of least privilege, as it grants access beyond the database. While service meshes provide advanced traffic management, NetworkPolicies operate at a lower layer (Layer 3/4) and are crucial for enforcing network segmentation and baseline security, complementing service mesh functionalities rather than replacing them.",
      "analogy": "Think of the application pod as a person in a secure room. An egress rule is like a guard checking who they are allowed to call (outbound). The correct answer is like giving them a phone number for only one specific contact (the database) and blocking all other outgoing calls. An ingress rule would be checking who can call *them* (inbound)."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: app-db-egress-policy\n  namespace: my-app-namespace\nspec:\n  podSelector:\n    matchLabels:\n      app: my-application\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              app: my-database\n      ports:\n        - protocol: TCP\n          port: 5432",
        "context": "NetworkPolicy allowing egress only to a specific database service on a specific port."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "NETWORK_SEGMENTATION",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "Which image scanning technique is most effective at detecting known vulnerabilities in application dependencies (e.g., Log4j, OpenSSL) within a container image?",
    "correct_answer": "Software Bill of Materials (SBOM) analysis combined with vulnerability databases",
    "distractors": [
      {
        "question_text": "Static Application Security Testing (SAST) of the application code",
        "misconception": "Targets scope confusion: Students might confuse SAST, which analyzes custom application code, with dependency scanning, which focuses on third-party libraries and packages."
      },
      {
        "question_text": "Dynamic Application Security Testing (DAST) of the running container",
        "misconception": "Targets confusion between static and dynamic analysis: Students might think DAST, which tests a running application, is suitable for detecting vulnerabilities in *image components* rather than runtime behavior."
      },
      {
        "question_text": "Runtime behavioral analysis of the deployed container",
        "misconception": "Targets confusion between detection and prevention/pre-deployment: Students might think runtime analysis is the primary method for detecting *known vulnerabilities* in dependencies, rather than pre-deployment scanning."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Detecting known vulnerabilities in application dependencies requires identifying all software components within the container image (an SBOM) and then cross-referencing these components against comprehensive vulnerability databases (like CVEs). Tools that generate an SBOM and perform this lookup are specifically designed for this purpose, providing a list of vulnerable packages and their associated CVEs.",
      "distractor_analysis": "Static Application Security Testing (SAST) analyzes the *source code* of the application itself for coding flaws, not the third-party libraries it uses. Dynamic Application Security Testing (DAST) tests the *running application* for vulnerabilities that manifest at runtime, such as injection flaws or misconfigurations, but it&#39;s less effective at identifying known vulnerabilities in static dependencies within the image. Runtime behavioral analysis monitors the container&#39;s actions for anomalous behavior, which might indicate an exploit, but it doesn&#39;t proactively identify known vulnerabilities in the image&#39;s components before deployment.",
      "analogy": "Imagine building a house (container image) with pre-fabricated parts (dependencies). SAST is like checking the blueprints for your custom additions. DAST is like testing if the house stands up to a storm. Runtime behavioral analysis is like having a security guard watch for intruders *after* the house is built. SBOM analysis with vulnerability databases is like checking the serial numbers of all pre-fabricated parts against a recall list *before* you even start building."
    },
    "code_snippets": [
      {
        "language": "bash",
        "code": "trivy image --format cyclonedx --output my-image-sbom.json my-image:latest\ntrivy image --severity HIGH,CRITICAL my-image:latest",
        "context": "Example commands using Trivy to generate an SBOM and scan a container image for vulnerabilities."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "procedure",
    "prerequisites": [
      "CONTAINER_IMAGE_SECURITY",
      "VULNERABILITY_MANAGEMENT",
      "SOFTWARE_SUPPLY_CHAIN_SECURITY"
    ]
  },
  {
    "question_text": "Which Kubernetes RBAC configuration grants a ServiceAccount the ability to create new Pods in a specific namespace, while adhering to the principle of least privilege?",
    "correct_answer": "A Role with &#39;create&#39; verb on &#39;pods&#39; resource, bound to the ServiceAccount via a RoleBinding in the target namespace",
    "distractors": [
      {
        "question_text": "A ClusterRole with &#39;create&#39; verb on &#39;pods&#39; resource, bound to the ServiceAccount via a ClusterRoleBinding",
        "misconception": "Targets scope over-permissioning: Students might use ClusterRole for namespace-scoped actions, granting unnecessary cluster-wide permissions."
      },
      {
        "question_text": "A Role with &#39;*&#39; verb on &#39;pods&#39; resource, bound to the ServiceAccount via a RoleBinding in the target namespace",
        "misconception": "Targets verb over-permissioning: Students might use wildcard verbs for convenience, granting more permissions (e.g., delete, update) than strictly necessary for &#39;create&#39;."
      },
      {
        "question_text": "A ServiceAccount with &#39;admin&#39; role directly assigned in the target namespace",
        "misconception": "Targets misunderstanding of direct role assignment: Students might think roles are directly assigned to ServiceAccounts, rather than through RoleBindings, and &#39;admin&#39; is often too broad."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To grant permissions within a specific namespace, a `Role` is the appropriate RBAC object. The `Role` should specify the `create` verb for the `pods` resource, as this is the minimal permission required. This `Role` is then associated with the `ServiceAccount` using a `RoleBinding` within the same target namespace. This ensures the ServiceAccount can only create pods in that specific namespace and cannot perform other actions like deleting or updating pods, or creating pods in other namespaces.",
      "distractor_analysis": "A `ClusterRole` grants permissions across all namespaces, which violates the principle of least privilege if the requirement is only for a specific namespace. Using the `*` verb grants all possible actions (get, list, watch, create, update, patch, delete) on the `pods` resource, which is excessive if only `create` is needed. Roles are not directly assigned to ServiceAccounts; they are linked via `RoleBindings`. Additionally, an &#39;admin&#39; role typically includes many more permissions than just creating pods.",
      "analogy": "Imagine giving someone a key to a specific room (namespace). The correct answer is like giving them a key that only *opens* the door (create verb) to *that one room* (Role in namespace). Using a ClusterRole is like giving them a master key to the entire building. Using `*` verb is like giving them a key that can open, lock, and even dismantle the door. Directly assigning &#39;admin&#39; is like making them the building manager without proper authorization."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: pod-creator-sa\n  namespace: my-app-namespace\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-creator-role\n  namespace: my-app-namespace\nrules:\n- apiGroups: [&quot;&quot;]\n  resources: [&quot;pods&quot;]\n  verbs: [&quot;create&quot;]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-creator-rb\n  namespace: my-app-namespace\nsubjects:\n- kind: ServiceAccount\n  name: pod-creator-sa\n  namespace: my-app-namespace\nroleRef:\n  kind: Role\n  name: pod-creator-role\n  apiGroup: rbac.authorization.k8s.io",
        "context": "RBAC configuration for a ServiceAccount to create pods in a specific namespace."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "procedure",
    "prerequisites": [
      "KUBERNETES_RBAC",
      "LEAST_PRIVILEGE_PRINCIPLE",
      "KUBERNETES_NAMESPACES"
    ]
  },
  {
    "question_text": "Which image scanning technique is most analogous to AI-driven dynamic analysis for detecting vulnerabilities in container images?",
    "correct_answer": "Running the container image in a sandbox environment and observing its behavior during execution.",
    "distractors": [
      {
        "question_text": "Analyzing the Dockerfile for insecure configurations and deprecated commands.",
        "misconception": "Targets static analysis confusion: Students might confuse static analysis of the Dockerfile (build-time) with dynamic analysis (runtime behavior)."
      },
      {
        "question_text": "Checking the image&#39;s Bill of Materials (BOM) for known vulnerable package versions.",
        "misconception": "Targets SBOM confusion: Students might think SBOM analysis (static, dependency-based) is a form of dynamic analysis, but it&#39;s a different static technique."
      },
      {
        "question_text": "Scanning the image layers for hardcoded secrets and sensitive information.",
        "misconception": "Targets secret scanning confusion: Students might conflate secret scanning (a static content analysis) with runtime behavioral analysis."
      }
    ],
    "detailed_explanation": {
      "core_logic": "AI-driven dynamic analysis involves executing code to observe its runtime behavior and detect anomalies or suspicious patterns. In the context of container images, the most analogous technique is to run the container in a controlled, isolated (sandbox) environment and monitor its actions, network calls, file system changes, and process execution. This allows for the detection of vulnerabilities that only manifest during actual operation, similar to how AI explores code paths and observes runtime behavior.",
      "distractor_analysis": "Analyzing the Dockerfile for insecure configurations is a form of static analysis, examining the build instructions without running the container. Checking the image&#39;s Bill of Materials (BOM) for vulnerable package versions is also a static analysis technique, focusing on known vulnerabilities in dependencies. Scanning for hardcoded secrets is a content-based static analysis, looking for specific patterns within the image layers. None of these involve executing the container and observing its live behavior.",
      "analogy": "If static analysis is like reading a recipe to find potential cooking mistakes, dynamic analysis is like actually cooking the dish and tasting it to find flaws. AI enhances this by automatically trying many variations of the recipe and tasting them all."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "CONTAINER_IMAGE_SCANNING",
      "STATIC_VS_DYNAMIC_ANALYSIS",
      "AI_IN_CYBERSECURITY"
    ]
  },
  {
    "question_text": "A containerized application is observed performing direct memory manipulation, potentially leading to buffer overflows. Which securityContext setting is most effective at preventing such low-level memory corruption exploits from impacting the host kernel?",
    "correct_answer": "seccompProfile: type: RuntimeDefault",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope confusion: Students might confuse general privilege escalation with specific low-level system call restrictions. allowPrivilegeEscalation prevents gaining *new* privileges, but doesn&#39;t restrict existing syscalls."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets mechanism misunderstanding: Students might think making the filesystem read-only prevents all exploits, but memory corruption is distinct from filesystem writes and can still occur in writable memory regions."
      },
      {
        "question_text": "capabilities: drop: [&quot;ALL&quot;]",
        "misconception": "Targets incomplete protection: While dropping capabilities is crucial, it doesn&#39;t restrict all dangerous syscalls. Many syscalls that can lead to memory corruption are not directly tied to specific capabilities and require seccomp for granular control."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Buffer overflows and other memory corruption exploits often rely on making specific system calls (syscalls) to manipulate memory or execute arbitrary code. A `seccompProfile` of `type: RuntimeDefault` applies a default seccomp filter that blocks a wide range of dangerous syscalls, significantly reducing the attack surface for such exploits and preventing them from impacting the host kernel. This is a direct control over the syscall interface.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but doesn&#39;t restrict the syscalls it can make with its *current* privileges. `readOnlyRootFilesystem: true` prevents writes to the container&#39;s root filesystem, but memory corruption exploits operate on process memory, not necessarily the filesystem. `capabilities: drop: [&quot;ALL&quot;]` removes Linux capabilities, which is excellent for preventing many types of privilege escalation, but it doesn&#39;t cover all dangerous syscalls that could be used for memory corruption if not tied to a specific capability.",
      "analogy": "Think of `seccompProfile` as a bouncer at a club, only allowing specific, safe actions (syscalls) to pass through. `allowPrivilegeEscalation` is like preventing someone from getting a VIP pass once inside, `readOnlyRootFilesystem` is like locking the club&#39;s storage room, and `capabilities: drop: [&quot;ALL&quot;]` is like taking away all the bouncer&#39;s special tools. While all are good, the bouncer&#39;s strict entry rules (seccomp) are the most direct defense against dangerous actions."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: vulnerable-app\nspec:\n  containers:\n  - name: app\n    image: my-vulnerable-app:latest\n    securityContext:\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest applying a default seccomp profile to a container."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "LINUX_SYSCALLS",
      "SECCOMP_FUNDAMENTALS",
      "CONTAINER_SECURITY_CONTEXTS"
    ]
  },
  {
    "question_text": "A Kubernetes admission controller is designed to reject Pods that request `privileged: true`. An attacker attempts to bypass this by encoding the `privileged` field in a non-standard way within the YAML manifest. Which security assessment step is most critical for detecting this evasion technique?",
    "correct_answer": "Identify each location where input (YAML manifest) is decoded and correlate with security decisions (admission control).",
    "distractors": [
      {
        "question_text": "Perform static analysis on the admission controller&#39;s source code to find encoding/decoding functions.",
        "misconception": "Targets focus on implementation details over architectural flow: While static analysis is useful, the core issue is the *timing* of decoding relative to the security decision, not just the presence of functions."
      },
      {
        "question_text": "Implement a NetworkPolicy to restrict traffic to the Kubernetes API server.",
        "misconception": "Targets control plane confusion: NetworkPolicy is for network segmentation *between* pods/services, not for validating API server requests or preventing admission controller bypasses."
      },
      {
        "question_text": "Scan container images for known vulnerabilities that exploit YAML parsers.",
        "misconception": "Targets incorrect vulnerability scope: Image scanning focuses on application code and dependencies *inside* the container, not on how the Kubernetes control plane processes manifest definitions."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The scenario describes a metacharacter evasion technique where encoded input bypasses a security filter. The critical step, as outlined in security assessment best practices, is to identify where encoded input (like a YAML manifest) is decoded and then check if security decisions (like the admission controller&#39;s check for `privileged: true`) are made *before* or *after* this decoding. If decoding happens after the security decision, the encoded malicious input can bypass the check.",
      "distractor_analysis": "Static analysis of the admission controller&#39;s source code might reveal decoding functions, but it doesn&#39;t directly address the timing issue of decoding relative to the security decision, which is the core of the evasion. NetworkPolicy is a network-level control and irrelevant to API server request validation. Image scanning targets vulnerabilities within container images, not the Kubernetes control plane&#39;s handling of manifest definitions.",
      "analogy": "Imagine a security checkpoint where bags are scanned (security decision) but then opened and their contents rearranged (decoding) *after* the scan. If a prohibited item was cleverly hidden in a way that the scanner missed but becomes obvious after rearrangement, the security decision was made too early. The key is to ensure the security check happens on the fully &#39;decoded&#39; or &#39;unpacked&#39; item."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: privileged-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      privileged: true # This is the field the admission controller checks\n",
        "context": "Example of a Kubernetes Pod manifest with a privileged container, which an admission controller might reject."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "KUBERNETES_ADMISSION_CONTROLLERS",
      "CONTAINER_SECURITY_CONTEXTS",
      "SOFTWARE_SECURITY_ASSESSMENT_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "A Kubernetes pod is configured with `securityContext.privileged: true`. Which Pod Security Standard profile would explicitly block this configuration?",
    "correct_answer": "Restricted",
    "distractors": [
      {
        "question_text": "Baseline",
        "misconception": "Targets partial understanding of PSS profiles: Students might think Baseline is strict enough, but it allows privileged containers, focusing more on preventing hostPath mounts and specific capabilities."
      },
      {
        "question_text": "Privileged",
        "misconception": "Targets confusion with PSS profile names: Students might incorrectly associate the &#39;Privileged&#39; profile with blocking privileged containers, when in fact, this profile allows all security contexts."
      },
      {
        "question_text": "Host Access",
        "misconception": "Targets non-existent PSS profile: Students might invent a profile name based on the concept of host access, indicating a lack of familiarity with the actual PSS profiles."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `privileged: true` setting grants a container all capabilities to the host, essentially making it equivalent to a root process on the host. The Restricted Pod Security Standard profile explicitly disallows privileged containers, along with other settings that could lead to privilege escalation or host compromise. The Baseline profile allows privileged containers, and the Privileged profile allows all security contexts, including privileged.",
      "distractor_analysis": "The Baseline profile permits privileged containers, so it would not block this configuration. The &#39;Privileged&#39; profile is the most permissive and explicitly allows privileged containers. &#39;Host Access&#39; is not a recognized Pod Security Standard profile.",
      "analogy": "Think of Pod Security Standards like security checkpoints at an airport. The &#39;Privileged&#39; profile is like having no checkpoint at all. The &#39;Baseline&#39; profile is like a basic metal detector and bag scan. The &#39;Restricted&#39; profile is like a full body scanner, pat-down, and thorough inspection, explicitly disallowing anything that could be a threat, like a privileged container."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: privileged-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      privileged: true",
        "context": "Example Pod manifest with privileged container setting"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "KUBERNETES_BASICS",
      "POD_SECURITY_STANDARDS",
      "CONTAINER_SECURITY_CONTEXTS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from performing actions that require elevated privileges, such as modifying host system settings or loading kernel modules?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete understanding of &#39;privileged&#39;: Students often think &#39;privileged: false&#39; removes all dangerous capabilities, but it only prevents full root access to the host, leaving default capabilities intact."
      },
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets confusion between initial privilege and escalation: Students confuse preventing initial elevated privileges with preventing a process from gaining *more* privileges than it started with. This setting doesn&#39;t prevent a container from starting with dangerous capabilities."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets user vs. capability confusion: Students confuse running as a non-root user with restricting kernel capabilities. A non-root user can still exploit dangerous capabilities if they are granted to the container."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `capabilities.drop: [&quot;ALL&quot;]` setting explicitly removes all Linux capabilities from a container. Capabilities are granular permissions that allow a process to perform specific privileged operations without granting full root access. By dropping all capabilities, you prevent the container from performing actions like modifying network interfaces (CAP_NET_ADMIN), loading kernel modules (CAP_SYS_MODULE), or performing system administration tasks (CAP_SYS_ADMIN), which are common vectors for container escape or host compromise.",
      "distractor_analysis": "`privileged: false` is the default and prevents the container from having full root access to the host, but it still allows a default set of capabilities that can be exploited. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent process, but it doesn&#39;t remove any capabilities the container starts with. `runAsNonRoot: true` ensures the container runs as a non-root user, which is good practice, but a non-root user can still leverage granted capabilities to perform privileged actions.",
      "analogy": "Think of Linux capabilities as individual keys to specific locked doors on a ship. `capabilities.drop: [&quot;ALL&quot;]` is like taking away all the keys. `privileged: false` is like not giving the captain&#39;s master key, but still leaving some individual keys. `allowPrivilegeEscalation: false` is like preventing a crew member from finding new keys, but they still have the ones they started with. `runAsNonRoot: true` is like making sure the crew member isn&#39;t the captain, but they might still have dangerous keys."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: restricted-pod\nspec:\n  containers:\n  - name: my-container\n    image: nginx\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Pod manifest demonstrating how to drop all capabilities for a container, combined with other hardening measures."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "A Kubernetes application processes user-submitted HTML content, which is then displayed to other users. Which security control is most effective at preventing stored Cross-Site Scripting (XSS) attacks in this scenario?",
    "correct_answer": "Implementing strict input validation and output encoding for all user-supplied data before rendering it in the UI.",
    "distractors": [
      {
        "question_text": "Applying a NetworkPolicy to restrict egress traffic from the application pod to only trusted domains.",
        "misconception": "Targets control plane confusion: Students confuse network-level controls with application-level vulnerabilities; NetworkPolicies limit network blast radius but do not prevent the injection of malicious scripts into the application&#39;s UI."
      },
      {
        "question_text": "Setting `readOnlyRootFilesystem: true` in the pod&#39;s security context to prevent modification of application binaries.",
        "misconception": "Targets scope misunderstanding: Students conflate filesystem integrity with application logic vulnerabilities; `readOnlyRootFilesystem` prevents changes to the container&#39;s filesystem but does not address how the application processes and renders user input."
      },
      {
        "question_text": "Configuring an RBAC Role that only grants &#39;get&#39; and &#39;list&#39; permissions to the application&#39;s ServiceAccount.",
        "misconception": "Targets domain mismatch: Students confuse authorization controls with application input handling; RBAC manages what the application can do within Kubernetes, not how it securely handles user data within its own logic."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Stored XSS occurs when malicious script is permanently saved on the target server (e.g., in a database) and then delivered to other users without proper sanitization. The most effective prevention is at the application layer: strictly validating all user input to ensure it conforms to expected formats and encoding all output before rendering it in the user interface. This neutralizes any embedded scripts, preventing them from executing in the victim&#39;s browser.",
      "distractor_analysis": "NetworkPolicies restrict network communication but do not prevent malicious scripts from being stored or executed within the browser. `readOnlyRootFilesystem: true` protects the container&#39;s filesystem but doesn&#39;t address how the application handles user input. RBAC controls the application&#39;s permissions within the Kubernetes cluster, not its internal logic for processing and displaying user data.",
      "analogy": "Imagine a post office (the application) that accepts letters (user input) and displays them on a public bulletin board (the UI). Input validation and output encoding are like checking each letter for hidden dangerous messages and then translating them into a safe, display-only format before pinning them up, ensuring no one can trick others by posting a &#39;bomb threat&#39; that actually detonates."
    },
    "code_snippets": [
      {
        "language": "go",
        "code": "import (\n\t&quot;html/template&quot;\n\t&quot;net/http&quot;\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tuserInput := r.URL.Query().Get(&quot;comment&quot;)\n\n\t// Simulate storing and retrieving user input\n\t// In a real app, this would come from a database\n\tstoredContent := &quot;&lt;p&gt;User comment: &quot; + userInput + &quot;&lt;/p&gt;&quot;\n\n\t// CORRECT: Use html/template to automatically escape output\n\ttmpl, _ := template.New(&quot;page&quot;).Parse(&quot;&lt;html&gt;&lt;body&gt;{{.Content}}&lt;/body&gt;&lt;/html&gt;&quot;)\n\ttmpl.Execute(w, map[string]template.HTML{&quot;Content&quot;: template.HTML(storedContent)})\n\n\t// INCORRECT (Vulnerable to XSS if userInput contains script tags):\n\t// fmt.Fprintf(w, &quot;&lt;html&gt;&lt;body&gt;%s&lt;/body&gt;&lt;/html&gt;&quot;, storedContent)\n}",
        "context": "Go example demonstrating output encoding using `html/template` to prevent XSS. The `template.HTML` type indicates that the content is already safe, but if `userInput` were directly inserted without `template.HTML`, it would be escaped."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "WEB_APPLICATION_SECURITY",
      "CROSS_SITE_SCRIPTING",
      "KUBERNETES_BASICS"
    ]
  },
  {
    "question_text": "A containerized web application processes user input from query strings and posted parameters, then uses this data to construct file paths for local storage. Which security context setting is most effective at preventing a container escape via path traversal vulnerabilities exploiting this interaction?",
    "correct_answer": "readOnlyRootFilesystem: true combined with a dedicated PersistentVolume for legitimate writes",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope misunderstanding: Students confuse privilege escalation prevention with filesystem access control; allowPrivilegeEscalation prevents gaining new privileges, not restricting file system writes."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets incomplete mitigation: While good practice, runAsNonRoot prevents running as UID 0 but does not prevent a non-root user from writing to arbitrary locations if the filesystem is writable and path traversal is possible."
      },
      {
        "question_text": "seccompProfile: RuntimeDefault",
        "misconception": "Targets partial protection: RuntimeDefault seccomp provides a baseline of syscall restrictions but might not specifically block all syscalls necessary for arbitrary file writes or path traversal if the application logic is flawed."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Path traversal vulnerabilities allow an attacker to access files and directories outside of the intended directory by manipulating file paths. By setting `readOnlyRootFilesystem: true`, the container&#39;s root filesystem becomes immutable, preventing any unauthorized writes to critical system files. Legitimate write operations, such as storing user uploads, should be directed to a dedicated PersistentVolume, which can be mounted at a specific, controlled path within the container. This combination ensures that even if a path traversal vulnerability exists, the attacker cannot write to sensitive host paths or critical application directories.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t restrict file system write access. `runAsNonRoot: true` ensures the container doesn&#39;t run as the root user, which is good for least privilege, but a non-root user can still exploit path traversal if the filesystem is writable. `seccompProfile: RuntimeDefault` provides a default set of syscall restrictions, but it&#39;s not guaranteed to prevent all forms of path traversal exploitation, especially if the application itself is performing the file operations within its allowed syscalls.",
      "analogy": "Imagine a secure vault (container). `readOnlyRootFilesystem: true` is like making the vault&#39;s walls impenetrable to writing. Any legitimate items (user data) must be placed in a specific, designated safe deposit box (PersistentVolume) inside the vault, not directly on the walls or floor. `allowPrivilegeEscalation: false` is like preventing a guard from getting a higher-level key, and `runAsNonRoot: true` is like ensuring the guard isn&#39;t the vault&#39;s master administrator. `seccompProfile: RuntimeDefault` is like giving the guard a standard set of tools, but not specifically preventing them from trying to write on the walls if they could."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: web-app-secure\nspec:\n  containers:\n  - name: web-app\n    image: my-web-app:v1.0\n    securityContext:\n      readOnlyRootFilesystem: true\n    volumeMounts:\n    - name: data-volume\n      mountPath: /app/data\n  volumes:\n  - name: data-volume\n    persistentVolumeClaim:\n      claimName: web-app-data-pvc",
        "context": "Pod definition demonstrating readOnlyRootFilesystem and a dedicated volume for writes."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_VULNERABILITIES",
      "PATH_TRAVERSAL",
      "KUBERNETES_VOLUMES"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from loading arbitrary kernel modules, a common technique for container escape or privilege escalation?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete mitigation: Students might think setting &#39;privileged: false&#39; removes all dangerous capabilities, but it only prevents the container from running with *all* host capabilities. Many default capabilities (like CAP_SYS_MODULE) are still present and can be exploited."
      },
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope confusion: Students confuse preventing privilege escalation *within* the container with preventing the initial dangerous capabilities. This setting prevents a process from gaining more privileges than its parent, but doesn&#39;t remove the initial set of capabilities."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets irrelevant control: Students might associate &#39;root&#39; with &#39;kernel&#39; and think a read-only root filesystem prevents kernel module loading. However, this only prevents writing to the container&#39;s root filesystem, not interacting with the kernel via capabilities."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Loading kernel modules typically requires the `CAP_SYS_MODULE` capability. By dropping all capabilities (`capabilities.drop: [&quot;ALL&quot;]`), this specific capability, along with all other potentially dangerous capabilities, is removed from the container&#39;s process. This significantly reduces the attack surface for container escapes and privilege escalations that rely on kernel interactions.",
      "distractor_analysis": "`privileged: false` is a good practice but does not drop all capabilities; containers still run with a default set that includes `CAP_SYS_MODULE`. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t remove the initial capabilities that might already be present. `readOnlyRootFilesystem: true` prevents modifications to the container&#39;s root filesystem but does not restrict kernel interactions via capabilities.",
      "analogy": "Imagine a security guard (container) who is given a set of tools (capabilities). Dropping all capabilities is like taking away all tools, including the master key (CAP_SYS_MODULE) that could unlock restricted areas (kernel modules). Setting `privileged: false` is like giving them a standard toolkit, not the master toolkit, but they still have some dangerous tools. `allowPrivilegeEscalation: false` is like preventing them from asking for more tools, but they still have what they started with. `readOnlyRootFilesystem: true` is like making sure their toolbox itself is locked, but not preventing them from using the tools they already have."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true",
        "context": "Kubernetes Pod manifest demonstrating how to drop all capabilities to enhance security."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "A containerized web application is found to be vulnerable to SQL Injection, a common OWASP Top 10 risk. Which Kubernetes NetworkPolicy configuration would best limit the blast radius if this vulnerability were exploited to gain unauthorized database access?",
    "correct_answer": "Egress NetworkPolicy denying all outbound traffic from the web application pod, except to the specific database service port and IP.",
    "distractors": [
      {
        "question_text": "Ingress NetworkPolicy allowing only traffic from the load balancer to the web application pod.",
        "misconception": "Targets scope misunderstanding: An Ingress policy protects the web app from external attacks but does not limit what the compromised web app can do outbound after exploitation."
      },
      {
        "question_text": "Egress NetworkPolicy allowing all outbound traffic from the web application pod to any internal service.",
        "misconception": "Targets over-permissioning: This policy is too permissive and would allow the compromised web app to connect to other internal services, expanding the blast radius beyond the database."
      },
      {
        "question_text": "Applying a Pod Security Standard (PSS) Restricted profile to the web application pod.",
        "misconception": "Targets control plane confusion: PSS controls container runtime behavior (e.g., capabilities, root user) and does not directly manage network traffic flow between pods or to external services."
      }
    ],
    "detailed_explanation": {
      "core_logic": "SQL Injection allows an attacker to execute arbitrary database commands. If the web application container is compromised, the attacker might try to pivot to other internal systems. An Egress NetworkPolicy specifically restricts outbound connections from the compromised pod. By allowing egress only to the necessary database service on its specific port and IP, any attempt by the attacker to connect to other internal hosts (e.g., other microservices, internal C2 servers) would be blocked, effectively limiting the &#39;blast radius&#39; of the compromise.",
      "distractor_analysis": "An Ingress NetworkPolicy protects the web application from incoming connections but does nothing to prevent a compromised application from making unauthorized outbound connections. An Egress NetworkPolicy allowing all internal traffic is too broad and defeats the purpose of limiting the blast radius. Pod Security Standards (PSS) focus on container runtime security (e.g., preventing root execution, dropping capabilities) and do not directly control network traffic flow, which is the domain of NetworkPolicies.",
      "analogy": "Imagine a bank vault (the database) and a teller (the web application). If a teller is compromised, an Ingress policy is like securing the bank&#39;s front door. An Egress policy is like ensuring the compromised teller can only access the vault and cannot call other bank branches or external contacts. Allowing all internal traffic is like letting the compromised teller access any department. PSS is like checking the teller&#39;s background and tools before they start work, not what they do during a breach."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: web-app-egress-to-db\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: web-app\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              app: database\n      ports:\n        - protocol: TCP\n          port: 5432 # Example PostgreSQL port",
        "context": "Kubernetes NetworkPolicy to restrict egress from a web application pod to only its database service."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "OWASP_TOP_10",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "A containerized web application is found to be using an outdated JavaScript library with known critical vulnerabilities. Which image scanning technique is most effective at detecting this specific type of vulnerability?",
    "correct_answer": "Software Composition Analysis (SCA)",
    "distractors": [
      {
        "question_text": "Static Application Security Testing (SAST)",
        "misconception": "Targets scope confusion: SAST analyzes proprietary code for vulnerabilities, but not third-party libraries or their known CVEs, which is a common misunderstanding."
      },
      {
        "question_text": "Dynamic Application Security Testing (DAST)",
        "misconception": "Targets methodology confusion: DAST tests running applications for vulnerabilities by interacting with them, but it&#39;s less effective at identifying specific outdated library versions and their associated CVEs without prior knowledge."
      },
      {
        "question_text": "Container Runtime Security",
        "misconception": "Targets control plane confusion: Container Runtime Security focuses on detecting malicious behavior during execution, not on identifying vulnerabilities in the image&#39;s software components before deployment."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Software Composition Analysis (SCA) tools are specifically designed to identify and inventory open-source and third-party components within an application or container image. They then compare these components against vulnerability databases (like CVEs) to detect known security flaws, such as those in outdated JavaScript libraries. Retire.js is an example of a tool that performs this function for JavaScript.",
      "distractor_analysis": "SAST analyzes source code for vulnerabilities but typically focuses on the application&#39;s own code, not the dependencies. DAST tests a running application for vulnerabilities by sending inputs and observing outputs, which might find symptoms of a vulnerable library but isn&#39;t the primary method for identifying the library itself. Container Runtime Security monitors container behavior during execution for anomalies or attacks, not for pre-existing vulnerabilities in the image&#39;s components.",
      "analogy": "Think of SCA as a librarian who checks every book (library) in your personal collection (application) against a list of banned or damaged books (vulnerability database). SAST is like a grammar checker for your own writing, and DAST is like having someone try to break into your house after it&#39;s built."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "CONTAINER_IMAGE_SCANNING",
      "VULNERABILITY_MANAGEMENT",
      "WEB_APPLICATION_SECURITY"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a containerized IoT application from gaining elevated privileges on the host, specifically by blocking the use of dangerous Linux capabilities like `CAP_SYS_ADMIN`?",
    "correct_answer": "securityContext.capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "securityContext.allowPrivilegeEscalation: false",
        "misconception": "Targets partial understanding: Students might think preventing privilege escalation is sufficient, but it only prevents a process from gaining *more* privileges than its parent; it doesn&#39;t remove existing dangerous capabilities like CAP_SYS_ADMIN if they were initially granted."
      },
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets scope confusion: Students confuse running as a non-root user with capability management. While good practice, runAsNonRoot prevents UID 0 execution but doesn&#39;t directly remove Linux capabilities from a non-root user if they were assigned."
      },
      {
        "question_text": "securityContext.privileged: false",
        "misconception": "Targets incomplete mitigation: Students might believe setting privileged: false is enough. While it&#39;s a critical step, it only prevents the container from running in privileged mode (which grants all capabilities); it doesn&#39;t explicitly drop specific dangerous capabilities if the container is not privileged but still has some capabilities by default."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `securityContext.capabilities.drop: [&quot;ALL&quot;]` setting explicitly removes all Linux capabilities from the container. This is the most effective way to prevent a containerized IoT application from exploiting dangerous capabilities like `CAP_SYS_ADMIN` to gain elevated privileges or escape to the host. By default, containers are granted a set of capabilities, and dropping all of them ensures a minimal attack surface.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t remove capabilities already present. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, but a non-root user can still exploit dangerous capabilities if they are present. `privileged: false` prevents the container from running in privileged mode (which grants all capabilities), but even non-privileged containers can have a default set of capabilities that includes potentially dangerous ones, which `drop: [&quot;ALL&quot;]` explicitly removes.",
      "analogy": "Imagine a security guard (container) who is given a set of tools (capabilities). `drop: [&quot;ALL&quot;]` is like taking away all the tools, ensuring they can&#39;t use a master key (`CAP_SYS_ADMIN`). `allowPrivilegeEscalation: false` is like preventing them from finding *new* tools. `runAsNonRoot: true` is like making sure they&#39;re not the chief of security. `privileged: false` is like not giving them the &#39;all-access&#39; badge, but they might still have a few dangerous tools in their pocket."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: iot-app\nspec:\n  containers:\n  - name: iot-device-controller\n    image: my-iot-app:v1.0\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating securityContext settings to drop all capabilities for an IoT application container."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "A containerized web application is deployed in Kubernetes. It processes sensitive user data and needs to communicate with a backend database in the same cluster. Which network policy configuration would best restrict its outbound traffic to only the database, following the principle of least privilege?",
    "correct_answer": "An Egress NetworkPolicy that allows traffic only to pods with the database label in the same namespace.",
    "distractors": [
      {
        "question_text": "An Ingress NetworkPolicy that allows traffic only from the web application pod.",
        "misconception": "Targets scope confusion: Students confuse Ingress (inbound) with Egress (outbound) traffic. An Ingress policy would not control the web app&#39;s communication to the database."
      },
      {
        "question_text": "A NetworkPolicy allowing all outbound traffic within the cluster but denying external traffic.",
        "misconception": "Targets over-permissioning: Students might think restricting external traffic is sufficient, but this policy grants excessive internal access, violating least privilege by allowing communication to any internal service, not just the database."
      },
      {
        "question_text": "No NetworkPolicy, relying on service mesh mTLS for traffic encryption and authorization.",
        "misconception": "Targets control plane confusion: Students conflate encryption/authorization (service mesh) with network segmentation (NetworkPolicy). While mTLS is good, it doesn&#39;t prevent unauthorized connections at the network layer if policies aren&#39;t in place."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To restrict outbound traffic from the web application to only the database, an Egress NetworkPolicy is required. This policy should specify the web application pod as the `podSelector` and define an `egress` rule that permits traffic only to pods matching the database&#39;s label (e.g., `app: database`) within the same namespace. This adheres to the principle of least privilege by explicitly allowing only necessary communication.",
      "distractor_analysis": "An Ingress NetworkPolicy controls incoming traffic to a pod, not outgoing traffic from it. Allowing all outbound traffic within the cluster is too permissive and violates least privilege, as the web app could connect to other unauthorized services. Relying solely on a service mesh for mTLS provides encryption and authentication but does not replace the need for network segmentation provided by NetworkPolicies to prevent unauthorized connections at the network layer.",
      "analogy": "Imagine the web application as a person in a secure room. An Egress NetworkPolicy is like a rule that says this person can only call one specific phone number (the database) and no other numbers, even within the same building. An Ingress policy would be about who can call this person, not who they can call."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: webapp-egress-to-db\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: webapp\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              app: database\n      ports:\n        - protocol: TCP\n          port: 5432 # Example database port",
        "context": "Kubernetes NetworkPolicy to restrict outbound traffic from &#39;webapp&#39; to &#39;database&#39; pods."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORKING",
      "NETWORK_POLICIES",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges beyond its initial configuration, specifically targeting the `CAP_NET_RAW` capability for network packet manipulation?",
    "correct_answer": "securityContext.capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "securityContext.allowPrivilegeEscalation: false",
        "misconception": "Targets partial prevention: Students might think this prevents all privilege gains, but it only prevents a process from gaining more privileges than its parent. It doesn&#39;t prevent a container from starting with dangerous capabilities like CAP_NET_RAW if not explicitly dropped."
      },
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets user vs. capability confusion: Students confuse running as a non-root user with preventing dangerous capabilities. A non-root user can still exploit capabilities like CAP_NET_RAW if they are present."
      },
      {
        "question_text": "Pod Security Standard: Restricted",
        "misconception": "Targets policy vs. direct control: Students might think applying a standard directly configures the specific capability drop. While &#39;Restricted&#39; *would* enforce this, the question asks for the *setting* that is most effective, implying a direct configuration, not a policy that enforces it."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `securityContext.capabilities.drop: [&quot;ALL&quot;]` setting explicitly removes all Linux capabilities from the container. This is the most effective way to prevent a container from utilizing dangerous capabilities like `CAP_NET_RAW` (which allows raw socket operations, crucial for network packet manipulation and sniffing) or `CAP_SYS_ADMIN` (for host-level access). By dropping all capabilities, the container operates with the absolute minimum privileges required, significantly reducing the attack surface.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but if the container *starts* with `CAP_NET_RAW`, this setting won&#39;t remove it. `runAsNonRoot: true` ensures the container runs as a non-root user, which is good practice, but a non-root user can still leverage dangerous capabilities if they are granted to the container. The &#39;Restricted&#39; Pod Security Standard *would* enforce dropping all capabilities, but the question asks for the specific security context setting that achieves this, not the policy that mandates it.",
      "analogy": "Imagine a security guard (the container) being given a set of keys (capabilities). `drop: [&quot;ALL&quot;]` is like taking away all keys, ensuring the guard can&#39;t open any doors. `allowPrivilegeEscalation: false` is like saying the guard can&#39;t ask for *more* keys, but if they already have a master key, they still have it. `runAsNonRoot: true` is like saying the guard isn&#39;t the chief of security, but they might still have dangerous keys. The &#39;Restricted&#39; standard is like a company policy that says &#39;no guard should have any keys&#39;."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true",
        "context": "Kubernetes Pod manifest demonstrating the security context settings to drop all capabilities and prevent privilege escalation."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "A Kubernetes admission controller uses a regular expression to prevent SQL injection by stripping keywords like &#39;union&#39; and &#39;select&#39; from incoming YAML configurations. Which attack technique could bypass this filter?",
    "correct_answer": "Recursive obfuscation (e.g., &#39;uniunionon selselectect&#39;)",
    "distractors": [
      {
        "question_text": "Base64 encoding the malicious payload",
        "misconception": "Targets encoding confusion: Students might think encoding bypasses regex, but the admission controller would likely decode before processing or the regex would still match after decoding."
      },
      {
        "question_text": "Using URL encoding for special characters",
        "misconception": "Targets URL encoding misunderstanding: Similar to Base64, URL encoding changes characters but doesn&#39;t inherently bypass keyword stripping if the controller decodes or the regex isn&#39;t designed for it."
      },
      {
        "question_text": "Injecting via environment variables instead of YAML fields",
        "misconception": "Targets input vector confusion: While a valid attack vector, this doesn&#39;t bypass the *specific* regex filter on YAML content; it&#39;s a different attack path, not a bypass of the filter itself."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The technique described involves recursively embedding the &#39;bad&#39; keywords within themselves. When the filter strips out the first instance of the keyword, the remaining characters form the original keyword again, effectively bypassing the single-pass stripping mechanism. For example, if &#39;union&#39; is stripped from &#39;uniunionon&#39;, the remaining &#39;union&#39; is reconstituted.",
      "distractor_analysis": "Base64 and URL encoding would likely be decoded by the admission controller before the regex is applied, or the regex would need to be specifically designed to handle encoded input, which is less common for simple keyword stripping. Injecting via environment variables is a different attack vector entirely and does not bypass a regex filter applied to YAML configuration fields.",
      "analogy": "Imagine a censor who removes the word &#39;apple&#39; from a sentence. If you write &#39;apappleple&#39;, the censor removes the first &#39;apple&#39;, leaving &#39;apple&#39; behind. This is similar to how recursive obfuscation works against simple stripping filters."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: vulnerable-app\nspec:\n  template:\n    spec:\n      containers:\n      - name: app\n        image: vulnerable-image\n        env:\n        - name: DB_QUERY\n          value: &quot;&#39; uniunionon selselectect name, password frfromom sys.user$--&quot;",
        "context": "Example of a Kubernetes deployment manifest where a malicious SQL injection payload might be embedded, attempting to bypass a keyword-stripping admission controller."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "attack",
    "prerequisites": [
      "KUBERNETES_ADMISSION_CONTROLLERS",
      "SQL_INJECTION_BASICS",
      "REGEX_LIMITATIONS"
    ]
  },
  {
    "question_text": "A Kubernetes application is vulnerable to Cross-Site Request Forgery (CSRF) due to a lack of anti-CSRF tokens. Which security control, if misconfigured or absent, would allow an attacker to exploit this vulnerability by sending requests from a rogue domain to the vulnerable application&#39;s service?",
    "correct_answer": "Kubernetes NetworkPolicy allowing ingress from all sources to the vulnerable service",
    "distractors": [
      {
        "question_text": "Pod Security Standard (PSS) set to &#39;Privileged&#39;",
        "misconception": "Targets control plane confusion: Students might incorrectly associate PSS with network access, but PSS primarily governs pod-level security contexts and capabilities, not network ingress rules."
      },
      {
        "question_text": "RBAC ClusterRole with &#39;*&#39; verbs on &#39;pods&#39;",
        "misconception": "Targets scope misunderstanding: RBAC controls who can perform actions on Kubernetes resources, not how external network traffic reaches a service. This is a common confusion between authorization within Kubernetes and network access."
      },
      {
        "question_text": "Container image scanned with a vulnerability scanner that missed the CSRF vulnerability",
        "misconception": "Targets detection vs. prevention: While image scanning is crucial, it focuses on software vulnerabilities within the image. CSRF is an application-level logic flaw, not typically detectable by image scanners, and its exploitation relies on network access, not just the presence of the flaw."
      }
    ],
    "detailed_explanation": {
      "core_logic": "CSRF exploits rely on a victim&#39;s browser sending authenticated requests to a vulnerable application. For this to happen, the attacker&#39;s rogue site needs to be able to reach the vulnerable application&#39;s service. A misconfigured or absent Kubernetes NetworkPolicy that allows ingress traffic from all sources (or specifically from the attacker&#39;s potential egress IP ranges) to the vulnerable service would enable the HTTP requests initiated by the victim&#39;s browser from the rogue domain to reach the target application, facilitating the CSRF attack.",
      "distractor_analysis": "PSS &#39;Privileged&#39; allows a pod to run with full host access, but it does not directly control network ingress to a service from external sources. RBAC controls authorization within the Kubernetes API, determining who can manage resources, not how external network traffic flows to services. While image scanning is vital, it primarily identifies known software vulnerabilities in the container&#39;s filesystem; application-level logic flaws like CSRF are typically outside its scope, and its exploitation still requires network connectivity.",
      "analogy": "Imagine a bank vault (your application) that requires a key (session cookie) to open. CSRF is like tricking a legitimate key-holder into unknowingly opening the vault from a distance. If the bank&#39;s outer gate (NetworkPolicy) is wide open, anyone can approach the vault and try to trick the key-holder. If the gate is closed, the trick won&#39;t work because the attacker can&#39;t even get close enough to the vault."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-all-ingress\nspec:\n  podSelector:\n    matchLabels:\n      app: vulnerable-app\n  policyTypes:\n    - Ingress\n  ingress:\n    - from:\n        - ipBlock:\n            cidr: 0.0.0.0/0",
        "context": "Example of a NetworkPolicy that would allow ingress from all sources, potentially enabling CSRF exploitation if the application is vulnerable."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "attack",
    "prerequisites": [
      "KUBERNETES_NETWORKING",
      "WEB_VULNERABILITIES",
      "NETWORK_POLICY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which CSS feature, specifically in older Internet Explorer versions, poses a significant code injection risk if attacker-controlled stylesheets are allowed?",
    "correct_answer": "The proprietary `expression(...)` function",
    "distractors": [
      {
        "question_text": "The `@import` directive for external stylesheets",
        "misconception": "Targets partial understanding of CSS risks: While `@import` can load external content, the primary code injection risk in IE6 was scripting-related schemes in `url(...)` within `@import`, not the directive itself for arbitrary code execution."
      },
      {
        "question_text": "The `-moz-binding` property in Firefox",
        "misconception": "Targets browser-specific confusion: Students might confuse browser-specific features. `-moz-binding` is a Firefox-specific feature for XBL, not an IE-specific CSS function for JavaScript injection."
      },
      {
        "question_text": "Redefining mouse cursors with arbitrary bitmaps",
        "misconception": "Targets misidentification of vulnerability type: Students might focus on the &#39;security bugs&#39; mentioned. Redefining cursors leads to UI obscuring/phishing, not direct code injection via CSS."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `expression(...)` function, proprietary to Internet Explorer, allowed JavaScript statements to be directly embedded and executed within CSS rules. This created a severe code injection vulnerability, as an attacker who could control stylesheet content could execute arbitrary JavaScript code in the context of the user&#39;s browser.",
      "distractor_analysis": "The `@import` directive allows including external CSS, which can be a risk if the imported content is malicious, but it&#39;s not the direct code injection mechanism like `expression(...)`. The `-moz-binding` property is a Firefox-specific feature for XBL, not related to IE&#39;s CSS JavaScript execution. Redefining mouse cursors is a UI spoofing/phishing risk, not a direct code injection vulnerability.",
      "analogy": "Imagine a building&#39;s interior decorator (CSS) being given a special paint (expression function) that, when applied, can also run a small program (JavaScript) inside the building. If an attacker controls the decorator, they can run malicious programs. Other CSS features might allow importing dangerous furniture (malicious external CSS) or changing the appearance of signs (mouse cursors), but not directly running programs."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "attack",
    "prerequisites": [
      "WEB_APPLICATION_SECURITY",
      "CSS_FUNDAMENTALS",
      "CODE_INJECTION_VULNERABILITIES"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting prevents a container from gaining new privileges after it starts, specifically addressing potential privilege escalation via `setuid` or `setgid` binaries?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope confusion: Students confuse preventing initial root execution with preventing privilege escalation; runAsNonRoot prevents a container from starting as UID 0, but doesn&#39;t stop it from escalating privileges if it starts as a non-root user and has the means (e.g., CAP_SETUID)."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete understanding of &#39;privileged&#39;: Students believe setting privileged: false is sufficient to prevent all forms of privilege escalation, but it only prevents the container from running with all capabilities and direct host access, not specific `setuid`/`setgid` escalations within its existing capabilities."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets irrelevant control: Students might associate &#39;root&#39; in the setting name with &#39;root user&#39; and think it prevents privilege escalation, but it only makes the container&#39;s root filesystem immutable, which doesn&#39;t directly prevent privilege escalation through `setuid` binaries if they are already present and executable."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting prevents a process in a container from gaining more privileges than its parent process. Specifically, it ensures that the `no_new_privs` flag is set on the container process, which prevents `setuid` and `setgid` binaries from granting additional privileges. This is a crucial control for preventing privilege escalation attacks within a container.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container does not start as the root user, but it doesn&#39;t prevent a non-root user from escalating privileges if allowed. `privileged: false` removes broad host access but doesn&#39;t specifically target `setuid`/`setgid` escalation. `readOnlyRootFilesystem: true` prevents writing to the root filesystem but doesn&#39;t stop existing `setuid` binaries from being executed.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re inside the building, you can&#39;t get a higher-level access card than the one you entered with.&#39; Even if there are higher-level cards lying around (like `setuid` binaries), you&#39;re prevented from picking them up and using them."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: no-priv-escalation-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      runAsUser: 1000",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` within a security context."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_PRIVILEGE_ESCALATION",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "A containerized Firefox application is found to be processing XUL documents from untrusted internet sources. Which security context setting would be most effective in preventing potential container escapes or privilege escalation attempts originating from XUL&#39;s JavaScript capabilities?",
    "correct_answer": "securityContext.allowPrivilegeEscalation: false and securityContext.capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "securityContext.readOnlyRootFilesystem: true",
        "misconception": "Targets scope misunderstanding: Students might think making the filesystem read-only prevents all attacks, but it doesn&#39;t stop in-memory exploits or privilege escalation if capabilities are present."
      },
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets partial solution bias: While good practice, runAsNonRoot prevents running as UID 0 but doesn&#39;t prevent a non-root user from exploiting capabilities or privilege escalation if allowed."
      },
      {
        "question_text": "NetworkPolicy to restrict egress traffic",
        "misconception": "Targets control plane confusion: Students confuse network controls with container runtime security. NetworkPolicy limits communication but does not prevent an already compromised container from escalating privileges internally."
      }
    ],
    "detailed_explanation": {
      "core_logic": "XUL documents, like HTML, can execute JavaScript, which is a common vector for exploits. To prevent a container escape or privilege escalation from such an exploit, it&#39;s crucial to remove any capabilities that could be abused (e.g., CAP_SYS_ADMIN) by dropping all capabilities. Additionally, `allowPrivilegeEscalation: false` prevents the container process from gaining more privileges than its parent, which is a critical defense against many privilege escalation techniques, especially when combined with capability dropping.",
      "distractor_analysis": "`readOnlyRootFilesystem: true` prevents writing to the container&#39;s root filesystem but doesn&#39;t stop in-memory exploits or privilege escalation if the process has dangerous capabilities. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, but a non-root user with certain capabilities can still perform dangerous actions. A `NetworkPolicy` restricts network communication but does not address the internal security posture of the container or prevent an escape if an exploit is successful.",
      "analogy": "Imagine a secure room (the container) with a window (XUL processing). Dropping all capabilities is like removing all tools that could break the window or open the door. `allowPrivilegeEscalation: false` is like ensuring no one inside the room can find new tools to break out. `readOnlyRootFilesystem` is like making the walls ungraffiti-able, which is good but doesn&#39;t stop someone from breaking out if they have the right tools."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: firefox-xul-app\nspec:\n  containers:\n  - name: firefox\n    image: my-firefox-image:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true\n      runAsUser: 1000\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating security context settings to mitigate XUL-based exploits."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting prevents a container from gaining new privileges after it starts, effectively mitigating a common step in container escape attempts?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope confusion: Students confuse preventing initial root execution with preventing privilege escalation; runAsNonRoot prevents a container from starting as UID 0, but doesn&#39;t stop it from escalating privileges if it starts as a non-root user with certain capabilities."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete understanding: Students might think disabling &#39;privileged&#39; mode is sufficient, but a non-privileged container can still escalate privileges if it retains certain capabilities or if allowPrivilegeEscalation is true."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets irrelevant control: Students might associate &#39;root&#39; in the setting name with root privileges, but this only makes the container&#39;s root filesystem immutable, which doesn&#39;t directly prevent privilege escalation within the container."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` security context setting prevents a process from gaining more privileges than its parent process. Specifically, it prevents the `setuid` and `setgid` bits from being honored and prevents a process from executing a binary with elevated privileges. This is a critical control against container escape, as many escape techniques rely on escalating privileges within the container to then access the host.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container does not run as UID 0 initially, but doesn&#39;t prevent a non-root user from escalating privileges if allowed. `privileged: false` removes broad access to host devices and capabilities but doesn&#39;t specifically block privilege escalation if the container still has capabilities like `CAP_SETUID` or `CAP_SETGID`. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which is good for integrity but doesn&#39;t directly stop privilege escalation within the container&#39;s process space.",
      "analogy": "Imagine `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re inside this room, you can&#39;t pick up any special tools that would let you open other locked doors.&#39; `runAsNonRoot: true` is like saying &#39;only people without master keys can enter this room initially.&#39;"
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: no-priv-escalation-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-secure-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false` in conjunction with dropping all capabilities for defense in depth."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "A Kubernetes Pod runs a web application that is vulnerable to SQL Injection. Which NetworkPolicy configuration would best limit the blast radius if the application&#39;s database credentials were compromised?",
    "correct_answer": "Egress NetworkPolicy allowing traffic only to the specific database service IP and port, and denying all other egress.",
    "distractors": [
      {
        "question_text": "Ingress NetworkPolicy allowing traffic only from the web application&#39;s frontend service.",
        "misconception": "Targets scope confusion: Students might confuse ingress (inbound) with egress (outbound) traffic. While important for protecting the web app, it doesn&#39;t limit the blast radius of a compromised database connection."
      },
      {
        "question_text": "Egress NetworkPolicy allowing traffic to all internal services within the same namespace.",
        "misconception": "Targets over-permissioning: Students might think &#39;internal&#39; is secure enough. This still grants excessive access to other services in the namespace, violating the principle of least privilege for a compromised pod."
      },
      {
        "question_text": "No NetworkPolicy, relying on Kubernetes service accounts and RBAC for security.",
        "misconception": "Targets control plane confusion: Students might conflate RBAC (authorization for Kubernetes API) and service accounts (pod identity) with network segmentation. These do not restrict network traffic between pods or to external resources."
      }
    ],
    "detailed_explanation": {
      "core_logic": "If a web application&#39;s database credentials are compromised via SQL Injection, an attacker could use the compromised pod to initiate connections to other internal or external systems. An Egress NetworkPolicy that explicitly permits outbound traffic ONLY to the known database service IP and port, and implicitly denies all other egress, prevents the compromised pod from being used for lateral movement, data exfiltration to arbitrary external IPs, or attacking other internal services.",
      "distractor_analysis": "An Ingress NetworkPolicy protects the web application from external attacks but does not limit what the compromised application can do outbound. Allowing egress to all internal services is too broad and would still permit lateral movement within the cluster. Relying solely on service accounts and RBAC is insufficient; these control access to the Kubernetes API, not network traffic between pods or to external networks.",
      "analogy": "Imagine a bank teller (the web application) whose keys to the vault (database credentials) are stolen. An Egress NetworkPolicy is like a physical barrier that only allows the teller to go directly to the vault and nowhere else in the bank, preventing them from accessing other offices or leaving the building with the stolen keys."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: db-egress-policy\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: web-app\n  policyTypes:\n  - Egress\n  egress:\n  - to:\n    - ipBlock:\n        cidr: 10.0.0.4/32 # Specific IP of the database service\n    ports:\n    - protocol: TCP\n      port: 5432 # Database port (e.g., PostgreSQL)",
        "context": "Kubernetes NetworkPolicy to restrict egress traffic from a web application pod to only its database."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "SQL_INJECTION_CONCEPTS",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "A Kubernetes deployment is configured with a container that processes user-submitted SQL queries. To prevent SQL injection attacks that could lead to unauthorized data modification via `UPDATE` statements, which security context setting is most effective in limiting the container&#39;s ability to execute arbitrary commands on the host, even if the application layer is compromised?",
    "correct_answer": "seccompProfile: type: RuntimeDefault",
    "distractors": [
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets scope misunderstanding: Students might think making the filesystem read-only prevents all forms of data modification, but SQL injection targets the database, not the container&#39;s local filesystem. This prevents writing to the container&#39;s root filesystem, not arbitrary command execution or database manipulation."
      },
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets control plane confusion: While important for general security, `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent. It does not directly prevent the execution of arbitrary SQL commands or limit syscalls that could be abused by an already compromised process within its current privilege level."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets privilege level confusion: `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0. While good practice, a non-root user can still execute arbitrary SQL commands if the application is vulnerable and can still perform many system calls that could be exploited for host compromise, especially if other controls are missing."
      }
    ],
    "detailed_explanation": {
      "core_logic": "SQL injection is an application-layer vulnerability. While security contexts don&#39;t directly prevent the injection itself, `seccompProfile: type: RuntimeDefault` is the most effective setting among the choices to limit the *impact* of a successful injection that attempts to escalate privileges or execute arbitrary commands on the host. Seccomp (Secure Computing Mode) filters system calls, preventing the container from making dangerous calls to the kernel that could lead to container escape or host compromise, even if the application process is compromised and tries to execute commands beyond its intended scope. This acts as a defense-in-depth mechanism.",
      "distractor_analysis": "`readOnlyRootFilesystem: true` prevents writing to the container&#39;s root filesystem, but SQL injection targets the database, which is typically external or mounted, and doesn&#39;t prevent arbitrary command execution via syscalls. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, which is good, but doesn&#39;t restrict the syscalls available at the current privilege level. `runAsNonRoot: true` ensures the container runs as a non-root user, which is a best practice, but a non-root user can still execute many system calls that could be exploited if seccomp is not applied.",
      "analogy": "Think of `seccompProfile: type: RuntimeDefault` as a bouncer at a club who only allows certain types of actions (syscalls) inside, regardless of who you are (root or non-root) or whether you try to sneak in extra privileges. Even if someone manages to trick the bartender (SQL injection), the bouncer still limits what they can do inside the club."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: vulnerable-app\nspec:\n  selector:\n    matchLabels:\n      app: vulnerable-app\n  template:\n    metadata:\n      labels:\n        app: vulnerable-app\n    spec:\n      containers:\n      - name: app-container\n        image: vulnerable-image:latest\n        securityContext:\n          seccompProfile:\n            type: RuntimeDefault\n        ports:\n        - containerPort: 8080",
        "context": "Kubernetes Deployment manifest applying a default seccomp profile to a container."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_SECCOMP",
      "SQL_INJECTION_BASICS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges by exploiting a vulnerability that requires new capabilities, such as CAP_NET_RAW for network sniffing?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing root execution with preventing privilege escalation. runAsNonRoot prevents the container from starting as UID 0 but doesn&#39;t stop a non-root user from escalating privileges if allowed."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students think filesystem immutability prevents privilege escalation. While good for integrity, it doesn&#39;t directly prevent a process from acquiring new capabilities or escalating privileges within its allowed scope."
      },
      {
        "question_text": "capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets incomplete understanding of interaction: While dropping ALL capabilities is highly effective, allowPrivilegeEscalation: false specifically prevents a process from gaining *new* capabilities, which is the direct mechanism for privilege escalation in this scenario. Dropping ALL is a broader, more restrictive measure, but allowPrivilegeEscalation directly addresses the &#39;gaining&#39; aspect."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting prevents a process from gaining more privileges than its parent process. Specifically, it ensures that a process cannot set the `setuid` or `setgid` bits, nor can it execute a binary with elevated capabilities. This directly mitigates attacks where a container attempts to acquire new capabilities (like CAP_NET_RAW) to perform privileged actions, even if it&#39;s not running as root.",
      "distractor_analysis": "`runAsNonRoot: true` prevents the container from running as UID 0, but a non-root user can still escalate privileges if `allowPrivilegeEscalation` is true and a vulnerability exists. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which is good for integrity but doesn&#39;t prevent a process from gaining new capabilities. `capabilities.drop: [&quot;ALL&quot;]` is a very strong control that removes all capabilities, but `allowPrivilegeEscalation: false` specifically targets the *gaining* of new privileges, which is the direct mechanism for the described attack. While dropping all capabilities would also prevent this, `allowPrivilegeEscalation: false` is the most direct answer to preventing the *gaining* of new capabilities.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a security guard at a club entrance who prevents anyone from getting a VIP pass once they&#39;re inside, regardless of their initial entry status. `runAsNonRoot: true` is like only allowing non-VIPs to enter the club in the first place. `readOnlyRootFilesystem: true` is like making sure the club&#39;s furniture can&#39;t be changed. `capabilities.drop: [&quot;ALL&quot;]` is like not giving anyone any special passes at all, which is more restrictive but `allowPrivilegeEscalation: false` directly addresses the &#39;gaining&#39; of a new pass."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      # Optional: Combine with dropping capabilities for stronger defense\n      # capabilities:\n      #   drop: [&quot;ALL&quot;]\n",
        "context": "Kubernetes Pod manifest demonstrating `allowPrivilegeEscalation: false`"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "PRIVILEGE_ESCALATION_CONCEPTS"
    ]
  },
  {
    "question_text": "A Kubernetes Pod is configured with `privileged: true`. Which Pod Security Standard (PSS) profile would explicitly prevent this configuration from being deployed?",
    "correct_answer": "Restricted",
    "distractors": [
      {
        "question_text": "Baseline",
        "misconception": "Targets partial understanding of PSS: Students might think Baseline is strict enough, but it allows privileged containers, focusing more on preventing hostPath mounts and specific capabilities."
      },
      {
        "question_text": "Privileged",
        "misconception": "Targets confusion with profile name: Students might incorrectly associate the &#39;Privileged&#39; profile with preventing privileged containers, when in fact it allows all capabilities and settings."
      },
      {
        "question_text": "Namespace-level Pod Security Admission (PSA) with `warn` mode",
        "misconception": "Targets misunderstanding of PSA enforcement: Students confuse warning with prevention; `warn` mode allows deployment but logs a warning, it does not block the pod."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `privileged: true` setting grants a container all capabilities on the host, effectively giving it root access to the node. The Restricted Pod Security Standard profile explicitly disallows privileged containers, along with other settings that could lead to privilege escalation or container escape. Deploying a pod with `privileged: true` would violate the Restricted profile and be blocked if the cluster&#39;s Pod Security Admission controller is enforcing this profile.",
      "distractor_analysis": "The Baseline profile allows privileged containers, so it would not prevent this deployment. The Privileged profile explicitly allows all capabilities and settings, including `privileged: true`. Namespace-level Pod Security Admission with `warn` mode would allow the pod to be deployed, only issuing a warning, not blocking it.",
      "analogy": "Think of the Pod Security Standards like security checkpoints at an airport. The &#39;Restricted&#39; profile is like a full body scan and strict baggage check, disallowing anything potentially dangerous. The &#39;Baseline&#39; is a less strict check, allowing some items. The &#39;Privileged&#39; profile is like having no security check at all."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: privileged-pod\nspec:\n  containers:\n  - name: my-container\n    image: busybox\n    command: [&quot;sleep&quot;, &quot;3600&quot;]\n    securityContext:\n      privileged: true",
        "context": "Example Pod manifest that would be blocked by the Restricted PSS profile due to `privileged: true`."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_POD_SECURITY_STANDARDS",
      "KUBERNETES_SECURITY_CONTEXTS"
    ]
  },
  {
    "question_text": "A containerized web application is vulnerable to SQL injection. After successfully exploiting the vulnerability and gaining access to the application&#39;s database account, a cybersecurity professional wants to prevent further lateral movement or host compromise from the database container. Which Kubernetes NetworkPolicy configuration would best limit the blast radius of this compromised database container?",
    "correct_answer": "A NetworkPolicy that denies all egress traffic from the database container except to the application container and denies all ingress traffic except from the application container.",
    "distractors": [
      {
        "question_text": "A NetworkPolicy that denies all ingress traffic to the database container except from the application container, but allows all egress traffic.",
        "misconception": "Targets incomplete egress control: Students might focus only on ingress to protect the database, overlooking the critical need to restrict outbound connections for preventing lateral movement and data exfiltration."
      },
      {
        "question_text": "A NetworkPolicy that allows all ingress and egress traffic within the same namespace as the database container.",
        "misconception": "Targets scope misunderstanding: Students might believe namespace-level allowance is sufficient, failing to realize that this still permits connections to other potentially vulnerable services within the same namespace and allows unrestricted outbound connections."
      },
      {
        "question_text": "A NetworkPolicy that denies all ingress and egress traffic to and from the database container.",
        "misconception": "Targets over-restriction: Students might choose the most restrictive option, not considering that the database container still needs to communicate with the application container to function, leading to service disruption."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The goal is to limit the blast radius of a compromised database container. This means preventing it from initiating connections to other systems (lateral movement, data exfiltration) and preventing unauthorized systems from connecting to it. By denying all egress traffic except to the specific application container it serves, we prevent the database from reaching other internal services, external networks, or the attacker&#39;s C2 server. Denying all ingress except from the application container ensures only legitimate application requests reach the database. This implements the principle of least privilege for network communication.",
      "distractor_analysis": "Allowing all egress traffic (Distractor 1) leaves the door open for an attacker to compromise the database host&#39;s OS, gain network access to other systems, or exfiltrate data. Allowing all traffic within the same namespace (Distractor 2) is too permissive; it doesn&#39;t prevent the compromised database from connecting to other services in the same namespace that it shouldn&#39;t interact with, nor does it restrict outbound connections. Denying all ingress and egress (Distractor 3) would render the database unusable as it wouldn&#39;t be able to communicate with the application, violating its operational requirements.",
      "analogy": "Imagine the database container as a secure vault. The NetworkPolicy is like a strict security guard. The correct policy allows only the authorized person (application container) to put things in (ingress) and take things out (egress) of the vault, and prevents the vault itself from sending messages or packages to anyone else (lateral movement, data exfiltration)."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: db-isolation-policy\n  namespace: my-app-namespace\nspec:\n  podSelector:\n    matchLabels:\n      app: database\n  policyTypes:\n    - Ingress\n    - Egress\n  ingress:\n    - from:\n        - podSelector:\n            matchLabels:\n              app: web-app\n      ports:\n        - protocol: TCP\n          port: 5432 # Example DB port\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              app: web-app\n      ports:\n        - protocol: TCP\n          port: 8080 # Example App port for DB to connect back if needed, or remove if not required\n    # Optionally, allow DNS resolution\n    - to:\n        - namespaceSelector: {}\n          podSelector:\n            matchLabels:\n              k8s-app: kube-dns # Or your specific DNS provider\n      ports:\n        - protocol: UDP\n          port: 53",
        "context": "Kubernetes NetworkPolicy to strictly limit ingress and egress for a database container, allowing communication only with its associated web application container and DNS."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICY",
      "CONTAINER_SECURITY_FUNDAMENTALS",
      "SQL_INJECTION_CONCEPTS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges by exploiting vulnerabilities that rely on the `CAP_NET_RAW` capability?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets partial understanding of privilege escalation: Students might think allowPrivilegeEscalation prevents all privilege gains, but it specifically prevents a process from gaining more privileges than its parent, not from using existing dangerous capabilities."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets confusion between user identity and capabilities: Students may conflate running as non-root with preventing capability-based attacks, but a non-root user can still possess and exploit dangerous capabilities."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets misunderstanding of default capabilities: Students might believe setting privileged: false removes all dangerous capabilities, but it only prevents the container from running with *all* capabilities and direct host access; many dangerous capabilities remain by default."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `CAP_NET_RAW` capability allows a process to create raw sockets, which can be used for network sniffing, spoofing, and other attacks. The most effective way to prevent a container from exploiting this or any other dangerous capability is to explicitly drop all capabilities using `capabilities.drop: [&quot;ALL&quot;]`. This ensures the container runs with the absolute minimum privileges necessary, adhering to the principle of least privilege.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t remove existing dangerous capabilities like `CAP_NET_RAW`. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, but a non-root user can still possess and exploit capabilities. `privileged: false` is a good practice, but it still leaves a default set of capabilities, some of which can be exploited.",
      "analogy": "Imagine a security guard (container) who has a master key (CAP_NET_RAW). `allowPrivilegeEscalation: false` is like telling the guard they can&#39;t get *more* keys, but they still have the master key. `runAsNonRoot: true` is like saying the guard isn&#39;t the chief of security, but they still have the master key. `privileged: false` is like taking away some of their less important keys, but they still retain the master key. `capabilities.drop: [&quot;ALL&quot;]` is like taking away *all* their keys, forcing them to request specific keys only when absolutely necessary."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-app\n    image: my-secure-image\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Pod security context demonstrating dropping all capabilities to prevent capability-based exploits."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "LINUX_CAPABILITIES",
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which characteristic of NoSQL databases, compared to traditional SQL databases, makes generalized injection attacks more challenging to develop?",
    "correct_answer": "NoSQL databases lack a single, standardized query language, with each type often having its own unique query methods.",
    "distractors": [
      {
        "question_text": "NoSQL databases primarily use key/value mappings, which inherently prevent injection.",
        "misconception": "Targets oversimplification of NoSQL security: Students might incorrectly assume that the key/value structure itself is a security feature against injection, rather than just a different data model."
      },
      {
        "question_text": "NoSQL data stores do not rely on a fixed schema, making injection attempts irrelevant.",
        "misconception": "Targets misunderstanding of schema&#39;s role in injection: Students might confuse the absence of a fixed schema with immunity to injection, whereas injection targets query logic, not just schema structure."
      },
      {
        "question_text": "NoSQL is a newer technology, and its vulnerabilities are not yet widely understood or exploited.",
        "misconception": "Targets conflation of maturity with inherent security: While true that NoSQL vulnerability research is less mature, this is a factor in *discovery* of vulnerabilities, not an inherent architectural feature that makes injection *more challenging to develop* across the board."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Unlike SQL databases, which largely share a common query language (SQL), NoSQL encompasses a diverse range of data stores, each with potentially unique query methods (e.g., key/value lookup, XPath, JavaScript). This lack of a single, standardized query language means that an injection technique developed for one NoSQL database type is unlikely to work directly on another, making generalized injection attacks difficult to craft.",
      "distractor_analysis": "While key/value mappings are a common NoSQL characteristic, they don&#39;t inherently prevent injection; the method of querying these mappings is what determines vulnerability. The absence of a fixed schema changes how data is structured but doesn&#39;t eliminate the possibility of injecting malicious input into query logic. The relative newness of NoSQL technology means fewer known vulnerabilities, but this doesn&#39;t make the *development* of generalized injection attacks inherently harder; rather, it means the attack surface is less explored and more varied.",
      "analogy": "Imagine trying to pick a lock. With SQL, it&#39;s like all houses use the same type of lock, so one set of lock-picking tools works everywhere. With NoSQL, it&#39;s like every house has a completely different, custom-made lock, so you need a unique set of tools for each one, making a &#39;universal&#39; lock-picking kit impossible."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "WEB_APPLICATION_SECURITY",
      "SQL_INJECTION_FUNDAMENTALS",
      "NOSQL_BASICS"
    ]
  },
  {
    "question_text": "An attacker has identified an XPath injection vulnerability in a web application that stores sensitive user data in an XML document. The application uses an XPath query to retrieve a user&#39;s credit card number based on provided username and password. Which security context setting in a Kubernetes Pod would be most effective in preventing the container from accessing the host&#39;s filesystem to exfiltrate this data, assuming the XML data is stored on the host?",
    "correct_answer": "readOnlyRootFilesystem: true",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets setting confusion: Students might confuse privilege escalation prevention with filesystem access control. allowPrivilegeEscalation prevents gaining additional privileges within the container, but doesn&#39;t directly restrict access to mounted host paths if the container already has permissions."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: While good practice, runAsNonRoot prevents the container from running as UID 0. If the host filesystem is mounted and accessible to a non-root user within the container, this setting alone won&#39;t prevent data exfiltration."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete mitigation: Students might think disabling privileged mode is sufficient. While privileged mode grants extensive host access, a non-privileged container can still access host paths if they are mounted and permissions allow, especially if the XML data is in a volume."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `readOnlyRootFilesystem: true` security context setting makes the container&#39;s root filesystem read-only. If the sensitive XML data is stored on the host and mounted into the container&#39;s filesystem (e.g., via a hostPath volume), making the container&#39;s filesystem read-only would prevent the attacker from writing the exfiltrated data to the host&#39;s filesystem or modifying host files, thereby hindering exfiltration attempts that rely on writing to the host. This directly addresses the scenario of preventing data exfiltration to the host&#39;s filesystem.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but doesn&#39;t restrict existing filesystem access. `runAsNonRoot: true` prevents the container from running as the root user, which is good practice, but a non-root user can still read and write to mounted host paths if permissions allow. `privileged: false` prevents the container from having full access to the host, but if a specific host path is mounted, a non-privileged container can still interact with it based on its mount options and permissions.",
      "analogy": "Imagine a secure vault (the host filesystem) with a window (the mounted volume). `readOnlyRootFilesystem: true` is like making the window one-way glass and unbreakable – you can see out (read data), but you can&#39;t throw anything back in (write data to the host) or break out to access the rest of the vault."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: vulnerable-app\nspec:\n  containers:\n  - name: webapp\n    image: vulnerable-image\n    securityContext:\n      readOnlyRootFilesystem: true\n    volumeMounts:\n    - name: host-data\n      mountPath: /app/data\n  volumes:\n  - name: host-data\n    hostPath:\n      path: /var/lib/app-data\n      type: DirectoryOrCreate",
        "context": "Kubernetes Pod definition with readOnlyRootFilesystem to prevent writing to mounted host paths."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_FILESYSTEMS",
      "XPATH_INJECTION_CONCEPTS"
    ]
  },
  {
    "question_text": "A containerized web application is vulnerable to XML External Entity (XXE) injection, allowing an attacker to read arbitrary files from the container&#39;s filesystem. Which Kubernetes security context setting, if properly configured, would prevent the container from successfully reading sensitive host files like `/etc/shadow` via XXE?",
    "correct_answer": "readOnlyRootFilesystem: true",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets setting confusion: Students might confuse privilege escalation with file system access. allowPrivilegeEscalation prevents a process from gaining more privileges than its parent, but doesn&#39;t restrict file system reads if the process already has permission."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: While good practice, runAsNonRoot prevents the container from running as UID 0. However, even a non-root user can read many system files (e.g., `/etc/passwd`, `/etc/hosts`) if the filesystem is writable or if the file permissions allow it."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete mitigation: Students might think disabling privileged mode is sufficient. While privileged containers have full host access, unprivileged containers can still read files if the filesystem is mounted read-write and permissions allow, or if other vulnerabilities exist."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `readOnlyRootFilesystem: true` security context setting mounts the container&#39;s root filesystem as read-only. This means that even if an attacker successfully exploits an XXE vulnerability to specify a file path like `/etc/shadow`, the XML parser within the container will be unable to read its contents because the underlying filesystem is immutable. This directly prevents data exfiltration via file read operations.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but doesn&#39;t restrict existing file read capabilities. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, but many sensitive files are readable by non-root users, and this setting doesn&#39;t make the filesystem read-only. `privileged: false` prevents the container from having full access to the host, but an unprivileged container can still read files from its own (potentially writable) filesystem if an XXE vulnerability is present.",
      "analogy": "Imagine a library (the container&#39;s filesystem). `readOnlyRootFilesystem: true` is like locking all the books in glass cases so you can see them but not take them out. Even if someone finds a way to know which book they want (XXE path), they can&#39;t actually get the content. `runAsNonRoot` is like saying only librarians can be in charge, but they can still read books. `allowPrivilegeEscalation` is like preventing a junior librarian from becoming a senior librarian. `privileged: false` is like saying the library isn&#39;t connected to the main government archives, but you can still read books within the library."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-webapp\nspec:\n  containers:\n  - name: webapp\n    image: my-vulnerable-webapp:latest\n    securityContext:\n      readOnlyRootFilesystem: true\n      # Other good practices:\n      # runAsNonRoot: true\n      # allowPrivilegeEscalation: false\n      # capabilities:\n      #   drop: [&quot;ALL&quot;]\n",
        "context": "Kubernetes Pod definition with readOnlyRootFilesystem enabled to prevent file exfiltration via XXE."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "XXE_INJECTION",
      "CONTAINER_FILESYSTEMS"
    ]
  },
  {
    "question_text": "A containerized web application processes user input and passes it to an underlying operating system command. The developers implemented a `securityContext` to prevent command injection by escaping characters like `;`, `|`, `&amp;`, `&lt;`, `&gt;`, `&#39;`, space, and newline. Which `securityContext` setting, if misconfigured, could allow an attacker to bypass this escaping mechanism and achieve command injection?",
    "correct_answer": "The `securityContext` itself does not directly handle character escaping; this is an application-level vulnerability. The flaw described is a logic error in the application&#39;s input sanitization, specifically failing to escape the backslash character.",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: true",
        "misconception": "Targets scope confusion: Students might incorrectly associate `allowPrivilegeEscalation` with application-level input sanitization, thinking it directly influences how characters are processed, rather than its true role in preventing privilege gains within the container."
      },
      {
        "question_text": "privileged: true",
        "misconception": "Targets control plane confusion: Students might believe that running a container in `privileged` mode somehow bypasses application-level input validation, when `privileged` mode grants host access, not a mechanism to subvert application logic."
      },
      {
        "question_text": "capabilities.add: [&quot;CAP_SYS_ADMIN&quot;]",
        "misconception": "Targets capability misunderstanding: Students might think adding `CAP_SYS_ADMIN` would enable bypassing input sanitization, but capabilities relate to kernel-level permissions, not application-level string manipulation or command injection logic."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The scenario describes a classic command injection vulnerability due to insufficient input sanitization at the application layer. The `securityContext` in Kubernetes is used to define security parameters for a pod or container, such as user IDs, capabilities, SELinux contexts, and privilege escalation settings. It does not provide mechanisms for character escaping or input validation for application-level logic. The flaw is in the application&#39;s code, which failed to escape the backslash character, allowing an attacker to neutralize the intended escaping of other metacharacters.",
      "distractor_analysis": "`allowPrivilegeEscalation: true` permits a process to gain more privileges than its parent, but it doesn&#39;t directly relate to how an application sanitizes user input for shell commands. `privileged: true` grants the container all capabilities and access to host devices, but it doesn&#39;t bypass application-level input validation logic. `capabilities.add: [&quot;CAP_SYS_ADMIN&quot;]` grants extensive kernel-level privileges, but again, this is distinct from the application&#39;s logic for handling and escaping user-supplied strings before passing them to a shell.",
      "analogy": "Imagine a security gate (application&#39;s input sanitization) that checks IDs (malicious characters). The `securityContext` is like the building&#39;s overall security policy (e.g., &#39;no weapons allowed&#39;). If the gate attendant (application code) forgets to check for a specific type of fake ID (the backslash), the building&#39;s overall policy doesn&#39;t directly fix that specific gate attendant&#39;s oversight."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: vulnerable-app\nspec:\n  containers:\n  - name: webapp\n    image: vulnerable-image:latest\n    securityContext:\n      # These settings do not prevent application-level logic flaws\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      capabilities:\n        drop: [&quot;ALL&quot;]\n    env:\n    - name: COMMAND_TEMPLATE\n      value: &quot;echo User input: %s&quot;\n    # The vulnerability lies within the application code processing user input\n    # and passing it to a shell command, not in these securityContext settings.\n",
        "context": "Example Kubernetes Pod manifest. The securityContext settings shown are good practices but do not address application-level input sanitization logic flaws."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "attack",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "COMMAND_INJECTION",
      "APPLICATION_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "An e-commerce application attempts to prevent SQL injection by escaping single quotes and truncating all user input to 128 characters. An attacker crafts a username of 127 &#39;a&#39; characters followed by a single quote (`aaaaaaaa[...]aaaaaaa&#39;`). Which of the following best describes how this input can lead to a successful SQL injection?",
    "correct_answer": "The application first doubles the single quote, then truncates the string, effectively restoring the original single quote and causing a syntax error that can be exploited with a crafted password.",
    "distractors": [
      {
        "question_text": "The truncation occurs before the escaping, allowing the single quote to bypass the filter entirely.",
        "misconception": "Targets process order confusion: Students might assume truncation always happens first, but the vulnerability relies on escaping happening first, then truncation."
      },
      {
        "question_text": "The doubled single quote is interpreted as a comment, allowing the attacker to append arbitrary SQL.",
        "misconception": "Targets SQL syntax misunderstanding: Doubled single quotes are for escaping literal quotes within a string, not for comments. Comments are typically `--` or `/* */`."
      },
      {
        "question_text": "The length limit is bypassed because the escaping process adds characters, making the string longer than 128 characters after truncation.",
        "misconception": "Targets misunderstanding of truncation: Truncation explicitly cuts the string to the limit, it doesn&#39;t allow it to exceed the limit due to prior modifications. The vulnerability is about *what* remains after truncation, not bypassing the limit."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The vulnerability arises from the order of operations: escaping then truncation. When the input `aaaaaaaa[...]aaaaaaa&#39;` (127 &#39;a&#39;s + 1 quote) is processed, the SQL injection filter first doubles the single quote, resulting in `aaaaaaaa[...]aaaaaaa&#39;&#39;`. This string is now 129 characters long. The subsequent truncation to 128 characters cuts off the *second* single quote, leaving `aaaaaaaa[...]aaaaaaa&#39;`. This effectively restores the original, unescaped single quote, which then causes a SQL syntax error in the query. This error can then be leveraged by a second input (e.g., a crafted password) to complete a malicious SQL query.",
      "distractor_analysis": "The first distractor is incorrect because the vulnerability specifically relies on the escaping happening *before* the truncation. If truncation happened first, the single quote would remain unescaped, but the specific attack described wouldn&#39;t work as intended. The second distractor misinterprets SQL syntax; doubled single quotes escape a literal quote, they don&#39;t create a comment. The third distractor misunderstands how truncation works; it doesn&#39;t bypass the length limit but rather cuts the string to that limit, and the vulnerability is about the *result* of that truncation.",
      "analogy": "Imagine you have a security guard who first puts a protective cover on a dangerous item (escaping the quote) and then a second guard who cuts the item to a specific length. If the cut happens in just the right place, it might remove the protective cover, making the item dangerous again. The order of operations is key."
    },
    "code_snippets": [
      {
        "language": "bash",
        "code": "username: aaaaaaaaa[...]aaaaaaa&#39;  # 127 &#39;a&#39;s + single quote",
        "context": "Attacker&#39;s crafted username input"
      },
      {
        "language": "bash",
        "code": "SELECT * FROM users WHERE username = &#39;aaaaaaaa[...]aaaaaaaa&#39; and password = &#39;or 1=1--&#39;",
        "context": "Resulting SQL query after successful exploitation with crafted username and password"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "attack",
    "prerequisites": [
      "WEB_APPLICATION_SECURITY_FUNDAMENTALS",
      "SQL_INJECTION_CONCEPTS",
      "INPUT_VALIDATION_TECHNIQUES"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges by exploiting a kernel vulnerability that requires specific Linux capabilities, such as `CAP_SYS_ADMIN`?",
    "correct_answer": "securityContext.capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "securityContext.allowPrivilegeEscalation: false",
        "misconception": "Targets partial prevention: Students confuse preventing *new* privileges with preventing *existing* dangerous capabilities. `allowPrivilegeEscalation: false` prevents a child process from gaining more privileges than its parent, but doesn&#39;t remove capabilities the container already has."
      },
      {
        "question_text": "securityContext.privileged: false",
        "misconception": "Targets scope misunderstanding: Students believe `privileged: false` removes all dangerous capabilities, but it only prevents the container from running in privileged mode, which grants *all* capabilities. Non-privileged containers still retain a default set of capabilities, some of which can be exploited."
      },
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets user vs. capability confusion: Students conflate running as root with having dangerous capabilities. `runAsNonRoot: true` prevents the container from running as UID 0, but a non-root user can still exploit capabilities like `CAP_NET_RAW` or `CAP_SYS_ADMIN` if they are not dropped."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `securityContext.capabilities.drop: [&quot;ALL&quot;]` setting explicitly removes all Linux capabilities from the container. This is the most effective way to prevent a container from exploiting kernel vulnerabilities that rely on specific capabilities, as it ensures the container starts with the absolute minimum set of privileges. Capabilities like `CAP_SYS_ADMIN` are particularly dangerous as they allow a wide range of system-level operations that can lead to container escape.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but doesn&#39;t remove capabilities the container already possesses. `privileged: false` prevents the container from running with *all* capabilities, but a default set of capabilities is still granted, some of which can be dangerous. `runAsNonRoot: true` prevents the container from running as the root user, but even non-root users can exploit dangerous capabilities if they are not dropped.",
      "analogy": "Imagine a safe with multiple locks. `drop: [&quot;ALL&quot;]` is like removing all the keys from the safe&#39;s custodian. `allowPrivilegeEscalation: false` is like preventing the custodian from making copies of any keys they *do* have. `privileged: false` is like not giving the custodian the master key, but they still have a set of standard keys. `runAsNonRoot: true` is like ensuring the custodian isn&#39;t the CEO, but they still have keys."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating dropping all capabilities for enhanced security."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_PREVENTION"
    ]
  },
  {
    "question_text": "A containerized web application is vulnerable to HTTP Header Injection due to unsanitized user input being reflected in the `Set-Cookie` header. Which Kubernetes security context setting, if properly configured, would directly prevent the application from being able to craft and send arbitrary HTTP headers containing newline characters to other users?",
    "correct_answer": "This vulnerability is not directly prevented by Kubernetes security context settings, as it&#39;s an application-level flaw.",
    "distractors": [
      {
        "question_text": "securityContext.allowPrivilegeEscalation: false",
        "misconception": "Targets scope confusion: Students might incorrectly associate privilege escalation with the ability to manipulate HTTP headers, but this setting prevents gaining higher privileges within the container, not application-level output manipulation."
      },
      {
        "question_text": "securityContext.readOnlyRootFilesystem: true",
        "misconception": "Targets irrelevant control: Students might think making the filesystem read-only would prevent writing malicious data, but HTTP header injection is about manipulating network responses, not filesystem writes."
      },
      {
        "question_text": "securityContext.capabilities.drop: [&quot;ALL&quot;]",
        "misconception": "Targets capability misunderstanding: Students may believe dropping all capabilities would prevent any malicious action, but manipulating HTTP responses is an application function, not a privileged kernel operation requiring specific Linux capabilities."
      }
    ],
    "detailed_explanation": {
      "core_logic": "HTTP Header Injection is an application-level vulnerability where unsanitized user input containing newline characters (CRLF) is reflected into HTTP response headers, allowing an attacker to inject arbitrary headers or even body content. Kubernetes security context settings primarily control the privileges and isolation of the container process relative to the host kernel and other containers (e.g., user ID, capabilities, seccomp profiles, filesystem access). They do not directly inspect or sanitize application-generated HTTP responses. Preventing HTTP Header Injection requires proper input validation and output encoding within the application code itself, or potentially a Web Application Firewall (WAF) at the network edge.",
      "distractor_analysis": "allowPrivilegeEscalation: false prevents a process from gaining more privileges than its parent, which is unrelated to HTTP response manipulation. readOnlyRootFilesystem: true makes the container&#39;s root filesystem immutable, but the vulnerability lies in dynamic HTTP response generation, not static file content. securityContext.capabilities.drop: [&quot;ALL&quot;] removes Linux capabilities that grant special kernel privileges (like CAP_NET_RAW for raw socket access), but sending HTTP responses is a standard network operation that doesn&#39;t require elevated capabilities; the issue is the content of the response, not the ability to send it."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "WEB_APPLICATION_SECURITY",
      "HTTP_PROTOCOL_BASICS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining new privileges, thereby mitigating certain privilege escalation attacks?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "privileged: false",
        "misconception": "Targets scope misunderstanding: Students confuse &#39;privileged&#39; mode (which grants all capabilities and host access) with the specific mechanism of privilege escalation. Setting privileged: false is a good practice but doesn&#39;t specifically target the &#39;gaining new privileges&#39; aspect as directly as allowPrivilegeEscalation."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets function confusion: Students might think preventing root execution also prevents privilege escalation. While related to least privilege, runAsNonRoot prevents a container from starting as root, but doesn&#39;t directly prevent a non-root process from escalating privileges if other conditions (like capabilities) allow it."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might associate filesystem immutability with privilege control. While important for security, readOnlyRootFilesystem prevents writing to the root filesystem but doesn&#39;t directly prevent a process from gaining new privileges within its existing filesystem context."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` setting in a container&#39;s security context prevents a process from gaining more privileges than its parent process. Specifically, it prevents the `setuid` and `setgid` bits from being honored, and it prevents a process from executing a binary with `CAP_SETUID` or `CAP_SETGID` capabilities. This directly mitigates privilege escalation attempts where a process tries to elevate its own privileges.",
      "distractor_analysis": "`privileged: false` is a broader setting that prevents the container from running in privileged mode, which grants all Linux capabilities and access to host devices. While important, it doesn&#39;t specifically target the &#39;gaining new privileges&#39; aspect as `allowPrivilegeEscalation: false` does for non-privileged containers. `runAsNonRoot: true` ensures the container does not run as UID 0 (root), which is a good practice for least privilege but doesn&#39;t directly prevent a non-root process from escalating if it has the means. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, preventing writes to system directories, but it doesn&#39;t directly control a process&#39;s ability to gain new privileges.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re in the building, you can&#39;t get a higher security clearance than you started with.&#39; `privileged: false` is like saying &#39;you can&#39;t have a master key to the whole building.&#39; Both are security measures, but they address different aspects of privilege control."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true",
        "context": "Example Pod manifest demonstrating `allowPrivilegeEscalation: false` in a security context."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "PRIVILEGE_ESCALATION_CONCEPTS"
    ]
  },
  {
    "question_text": "A containerized web application is vulnerable to SQL injection, and an attacker uses a crafted query to force a type conversion error, revealing sensitive data in the error message. Which security context setting would prevent the application from accessing the database credentials necessary for this type of attack, assuming the credentials are stored as environment variables?",
    "correct_answer": "The security context itself does not directly prevent access to environment variables. Instead, secrets management and RBAC for the application&#39;s service account are crucial.",
    "distractors": [
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets scope misunderstanding: Students might think making the filesystem read-only prevents data exfiltration, but it doesn&#39;t prevent an application from reading its own environment variables or making outbound network connections."
      },
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets control plane confusion: Students might confuse privilege escalation within the container with the application&#39;s ability to read its own configuration, which are distinct security concerns."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets partial solution bias: While good practice, running as non-root does not prevent an application from reading environment variables or executing SQL queries if it has the necessary permissions and credentials."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The security context primarily controls Linux kernel-level security features for a container (e.g., user ID, capabilities, seccomp profiles). It does not directly manage how an application accesses its configuration, such as environment variables. To prevent an application from accessing sensitive database credentials, these credentials should be stored securely using Kubernetes Secrets, mounted as files or injected as environment variables from the Secret. Access to these Secrets should then be controlled via RBAC for the Pod&#39;s Service Account, ensuring only authorized applications can retrieve them. Furthermore, network policies should restrict outbound connections to only the necessary database endpoints.",
      "distractor_analysis": "readOnlyRootFilesystem: true prevents writing to the container&#39;s root filesystem but does not restrict reading environment variables or making network calls. allowPrivilegeEscalation: false prevents a process from gaining more privileges than its parent, which is unrelated to reading environment variables. runAsNonRoot: true ensures the container doesn&#39;t run as UID 0, but if the application is compromised, it can still read its environment variables and execute code as the non-root user.",
      "analogy": "Imagine a bank vault (the database) and a teller (the web application). The security context is like the teller&#39;s uniform and basic access card (e.g., not allowed to carry weapons, restricted to certain areas). However, the teller&#39;s ability to access the vault&#39;s contents (database credentials) is determined by their specific key (Kubernetes Secret) and their job role (RBAC permissions), not just their uniform."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: vulnerable-app\nspec:\n  serviceAccountName: app-db-access\n  containers:\n  - name: webapp\n    image: vulnerable-image:latest\n    env:\n    - name: DB_PASSWORD\n      valueFrom:\n        secretKeyRef:\n          name: db-credentials\n          key: password\n    securityContext:\n      runAsNonRoot: true\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Example Pod manifest showing how credentials might be injected from a Secret, which is then controlled by RBAC for the service account. The security context settings shown are good practices but don&#39;t directly prevent reading environment variables."
      },
      {
        "language": "yaml",
        "code": "apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: default\n  name: secret-reader\nrules:\n- apiGroups: [&quot;&quot;]\n  resources: [&quot;secrets&quot;]\n  resourceNames: [&quot;db-credentials&quot;]\n  verbs: [&quot;get&quot;]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  namespace: default\n  name: app-db-access-binding\nsubjects:\n- kind: ServiceAccount\n  name: app-db-access\n  namespace: default\nroleRef:\n  kind: Role\n  name: secret-reader\n  apiGroup: rbac.authorization.k8s.io",
        "context": "Example RBAC configuration to grant a ServiceAccount &#39;get&#39; access to a specific Secret, demonstrating how access to credentials is managed outside the container&#39;s security context."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECRETS",
      "KUBERNETES_RBAC",
      "CONTAINER_SECURITY_CONTEXTS",
      "SQL_INJECTION_BASICS"
    ]
  },
  {
    "question_text": "An attacker has gained access to a container and is attempting to perform a container escape by leveraging a known kernel vulnerability. Which security context setting, combined with a robust seccomp profile, offers the strongest defense against this type of escape?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete mitigation: Students might think privileged: false is sufficient, but it only removes the &#39;privileged&#39; flag, leaving default capabilities that could still be exploited for kernel vulnerabilities."
      },
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope misunderstanding: While important, allowPrivilegeEscalation prevents a process from gaining *new* privileges. It doesn&#39;t remove existing dangerous capabilities that could be used to exploit a kernel vulnerability."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets irrelevant control: Students might associate filesystem protection with kernel exploits, but a read-only filesystem does not prevent a process with dangerous capabilities from interacting with the kernel in malicious ways."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Dropping all unnecessary Linux capabilities (`capabilities.drop: [&quot;ALL&quot;]`) is a critical defense against container escapes, especially those exploiting kernel vulnerabilities. By removing capabilities like `CAP_SYS_ADMIN`, `CAP_NET_ADMIN`, or `CAP_DAC_OVERRIDE`, the container&#39;s attack surface against the host kernel is significantly reduced. Combined with a restrictive seccomp profile, this severely limits the syscalls and kernel interactions available to a compromised container.",
      "distractor_analysis": "Setting `privileged: false` is a good practice but does not remove all default capabilities, some of which can be dangerous. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges, but doesn&#39;t remove the initial set of capabilities. `readOnlyRootFilesystem: true` protects the filesystem but doesn&#39;t restrict kernel interactions via capabilities.",
      "analogy": "Imagine a secure room. `capabilities.drop: [&quot;ALL&quot;]` is like removing all tools that could be used to pick the lock or break the walls. `seccomp` is like having a guard who only allows specific, safe actions inside the room. `privileged: false` is just making sure the door isn&#39;t wide open, but doesn&#39;t remove the tools."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "securityContext:\n  capabilities:\n    drop: [&quot;ALL&quot;]\n  seccompProfile:\n    type: RuntimeDefault",
        "context": "Pod security context dropping all capabilities and using default seccomp profile"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_TECHNIQUES",
      "SECCOMP"
    ]
  },
  {
    "question_text": "A critical application pod needs to communicate only with a specific database service within the same namespace and an external logging service. All other inbound and outbound traffic should be denied. Which NetworkPolicy configuration achieves this least-privilege network segmentation?",
    "correct_answer": "Egress rules allowing traffic to the database service and logging service, and Ingress rules allowing traffic only from necessary sources (e.g., frontend pods), with a default deny for both ingress and egress.",
    "distractors": [
      {
        "question_text": "An Ingress NetworkPolicy allowing traffic from the database service and a separate Egress NetworkPolicy allowing traffic to the logging service.",
        "misconception": "Targets incomplete policy: Students might forget that NetworkPolicy is deny-by-default. Without explicit rules for all allowed traffic (both ingress and egress), other necessary traffic might be blocked, or unwanted traffic might still be allowed if only one direction is specified."
      },
      {
        "question_text": "A NetworkPolicy with only `podSelector` matching the application pod, and `policyTypes: [&quot;Ingress&quot;, &quot;Egress&quot;]` without any rules.",
        "misconception": "Targets misunderstanding of default behavior: Students might think an empty policy with policyTypes set will implicitly allow all traffic, but it actually results in a default deny for both ingress and egress, effectively isolating the pod completely."
      },
      {
        "question_text": "A NetworkPolicy allowing all traffic within the namespace and a separate Egress rule for the external logging service.",
        "misconception": "Targets over-permissioning: Students might default to allowing all internal traffic for simplicity, violating the principle of least privilege by not restricting communication to only the database service."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To achieve least-privilege network segmentation, a NetworkPolicy should explicitly define both ingress (inbound) and egress (outbound) traffic. By default, once a NetworkPolicy selects a pod, all traffic not explicitly allowed is denied. Therefore, you need to define egress rules for the database service (using `podSelector` or `ipBlock` if it&#39;s external to Kubernetes) and the external logging service (using `ipBlock` or `namespaceSelector` if in another namespace). Similarly, ingress rules must explicitly allow traffic from any legitimate sources, such as frontend pods that initiate connections to this application.",
      "distractor_analysis": "An Ingress policy alone won&#39;t restrict outbound traffic, and an Egress policy alone won&#39;t restrict inbound. An empty policy with `policyTypes` will deny all traffic, which is too restrictive. Allowing all traffic within the namespace violates least privilege, as the application only needs to talk to the database, not every other pod.",
      "analogy": "This is like a highly secure building. You need a specific badge (Ingress rule) to enter, and you can only use specific exits (Egress rules) to go to the cafeteria or the parking lot. Any other entry or exit is blocked."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: app-db-logging-policy\nspec:\n  podSelector:\n    matchLabels:\n      app: my-app\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          app: frontend-app # Allow traffic from frontend\n  egress:\n  - to:\n    - podSelector:\n        matchLabels:\n          app: my-database # Allow traffic to database service\n  - to:\n    - ipBlock:\n        cidr: 10.0.0.0/24 # Example: IP range for external logging service",
        "context": "NetworkPolicy for least-privilege communication to database and external logging"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "A Kubernetes cluster administrator wants to ensure that no container can ever run with the `NET_RAW` capability, which allows it to forge network packets. Which Pod Security Standard (PSS) profile would enforce this restriction by default?",
    "correct_answer": "Restricted",
    "distractors": [
      {
        "question_text": "Baseline",
        "misconception": "Targets profile misunderstanding: Students might think Baseline is strict enough, but it allows `NET_RAW` by default, as it focuses on preventing known privilege escalations, not all dangerous capabilities."
      },
      {
        "question_text": "Privileged",
        "misconception": "Targets inverse understanding: Students might confuse Privileged as the most secure, but it&#39;s the least secure, allowing all capabilities and no restrictions."
      },
      {
        "question_text": "Custom (requires manual configuration)",
        "misconception": "Targets unnecessary complexity: While a custom profile *could* enforce this, the question asks which *default* PSS profile enforces it, implying a built-in option."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `Restricted` Pod Security Standard profile is designed to enforce hardening best practices and prevent known privilege escalations. One of its key restrictions is to disallow the use of most Linux capabilities, including `NET_RAW`, which is considered dangerous. The `Baseline` profile, while more secure than `Privileged`, still permits `NET_RAW` by default.",
      "distractor_analysis": "The `Baseline` profile allows `NET_RAW` by default. The `Privileged` profile allows all capabilities and imposes no restrictions. While a custom profile could enforce this, the `Restricted` profile does so by default, making it the most appropriate answer for a default enforcement.",
      "analogy": "Think of PSS profiles like security levels for a building. `Privileged` is no security, anyone can do anything. `Baseline` is basic security, like locking the main door but leaving some tools inside. `Restricted` is high security, locking the main door and removing all dangerous tools, including those that could forge passes (`NET_RAW`)."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-pod\n  labels:\n    app: my-app\nspec:\n  securityContext:\n    runAsNonRoot: true\n    seccompProfile:\n      type: RuntimeDefault\n    capabilities:\n      drop: [&quot;ALL&quot;]\n  containers:\n  - name: my-container\n    image: my-image:latest",
        "context": "Example Pod configuration that would pass the Restricted PSS profile"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "definition",
    "prerequisites": [
      "POD_SECURITY_STANDARDS",
      "LINUX_CAPABILITIES"
    ]
  },
  {
    "question_text": "A Kubernetes application is designed where the frontend service (application tier) directly interacts with a backend database (data tier). The database is configured to trust all connections originating from the frontend service&#39;s IP address, assuming the frontend has already performed all necessary access control checks. If the frontend service is compromised via a command injection vulnerability, which security control would best limit the blast radius of this trust relationship exploitation?",
    "correct_answer": "Implement a NetworkPolicy that restricts the frontend service&#39;s egress traffic to only the necessary database port and IP, and ingress to the database from only the frontend service&#39;s IP.",
    "distractors": [
      {
        "question_text": "Configure the database to use a read-only user account for the frontend service&#39;s connections.",
        "misconception": "Targets partial mitigation: While a read-only account limits data modification, it doesn&#39;t prevent data exfiltration or other command injection consequences if the attacker can still execute arbitrary commands on the frontend and pivot to other services."
      },
      {
        "question_text": "Ensure the frontend service runs with `runAsNonRoot: true` and drops all capabilities.",
        "misconception": "Targets control plane confusion: These security context settings prevent privilege escalation within the container or host escape, but they do not directly address network-based trust exploitation between services."
      },
      {
        "question_text": "Apply a Pod Security Standard (PSS) of &#39;Restricted&#39; to the frontend service&#39;s Pod.",
        "misconception": "Targets scope misunderstanding: PSS &#39;Restricted&#39; enforces strong security context settings for the pod itself, but it does not inherently define or restrict network communication patterns between pods or external services."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The scenario describes a trust relationship where the database implicitly trusts the application tier. A command injection on the frontend allows an attacker to leverage this trust. A NetworkPolicy is designed to control network traffic between pods and other network endpoints. By explicitly defining egress rules for the frontend to only allow connections to the database on its specific port, and ingress rules for the database to only accept connections from the frontend, you create a micro-segmentation that prevents the compromised frontend from initiating connections to other internal or external services, thus limiting the blast radius of the command injection exploit.",
      "distractor_analysis": "Configuring a read-only database user is a good practice for least privilege but doesn&#39;t prevent an attacker from using the compromised frontend to scan internal networks, exfiltrate data (if read access is sufficient), or pivot to other services if the NetworkPolicy isn&#39;t in place. `runAsNonRoot: true` and dropping capabilities are crucial for preventing container escapes and privilege escalation, but they don&#39;t directly govern network communication between services. Applying a &#39;Restricted&#39; PSS profile enhances the pod&#39;s internal security posture but does not define or enforce network communication rules, which is the primary vector for exploiting inter-tier trust relationships.",
      "analogy": "Imagine a security guard (NetworkPolicy) at a building (Kubernetes cluster). Even if a visitor (frontend service) has a valid ID (trust relationship) to enter one specific office (database), the guard ensures they can only go to that office and nowhere else, preventing them from wandering into other sensitive areas if their ID is stolen (frontend compromised)."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: frontend-to-db-policy\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: frontend\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              app: database\n      ports:\n        - protocol: TCP\n          port: 5432 # Example PostgreSQL port\n---\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: db-ingress-from-frontend-policy\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: database\n  policyTypes:\n    - Ingress\n  ingress:\n    - from:\n        - podSelector:\n            matchLabels:\n              app: frontend\n      ports:\n        - protocol: TCP\n          port: 5432",
        "context": "Kubernetes NetworkPolicy to restrict egress from frontend to database and ingress to database from frontend."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICY",
      "CONTAINER_SECURITY_FUNDAMENTALS",
      "WEB_APPLICATION_VULNERABILITIES"
    ]
  },
  {
    "question_text": "A Kubernetes application is designed with multiple tiers, including a web frontend, an application server, and a database. Following the principle of &#39;Minimize Trust Relationships&#39; for containerized environments, which security context configuration for the application server container best mitigates the impact of a potential command injection vulnerability?",
    "correct_answer": "The application server container should run with `runAsNonRoot: true`, `readOnlyRootFilesystem: true`, and `capabilities.drop: [&quot;ALL&quot;]`.",
    "distractors": [
      {
        "question_text": "The application server container should have `allowPrivilegeEscalation: false` and `seccompProfile.type: RuntimeDefault`.",
        "misconception": "Targets incomplete mitigation: Students might think these settings are sufficient, but `allowPrivilegeEscalation: false` prevents gaining *new* privileges, not running with existing dangerous ones, and `RuntimeDefault` seccomp is a good baseline but doesn&#39;t explicitly drop all capabilities."
      },
      {
        "question_text": "The application server container should be deployed in a dedicated namespace with a NetworkPolicy restricting egress traffic.",
        "misconception": "Targets control plane confusion: Students confuse network isolation and blast radius containment with preventing the initial impact of a command injection within the container itself. NetworkPolicy is for lateral movement, not initial compromise prevention."
      },
      {
        "question_text": "The application server container should use a `privileged: true` security context to ensure all necessary OS functions are available.",
        "misconception": "Targets misunderstanding of least privilege: Students might incorrectly assume that &#39;all necessary OS functions&#39; implies `privileged: true`, which is the opposite of least privilege and would exacerbate a command injection vulnerability by granting full host access."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The principle of &#39;Minimize Trust Relationships&#39; dictates that each component should defend itself. For a containerized application server, mitigating command injection means limiting what an attacker can do if they successfully inject commands. Running as `runAsNonRoot: true` prevents the injected commands from executing as the root user. `readOnlyRootFilesystem: true` prevents an attacker from writing to critical system directories or installing malicious binaries. `capabilities.drop: [&quot;ALL&quot;]` removes all Linux capabilities, severely limiting the attacker&#39;s ability to interact with the host kernel or perform privileged operations, even if they manage to execute commands. This combination directly reduces the impact of a command injection by restricting the container&#39;s privileges.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` and `seccompProfile.type: RuntimeDefault` are good practices but are not as direct in mitigating the *impact* of command injection as dropping all capabilities and running non-root. `allowPrivilegeEscalation: false` prevents gaining *more* privileges, but if the container already has dangerous capabilities, it doesn&#39;t help. `RuntimeDefault` seccomp is a general profile, not specifically tailored to remove all dangerous syscalls that could be exploited via command injection. Deploying in a dedicated namespace with NetworkPolicy is crucial for limiting the blast radius *after* a compromise but does not prevent or mitigate the initial impact of the command injection within the container itself. `privileged: true` is an anti-pattern for security, granting full host access and making any command injection vulnerability critical, directly violating the principle of least privilege.",
      "analogy": "Imagine a bank vault (the container). `runAsNonRoot` is like ensuring the vault manager doesn&#39;t have the master key to the entire bank. `readOnlyRootFilesystem` is like making the vault walls impenetrable to drilling. `capabilities.drop: [&quot;ALL&quot;]` is like removing all tools (drills, torches, explosives) from inside the vault, so even if someone gets in, they can&#39;t do much damage or escape to other parts of the bank."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-server\nspec:\n  template:\n    spec:\n      containers:\n      - name: app\n        image: my-app-server:v1.0\n        securityContext:\n          runAsNonRoot: true\n          readOnlyRootFilesystem: true\n          capabilities:\n            drop: [&quot;ALL&quot;]\n          seccompProfile:\n            type: RuntimeDefault",
        "context": "Kubernetes Deployment manifest snippet for an application server container with security context settings to mitigate command injection."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "COMMAND_INJECTION_VULNERABILITIES",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "A multi-tenant Kubernetes application uses a shared logging service that aggregates logs from all tenant pods. An attacker successfully injects malicious JavaScript into their tenant&#39;s log entries, which are then viewed by an administrative user of the shared logging service. Which security control would have prevented the administrative user&#39;s session from being hijacked?",
    "correct_answer": "Enforcing a Restricted Pod Security Standard profile on the logging service&#39;s pods to prevent arbitrary code execution via log parsing",
    "distractors": [
      {
        "question_text": "Implementing NetworkPolicies to isolate tenant pods from the logging service",
        "misconception": "Targets control plane confusion: Students confuse network isolation (preventing direct communication) with content-based attack prevention; NetworkPolicies don&#39;t sanitize or prevent malicious content from being processed by a legitimate service."
      },
      {
        "question_text": "Using RBAC to restrict the administrative user&#39;s access to only their tenant&#39;s logs",
        "misconception": "Targets scope misunderstanding: RBAC controls access to Kubernetes resources, not the content within application logs or the rendering of that content in a web UI. The attack is on the application layer, not the Kubernetes API."
      },
      {
        "question_text": "Configuring `readOnlyRootFilesystem: true` for the tenant&#39;s application pods",
        "misconception": "Targets irrelevant control: Students might associate &#39;read-only&#39; with security, but `readOnlyRootFilesystem` prevents writing to the container&#39;s filesystem, not injecting data into an external logging service or preventing XSS in a viewer."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The scenario describes a stored Cross-Site Scripting (XSS) attack where malicious JavaScript is stored in logs and executed in the browser of an administrative user. While the prompt focuses on the *prevention* of the session hijack, the underlying issue is the logging service&#39;s vulnerability to rendering untrusted input. A Restricted Pod Security Standard profile, when applied to the *logging service&#39;s pods*, would enforce strict security contexts (e.g., `seccompProfile: RuntimeDefault`, `allowPrivilegeEscalation: false`, `capabilities: drop: [&quot;ALL&quot;]`) that make it harder for an attacker to compromise the logging service itself, or for the logging service to execute arbitrary code if it were somehow tricked into doing so. However, the most direct prevention of the XSS would be proper input sanitization and output encoding by the logging service&#39;s UI. Given the options, enforcing a Restricted profile on the *logging service&#39;s pods* would contribute to the overall security posture, making it harder for the logging service to be exploited in ways that could facilitate such an attack, or for an attacker to gain further control if the XSS was part of a larger exploit chain. The question implies a vulnerability in the *logging service&#39;s handling* of the malicious log entry. A robust logging service, ideally, would sanitize or encode log entries before rendering them to prevent XSS. If the logging service itself is compromised or misconfigured, a Restricted PSS profile would limit its capabilities, making it harder to escalate privileges or perform further attacks, even if it renders malicious content. The best answer here is about preventing the *consequences* of the XSS in the context of the logging service&#39;s execution environment, rather than directly preventing the XSS itself, which is an application-level vulnerability.",
      "distractor_analysis": "NetworkPolicies isolate network traffic but do not sanitize application content; the malicious JavaScript is legitimate data from the logging service&#39;s perspective. RBAC controls access to Kubernetes API resources, not the content displayed by a web application. `readOnlyRootFilesystem: true` prevents writing to the container&#39;s filesystem but has no bearing on how an external logging service processes and displays log entries.",
      "analogy": "This is like a security guard (Restricted PSS) ensuring the log viewer (logging service) is wearing protective gear and can&#39;t pick up dangerous items, even if someone tries to slip them something harmful in a package (malicious log entry). The best defense is for the log viewer to inspect all packages carefully (input sanitization/output encoding), but the protective gear adds a layer of safety."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: policy/v1\nkind: PodSecurityPolicy\nmetadata:\n  name: restricted\nspec:\n  privileged: false\n  allowPrivilegeEscalation: false\n  requiredDropCapabilities:\n    - ALL\n  volumes:\n    - &#39;configMap&#39;\n    - &#39;emptyDir&#39;\n    - &#39;projected&#39;\n    - &#39;secret&#39;\n    - &#39;downwardAPI&#39;\n    - &#39;persistentVolumeClaim&#39;\n  hostNetwork: false\n  hostPID: false\n  hostIPC: false\n  runAsUser:\n    rule: &#39;MustRunAsNonRoot&#39;\n  seccompProfile:\n    type: &#39;RuntimeDefault&#39;\n  # ... other restricted settings",
        "context": "Example of a Restricted Pod Security Policy (though PSS is deprecated, the principles are enforced by Pod Security Admission with the Restricted profile)"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "POD_SECURITY_STANDARDS",
      "WEB_APPLICATION_SECURITY",
      "XSS_ATTACKS"
    ]
  },
  {
    "question_text": "A containerized web application is deployed with a separate database container. An attacker gains remote code execution (RCE) on the web application container. Which security control is most effective in preventing the attacker from directly accessing sensitive data in the database container?",
    "correct_answer": "NetworkPolicy restricting egress from the web app container to only the database port",
    "distractors": [
      {
        "question_text": "Setting `readOnlyRootFilesystem: true` on the web app container",
        "misconception": "Targets scope misunderstanding: Students might think making the filesystem read-only prevents all data access, but it only prevents writing to the web app&#39;s filesystem, not network-based access to other containers."
      },
      {
        "question_text": "Enforcing `runAsNonRoot: true` for the web app container",
        "misconception": "Targets privilege confusion: Students might believe running as non-root prevents all attacks, but it primarily limits host-level privilege escalation, not lateral movement between containers via network."
      },
      {
        "question_text": "Applying a `seccompProfile: RuntimeDefault` to the web app container",
        "misconception": "Targets control plane confusion: Students might think seccomp profiles prevent all malicious actions, but while they restrict syscalls, they don&#39;t inherently block network connections to other containers if the syscalls for networking are allowed."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Remote Code Execution (RCE) on the web application container allows an attacker to run arbitrary commands. To prevent this attacker from directly accessing the database container, a NetworkPolicy should be implemented. This policy would restrict the web application container&#39;s egress traffic to only the specific port(s) required to communicate with the database container (e.g., port 5432 for PostgreSQL, 3306 for MySQL). This limits the attacker&#39;s ability to scan for other services or exfiltrate data to external destinations, effectively containing the blast radius.",
      "distractor_analysis": "`readOnlyRootFilesystem: true` prevents an attacker from modifying the web application&#39;s filesystem but does not prevent network connections to other containers. `runAsNonRoot: true` prevents the container from running as UID 0, which is good practice for host-level security, but doesn&#39;t restrict network egress. `seccompProfile: RuntimeDefault` provides a baseline of syscall restrictions, but typically allows necessary networking syscalls, so it wouldn&#39;t inherently block connections to the database container if the application legitimately needs to connect.",
      "analogy": "Imagine a secure office building. RCE on the web app is like an intruder gaining access to one office. A NetworkPolicy is like locking all other office doors and only allowing the intruder to use the phone to call the database department&#39;s specific extension, preventing them from wandering into other departments or leaving the building."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: web-to-db-egress\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: web-app\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              app: database\n      ports:\n        - protocol: TCP\n          port: 5432 # Example: PostgreSQL port",
        "context": "Kubernetes NetworkPolicy restricting egress from &#39;web-app&#39; to only &#39;database&#39; on a specific port."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORKING",
      "CONTAINER_SECURITY_FUNDAMENTALS",
      "NETWORK_POLICIES"
    ]
  },
  {
    "question_text": "A containerized web application is found to be running a default sample servlet, `/test/jsp/dump.jsp`, which exposes server details and is vulnerable to Cross-Site Scripting (XSS) via URL parameters. Which securityContext setting would prevent the container from executing arbitrary scripts injected through such a vulnerability, assuming the XSS payload attempts to write to the filesystem or execute a new process?",
    "correct_answer": "readOnlyRootFilesystem: true and capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets partial protection: Students might think running as non-root is sufficient, but it doesn&#39;t prevent XSS payloads from executing if they don&#39;t require root privileges or if other capabilities are available."
      },
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope confusion: Students might confuse preventing privilege escalation with preventing script execution. allowPrivilegeEscalation prevents a process from gaining more privileges than its parent, but doesn&#39;t stop an already-privileged (or non-root with capabilities) process from executing scripts."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete understanding of capabilities: While `privileged: false` is good practice, it still leaves default capabilities that an XSS payload could potentially leverage for limited execution or information disclosure, especially if combined with other vulnerabilities."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The XSS vulnerability allows an attacker to inject and execute client-side scripts. While `readOnlyRootFilesystem: true` prevents the script from writing to the container&#39;s filesystem, `capabilities.drop: [&quot;ALL&quot;]` is crucial. Dropping all capabilities severely restricts what the container processes can do, including preventing them from executing new processes or making system calls that could be exploited by an XSS payload to escalate privileges or perform malicious actions beyond simple client-side manipulation, especially if the XSS leads to server-side execution.",
      "distractor_analysis": "`runAsNonRoot: true` prevents the container from running as UID 0, but an XSS payload can still execute as a non-root user with existing capabilities. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but doesn&#39;t stop an XSS payload from executing within the existing privilege context. `privileged: false` removes broad host access but leaves default capabilities that could still be exploited by a sophisticated XSS payload for limited execution or information gathering.",
      "analogy": "Imagine a house with a broken window (the XSS vulnerability). `readOnlyRootFilesystem: true` is like making sure the walls inside are concrete and nothing can be written on them. `capabilities.drop: [&quot;ALL&quot;]` is like removing all tools (hammers, drills, keys) from the house, so even if someone gets in through the window, they can&#39;t do much damage or open any doors."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "securityContext:\n  readOnlyRootFilesystem: true\n  capabilities:\n    drop: [&quot;ALL&quot;]\n  allowPrivilegeEscalation: false # Good practice, but not the primary defense here\n  runAsNonRoot: true # Good practice, but not the primary defense here",
        "context": "Kubernetes Pod securityContext to mitigate XSS leading to potential container escape or malicious execution"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "XSS_VULNERABILITIES"
    ]
  },
  {
    "question_text": "A legacy PHP application running in a Docker container has `magic_quotes_gpc` enabled. An attacker attempts SQL injection. Which security context setting, if misconfigured, could inadvertently assist the attacker by allowing the application to run with unnecessary privileges, even though `magic_quotes_gpc` is present?",
    "correct_answer": "privileged: true",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: true",
        "misconception": "Targets scope confusion: Students might confuse `allowPrivilegeEscalation` with general privilege, but it specifically refers to gaining *more* privileges than the process already has, not the initial set of privileges like `privileged: true`."
      },
      {
        "question_text": "readOnlyRootFilesystem: false",
        "misconception": "Targets irrelevant control: Students might think write access to the filesystem is related to SQL injection, but `readOnlyRootFilesystem` primarily prevents tampering with the container&#39;s OS, not directly influencing how `magic_quotes_gpc` interacts with database vulnerabilities."
      },
      {
        "question_text": "runAsNonRoot: false",
        "misconception": "Targets user vs. capability confusion: While running as root (`runAsNonRoot: false`) is generally bad practice, it doesn&#39;t directly grant the *host-level* capabilities that `privileged: true` does, which could be exploited in a container escape to further an attack after SQL injection."
      }
    ],
    "detailed_explanation": {
      "core_logic": "While `magic_quotes_gpc` is an application-level defense, the question asks about a *security context setting* that could inadvertently assist an attacker. `privileged: true` grants the container all capabilities to the host, essentially removing container isolation. If an attacker successfully exploits an SQL injection (which `magic_quotes_gpc` doesn&#39;t fully prevent, especially for numeric fields or second-order attacks), and the container is running in privileged mode, they could potentially leverage this to escape the container and access the host system, significantly escalating the impact of the initial SQL injection. This misconfiguration provides a much larger attack surface beyond the application itself.",
      "distractor_analysis": "`allowPrivilegeEscalation: true` allows a process to gain more privileges than its parent, but `privileged: true` already grants maximum privileges, making `allowPrivilegeEscalation` less relevant in this specific context of initial high privilege. `readOnlyRootFilesystem: false` allows writing to the container&#39;s root filesystem, which is a security risk, but doesn&#39;t directly relate to the `magic_quotes_gpc` SQL injection scenario or the broad host access granted by `privileged: true`. `runAsNonRoot: false` means the container runs as root, which is poor practice, but it doesn&#39;t grant the extensive host capabilities that `privileged: true` does, which are critical for container escapes after an initial compromise.",
      "analogy": "Imagine `magic_quotes_gpc` as a flimsy lock on a door. `privileged: true` is like leaving the entire building&#39;s master key on the floor inside that room. Even if the lock is picked (SQL injection), having the master key (privileged mode) allows the attacker to do far more damage than just being inside the room."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "securityContext:\n  privileged: true",
        "context": "Example of a misconfigured security context granting excessive privileges."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "attack",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "CONTAINER_PRIVILEGES",
      "SQL_INJECTION_BASICS",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "A Kubernetes application container is found to be vulnerable to SQL injection due to improper handling of user input in database queries. Which container security control, if properly implemented, would have prevented this specific vulnerability?",
    "correct_answer": "Using prepared statements with parameterized queries in the application code",
    "distractors": [
      {
        "question_text": "Implementing a NetworkPolicy to restrict egress traffic from the pod",
        "misconception": "Targets control plane confusion: Students confuse network segmentation (NetworkPolicy) with application-layer input validation; NetworkPolicy limits communication but doesn&#39;t prevent SQL injection within the application."
      },
      {
        "question_text": "Setting `readOnlyRootFilesystem: true` in the pod&#39;s securityContext",
        "misconception": "Targets scope misunderstanding: Students think filesystem immutability prevents all vulnerabilities; readOnlyRootFilesystem prevents writing to the container&#39;s root filesystem but has no bearing on how the application processes user input or interacts with a database."
      },
      {
        "question_text": "Enforcing the `Restricted` Pod Security Standard on the namespace",
        "misconception": "Targets control type confusion: Students conflate general hardening (PSS) with application-specific vulnerability prevention; while &#39;Restricted&#39; PSS improves overall security, it does not directly prevent application-layer vulnerabilities like SQL injection, which are code-level issues."
      }
    ],
    "detailed_explanation": {
      "core_logic": "SQL injection is an application-layer vulnerability that occurs when an application concatenates user-supplied input directly into an SQL query without proper sanitization or parameterization. Prepared statements with parameterized queries separate the SQL code from the user-supplied data, ensuring that the input is treated as data values rather than executable SQL commands, thereby preventing injection attacks. This is a fundamental application security best practice.",
      "distractor_analysis": "Implementing a NetworkPolicy restricts network communication but does not prevent the application itself from being exploited if it&#39;s vulnerable to SQL injection. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which is a good security practice for preventing persistence or tampering, but it doesn&#39;t address how the application constructs database queries. Enforcing the `Restricted` Pod Security Standard applies strong security defaults at the Kubernetes level (e.g., dropping capabilities, running as non-root), which is excellent for preventing container escapes and privilege escalation, but it does not directly address application-level code vulnerabilities like SQL injection.",
      "analogy": "Think of SQL injection like a malicious instruction slipped into a letter. Prepared statements are like using a pre-printed form where you can only fill in the blanks, making it impossible to add extra instructions. NetworkPolicy is like putting the letter in a secure envelope, and `readOnlyRootFilesystem` is like making sure the pen used to write the letter can&#39;t also be used to deface the mailbox. These are good, but they don&#39;t stop the malicious instruction from being written on the letter itself if the form isn&#39;t used."
    },
    "code_snippets": [
      {
        "language": "bash",
        "code": "my $username = &quot;admin&#39; or 1=1--&quot;;\nmy $password = &quot;foo&quot;;\nmy $sql = $db_connection-&gt;prepare(&quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;);\n$sql-&gt;execute($username, $password);",
        "context": "Example of using prepared statements to prevent SQL injection in Perl"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "SQL_INJECTION_FUNDAMENTALS",
      "KUBERNETES_SECURITY_CONTEXTS",
      "NETWORK_POLICIES"
    ]
  },
  {
    "question_text": "A Kubernetes application uses a database with stored procedures that process user input. Which security context setting is most effective at preventing a container escape if a SQL injection vulnerability in a stored procedure leads to arbitrary code execution within the container?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets partial protection: Students might think running as non-root prevents all escapes, but if the non-root user still has dangerous capabilities (like CAP_SYS_ADMIN), escapes are still possible."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets scope confusion: Students confuse filesystem immutability with process-level privilege control. While good practice, it doesn&#39;t prevent arbitrary code execution from leveraging existing capabilities for escape."
      },
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets timing/mechanism confusion: Students might think this prevents the initial exploit. However, if the container already has dangerous capabilities, allowPrivilegeEscalation: false only prevents *gaining new* privileges, not using existing ones for escape."
      }
    ],
    "detailed_explanation": {
      "core_logic": "If a SQL injection vulnerability allows arbitrary code execution within the container, the attacker will attempt to leverage existing Linux capabilities to escape to the host. Dropping all capabilities (`capabilities.drop: [&quot;ALL&quot;]`) removes the most dangerous capabilities (like CAP_SYS_ADMIN, CAP_DAC_OVERRIDE, CAP_NET_RAW, etc.) that are commonly used for container escapes, significantly hindering the attacker&#39;s ability to interact with the host kernel or devices.",
      "distractor_analysis": "While `runAsNonRoot: true` is a good practice, a non-root user can still exploit capabilities for escape. `readOnlyRootFilesystem: true` prevents writing to the root filesystem but doesn&#39;t stop an attacker from using capabilities to manipulate the kernel or other host resources. `allowPrivilegeEscalation: false` prevents a process from gaining *more* privileges than its parent, but if the container already starts with dangerous capabilities, this setting won&#39;t prevent their exploitation.",
      "analogy": "Imagine a container as a locked room. SQL injection is like finding a way to operate a machine inside the room. `capabilities.drop: [&quot;ALL&quot;]` is like removing all the tools that could be used to pick the lock or break the wall. `runAsNonRoot` is like making sure the person operating the machine isn&#39;t the building manager, but they might still have a crowbar. `readOnlyRootFilesystem` is like making sure the machine itself can&#39;t be modified, but it doesn&#39;t stop the person from using it to attack the room. `allowPrivilegeEscalation` is like preventing the person from asking for more tools, but if they already have a crowbar, it&#39;s too late."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: db-app\nspec:\n  containers:\n  - name: app-container\n    image: my-db-app:latest\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod definition with security context settings to mitigate container escape from code execution vulnerabilities."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_TECHNIQUES",
      "KUBERNETES_SECURITY_CONTEXTS",
      "SQL_INJECTION_BASICS"
    ]
  },
  {
    "question_text": "A Kubernetes pod runs an application that interacts with a legacy database. The application uses prepared statements for its direct database calls. However, a security audit reveals a stored procedure in the database that dynamically constructs SQL queries using user-supplied input. If this stored procedure is invoked by the application, which security control in Kubernetes is most relevant to limiting the potential blast radius of a successful SQL injection attack exploiting this stored procedure?",
    "correct_answer": "NetworkPolicy restricting egress from the application pod to only necessary database ports and hosts",
    "distractors": [
      {
        "question_text": "Pod Security Standard (PSS) Restricted profile applied to the application pod",
        "misconception": "Targets control plane confusion: PSS Restricted profile focuses on preventing container escapes and privilege escalation within the pod, not on limiting network-based lateral movement after a database compromise."
      },
      {
        "question_text": "securityContext with readOnlyRootFilesystem: true for the application container",
        "misconception": "Targets scope misunderstanding: readOnlyRootFilesystem prevents writing to the container&#39;s filesystem but does not prevent the application from making malicious database calls or exfiltrating data over the network if a SQL injection occurs."
      },
      {
        "question_text": "RBAC role limiting the application&#39;s ServiceAccount to &#39;get&#39; and &#39;list&#39; permissions on its own namespace",
        "misconception": "Targets domain mismatch: RBAC controls access to Kubernetes API resources, not external database access or network traffic. Limiting API permissions does not prevent a compromised application from interacting with external services."
      }
    ],
    "detailed_explanation": {
      "core_logic": "A SQL injection vulnerability in a stored procedure, even if the application uses prepared statements, means an attacker can manipulate database queries. If successful, the attacker could potentially exfiltrate sensitive data, modify data, or even execute arbitrary commands on the database server. A NetworkPolicy is crucial here because it can restrict the application pod&#39;s outbound (egress) network connections. By allowing connections only to the specific database server(s) on the required port(s), and blocking all other outbound traffic, the NetworkPolicy limits the attacker&#39;s ability to use the compromised database connection for lateral movement to other internal systems or for exfiltrating data to external command-and-control servers.",
      "distractor_analysis": "The PSS Restricted profile is excellent for preventing container escapes and privilege escalation, but it doesn&#39;t directly control network egress from the pod. readOnlyRootFilesystem prevents changes to the container&#39;s filesystem but doesn&#39;t stop network communication. RBAC governs access to the Kubernetes API, not the network traffic originating from within a pod to external services.",
      "analogy": "Imagine a bank vault (the database) with a weak lock (the vulnerable stored procedure). Even if the bank teller (the application) uses a secure procedure to open the vault, a thief (attacker) could exploit the weak lock directly. A NetworkPolicy is like building a secure, one-way tunnel from the bank teller&#39;s station to only that specific vault, preventing the thief from using the vault access to reach other parts of the bank or escape to the outside world."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: restrict-db-egress\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: my-vulnerable-app\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - ipBlock:\n            cidr: 192.168.1.10/32 # IP of the database server\n      ports:\n        - protocol: TCP\n          port: 5432 # Database port (e.g., PostgreSQL)\n    - to:\n        - podSelector: {}\n          namespaceSelector: {}\n      ports:\n        - protocol: TCP\n          port: 53 # Allow DNS resolution",
        "context": "Kubernetes NetworkPolicy to restrict egress traffic from an application pod to only the necessary database server and DNS."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICY",
      "SQL_INJECTION_CONCEPTS",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "A containerized web application is deployed in Kubernetes. An attacker gains initial access and attempts to escalate privileges by exploiting a known vulnerability in a kernel module. Which securityContext setting is most effective at preventing this specific privilege escalation method?",
    "correct_answer": "privileged: false",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets setting confusion: Students confuse allowPrivilegeEscalation with privileged mode. allowPrivilegeEscalation prevents a child process from gaining more privileges than its parent, but doesn&#39;t prevent the container from starting with high privileges if &#39;privileged: true&#39; is set."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students think preventing root user prevents all privilege escalation. runAsNonRoot prevents the container from running as UID 0, but a non-root user can still exploit kernel vulnerabilities if the container is in privileged mode or has dangerous capabilities."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might believe making the filesystem read-only prevents kernel exploits. While good for integrity, it doesn&#39;t prevent a container from interacting with the kernel in a privileged way if it has the necessary capabilities or is in privileged mode."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Exploiting a kernel module vulnerability typically requires direct access to host devices or kernel interfaces, which is granted when a container runs in `privileged: true` mode. Setting `privileged: false` removes all capabilities and disables access to host devices, significantly reducing the attack surface for kernel-level exploits and preventing direct interaction with kernel modules.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but if the container itself starts in privileged mode, this setting has limited impact on preventing kernel module exploits. `runAsNonRoot: true` prevents the container from running as UID 0, but even a non-root user can exploit kernel vulnerabilities if the container has `privileged: true` or dangerous capabilities. `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, which is good for integrity but does not prevent a privileged container from interacting with the host kernel.",
      "analogy": "Think of `privileged: false` as locking the door to the engine room of a ship. Even if an attacker has a tool (kernel exploit), they can&#39;t use it if they can&#39;t get into the engine room. `allowPrivilegeEscalation: false` is like preventing someone from getting a master key once they&#39;re already inside a room, but it doesn&#39;t stop them if they started with the master key (privileged mode)."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: secure-app\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      privileged: false # Prevents direct access to host devices and kernel modules\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      runAsNonRoot: true\n      runAsUser: 1000",
        "context": "Pod security context preventing privileged mode and dropping capabilities"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "Which image scanning technique is most effective at detecting known vulnerabilities in third-party libraries used within a container image?",
    "correct_answer": "Software Bill of Materials (SBOM) analysis combined with vulnerability databases",
    "distractors": [
      {
        "question_text": "Static Application Security Testing (SAST) of the application code",
        "misconception": "Targets scope confusion: SAST analyzes proprietary application code, not typically the dependencies within third-party libraries, which are often pre-compiled or pre-packaged."
      },
      {
        "question_text": "Dynamic Application Security Testing (DAST) during runtime",
        "misconception": "Targets phase confusion: DAST operates on a running application to find vulnerabilities through execution, but it doesn&#39;t directly scan the static image layers or identify known CVEs in bundled libraries before deployment."
      },
      {
        "question_text": "Runtime behavioral analysis and anomaly detection",
        "misconception": "Targets control plane confusion: This technique focuses on detecting anomalous behavior during container execution, not on identifying known vulnerabilities in the static image components prior to runtime."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Detecting known vulnerabilities in third-party libraries within a container image is best achieved by generating a Software Bill of Materials (SBOM) for the image. An SBOM lists all components, including dependencies, used in the image. This SBOM can then be cross-referenced against continuously updated vulnerability databases (like NVD, OSV, etc.) to identify known CVEs (Common Vulnerabilities and Exposures) associated with those specific library versions. This process is often part of a comprehensive container image scanning solution.",
      "distractor_analysis": "SAST primarily analyzes the source code of the application itself, not the pre-built third-party libraries. DAST tests the running application for vulnerabilities but doesn&#39;t inherently scan the static image for known library vulnerabilities. Runtime behavioral analysis detects suspicious activity during execution, which is a post-deployment control, not a pre-deployment image scanning technique for known vulnerabilities.",
      "analogy": "Imagine you&#39;re building a house with pre-fabricated components. SBOM analysis is like getting a detailed list of every component (walls, windows, pipes) and checking that list against a database of known faulty products before you even start building. SAST is like checking the blueprints you drew yourself. DAST is like testing the finished house for leaks or structural weaknesses after it&#39;s built."
    },
    "code_snippets": [
      {
        "language": "bash",
        "code": "trivy image --format cyclonedx --output sbom.json my-container-image:latest\ntrivy image my-container-image:latest",
        "context": "Example commands using Trivy to generate an SBOM and scan a container image for vulnerabilities."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "CONTAINER_IMAGE_SECURITY",
      "VULNERABILITY_MANAGEMENT",
      "SOFTWARE_SUPPLY_CHAIN_SECURITY"
    ]
  },
  {
    "question_text": "A Kubernetes pod is configured with `securityContext.capabilities.add: [&quot;NET_ADMIN&quot;]`. Which network policy configuration is most effective at limiting the blast radius if an attacker exploits this capability to manipulate network rules within the pod?",
    "correct_answer": "Egress NetworkPolicy denying all outbound traffic except to whitelisted internal services and DNS",
    "distractors": [
      {
        "question_text": "Ingress NetworkPolicy allowing traffic only from specific namespaces",
        "misconception": "Targets scope confusion: Students confuse ingress (inbound) with egress (outbound) traffic. NET_ADMIN exploitation primarily impacts outbound connections or internal network manipulation, not inbound access."
      },
      {
        "question_text": "Pod Security Standard &#39;Restricted&#39; profile applied to the namespace",
        "misconception": "Targets control plane vs. data plane: While &#39;Restricted&#39; would prevent `NET_ADMIN` from being added, this question assumes the capability *is* present. PSS is a preventative control at pod creation, not a runtime containment measure for an exploited capability."
      },
      {
        "question_text": "Host-level firewall rules blocking all traffic from the node where the pod is running",
        "misconception": "Targets granularity and operational overhead: This is an overly broad and impractical solution. It would disrupt all pods on the node, not just the compromised one, and is not a Kubernetes-native network policy."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `NET_ADMIN` capability allows a container to perform various network-related operations, including modifying network interfaces, setting up IP tables, and manipulating routing tables. If exploited, an attacker could use this to redirect traffic, perform man-in-the-middle attacks, or access internal services. An Egress NetworkPolicy that denies all outbound traffic by default and only allows connections to explicitly whitelisted, necessary internal services (like a database or message queue) and DNS servers, significantly limits the attacker&#39;s ability to exfiltrate data or launch further attacks from the compromised pod.",
      "distractor_analysis": "An Ingress NetworkPolicy controls incoming traffic to the pod, which is less relevant for containing an attacker who has already gained control and is trying to make outbound connections. The &#39;Restricted&#39; Pod Security Standard would prevent the `NET_ADMIN` capability from being added in the first place, but the question assumes the capability is already present and exploited, requiring a runtime containment strategy. Host-level firewall rules are too coarse-grained and not a Kubernetes-native solution; they would impact all pods on the node, not just the compromised one, leading to significant operational issues.",
      "analogy": "Imagine a security guard (NetworkPolicy) at the exit of a building (pod). If a person inside (attacker) has a tool (NET_ADMIN) to open any door, the best way to limit damage is to ensure that only specific, monitored exits (whitelisted services) are ever allowed to be used, and all other exits are locked down (deny all egress)."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-all-egress-except-dns-and-internal\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: vulnerable-app\n  policyTypes:\n    - Egress\n  egress:\n    # Allow DNS resolution\n    - to:\n        - ipBlock:\n            cidr: 0.0.0.0/0\n      ports:\n        - protocol: UDP\n          port: 53\n    # Allow access to internal database service (example)\n    - to:\n        - podSelector:\n            matchLabels:\n              app: internal-db\n      ports:\n        - protocol: TCP\n          port: 5432\n    # Implicitly denies all other egress traffic",
        "context": "Egress NetworkPolicy to limit outbound connections from a pod with NET_ADMIN capability"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "LINUX_CAPABILITIES",
      "CONTAINER_SECURITY_CONTEXTS"
    ]
  },
  {
    "question_text": "A containerized web application is deployed in a shared Kubernetes cluster. An attacker gains command execution within one tenant&#39;s container. Which security control is most effective at preventing this attacker from escalating their attack to other containers in the same shared infrastructure?",
    "correct_answer": "Strict NetworkPolicies limiting egress and ingress to only necessary services",
    "distractors": [
      {
        "question_text": "Enforcing `runAsNonRoot: true` in the pod&#39;s securityContext",
        "misconception": "Targets scope misunderstanding: While `runAsNonRoot` prevents root execution within the container, it does not prevent network-based lateral movement if command execution is already achieved as a non-root user."
      },
      {
        "question_text": "Using a `readOnlyRootFilesystem: true` securityContext setting",
        "misconception": "Targets control type confusion: `readOnlyRootFilesystem` prevents writing to the container&#39;s root filesystem but does not restrict network communication or prevent an attacker from using existing binaries to connect to other services."
      },
      {
        "question_text": "Implementing a ClusterRole with minimal permissions for the application&#39;s ServiceAccount",
        "misconception": "Targets control plane vs. data plane confusion: RBAC controls access to the Kubernetes API server (control plane), not direct network communication between pods (data plane). An attacker with command execution inside a container can bypass RBAC for lateral movement."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Once an attacker achieves command execution within a container, the primary concern for shared infrastructures is lateral movement to other tenants&#39; containers or the host. Strict NetworkPolicies are crucial for limiting this &#39;blast radius&#39; by ensuring that even if a container is compromised, it can only communicate with explicitly allowed endpoints. This prevents the compromised container from scanning or connecting to other unauthorized services or containers in the shared environment.",
      "distractor_analysis": "`runAsNonRoot: true` prevents the container from running as root, which is good practice, but an attacker can still perform lateral movement as a non-root user if network access is unrestricted. `readOnlyRootFilesystem: true` prevents modifications to the container&#39;s filesystem but doesn&#39;t restrict network communication. RBAC controls access to the Kubernetes API, not direct network traffic between pods, so it won&#39;t prevent a compromised container from communicating with other pods if NetworkPolicies are not in place.",
      "analogy": "Imagine a shared office building. If one office is compromised, `runAsNonRoot` is like ensuring the intruder isn&#39;t the building manager. `readOnlyRootFilesystem` is like locking down the office&#39;s filing cabinets. But strict NetworkPolicies are like having firewalls between each office, ensuring the intruder can&#39;t just walk into another tenant&#39;s space even if they&#39;re inside the building."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: web-app-policy\n  namespace: tenant-a\nspec:\n  podSelector:\n    matchLabels:\n      app: web-app\n  policyTypes:\n    - Ingress\n    - Egress\n  ingress:\n    - from:\n        - podSelector:\n            matchLabels:\n              app: frontend\n      ports:\n        - protocol: TCP\n          port: 80\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              app: database\n      ports:\n        - protocol: TCP\n          port: 5432\n    - to:\n        - ipBlock:\n            cidr: 10.0.0.0/8\n            except:\n              - 10.0.0.0/24 # Allow only specific internal network ranges\n      ports:\n        - protocol: TCP\n          port: 443",
        "context": "Example NetworkPolicy for a web application, restricting ingress to frontend and egress to a database and specific internal network ranges."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORKING",
      "NETWORK_POLICY_CONCEPTS",
      "CONTAINER_LATERAL_MOVEMENT"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining elevated privileges by exploiting a vulnerability that relies on `CAP_NET_RAW` to craft arbitrary network packets?",
    "correct_answer": "securityContext.capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "securityContext.allowPrivilegeEscalation: false",
        "misconception": "Targets partial prevention: Students confuse preventing *new* privileges with preventing *existing* dangerous capabilities. allowPrivilegeEscalation prevents a child process from gaining more privileges than its parent, but doesn&#39;t remove capabilities the container already has."
      },
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets user vs. capability confusion: Students conflate running as root with having dangerous capabilities. A non-root user can still possess and exploit capabilities like CAP_NET_RAW if not explicitly dropped."
      },
      {
        "question_text": "Pod Security Standard: Baseline",
        "misconception": "Targets insufficient standard: Students might think &#39;Baseline&#39; is enough. The Baseline standard allows `CAP_NET_RAW` by default, as it&#39;s not considered a &#39;privileged&#39; capability in the same vein as `CAP_SYS_ADMIN`."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `CAP_NET_RAW` capability allows a process to create raw sockets, which can be used to craft and send arbitrary network packets, bypassing firewall rules and potentially enabling network-based attacks or reconnaissance. The most effective way to prevent exploitation of this capability is to explicitly remove it from the container&#39;s security context. Dropping &#39;ALL&#39; capabilities is the strongest measure, ensuring that the container operates with the absolute minimum necessary privileges.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining *more* privileges than its parent, but it does not remove capabilities the container already possesses, such as `CAP_NET_RAW`. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, but a non-root user can still have and exploit dangerous capabilities. The Pod Security Standard &#39;Baseline&#39; profile does not restrict `CAP_NET_RAW`, allowing containers to retain this capability by default.",
      "analogy": "Imagine a security guard (container) who has a special tool (CAP_NET_RAW) that lets them bypass the main entrance (firewall) and go anywhere. `allowPrivilegeEscalation: false` is like telling the guard they can&#39;t get *more* special tools. `runAsNonRoot: true` is like saying the guard can&#39;t be the chief of security. But `securityContext.capabilities.drop: [&quot;ALL&quot;]` is like taking away *all* their special tools, including the one that bypasses the entrance, ensuring they can only use the designated pathways."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: network-sensitive-app\nspec:\n  containers:\n  - name: my-container\n    image: my-image:latest\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating how to drop all capabilities to prevent exploitation of `CAP_NET_RAW` and other dangerous capabilities."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_RUNTIME_SECURITY"
    ]
  },
  {
    "question_text": "A red team member has successfully exploited a containerized application using a known vulnerability in a third-party library. To provide actionable security improvements, beyond just reporting the vulnerability, what additional information should the red team member focus on providing to the blue team?",
    "correct_answer": "Explain the specific impact of the vulnerability on the container&#39;s runtime, how it could lead to host compromise, and suggest a compensating control like a specific seccomp profile.",
    "distractors": [
      {
        "question_text": "Detail the exact SQL injection payload used and the steps to reproduce the attack.",
        "misconception": "Targets &#39;how to hack&#39; focus: This focuses on the &#39;what attacking is like&#39; aspect, which is important for reproduction, but doesn&#39;t fully address the &#39;what your attack does&#39; or &#39;what your target system does&#39; for deeper improvements."
      },
      {
        "question_text": "Provide a list of all open ports on the compromised container and the network path taken to reach it.",
        "misconception": "Targets network-centric view: While network information is useful, it primarily describes the attack&#39;s entry point (&#39;what attacking is like&#39;) rather than the internal mechanics of the exploit or the system&#39;s normal behavior."
      },
      {
        "question_text": "Recommend a general upgrade of all container images to their latest versions.",
        "misconception": "Targets generic advice: This is a common, but often insufficient, recommendation. It lacks the specific context of the exploit&#39;s impact and doesn&#39;t provide targeted, actionable improvements beyond basic hygiene."
      }
    ],
    "detailed_explanation": {
      "core_logic": "To provide actionable security improvements, a red team member must go beyond merely demonstrating the &#39;how to hack&#39; (the attack steps). They need to understand &#39;what the attack does&#39; (the specific impact on the container, e.g., privilege escalation, arbitrary code execution, host compromise potential) and &#39;what the target system does when you&#39;re not around&#39; (the normal function of the container and how the exploit deviates from it). This allows for recommending targeted, preventive controls like specific security contexts (e.g., `seccompProfile`, `capabilities.drop`) or network policies that address the root cause and specific impact, rather than just the symptom.",
      "distractor_analysis": "Detailing the SQL injection payload is part of &#39;what attacking is like&#39; and helps reproduction but doesn&#39;t explain the deeper impact or system behavior. Listing open ports and network paths describes the attack&#39;s entry and movement but not its internal effect or how the system normally operates. Recommending a general upgrade is a good practice but lacks the specific context of the exploit&#39;s mechanism and impact, making it less actionable for targeted defense.",
      "analogy": "Imagine a doctor diagnosing a patient. Just saying &#39;the patient has a fever&#39; (the vulnerability) isn&#39;t enough. A good doctor explains &#39;what the fever does&#39; (how it affects organs, potential complications) and &#39;what the body normally does&#39; (how the immune system should respond) to recommend a specific treatment, not just &#39;take some general medicine&#39;."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: vulnerable-app\nspec:\n  containers:\n  - name: app\n    image: vulnerable-image:1.0\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Example of a Pod manifest with security context settings that could mitigate a container escape vulnerability, demonstrating a specific compensating control."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "RED_TEAM_METHODOLOGY",
      "CONTAINER_SECURITY_FUNDAMENTALS",
      "KUBERNETES_SECURITY_CONTEXTS",
      "VULNERABILITY_MANAGEMENT"
    ]
  },
  {
    "question_text": "A containerized application is deployed with a `securityContext` that includes `privileged: true`. Which Pod Security Standard is violated by this configuration, and why is it a critical security concern?",
    "correct_answer": "Restricted, because `privileged: true` grants all Linux capabilities and access to host devices, enabling potential container escapes.",
    "distractors": [
      {
        "question_text": "Baseline, because `privileged: true` allows the container to run as root, which is prohibited.",
        "misconception": "Targets partial understanding of &#39;privileged&#39;: Students may correctly identify that privileged containers often run as root but miss the broader implications of `privileged: true` (all capabilities, host access) and confuse it with `runAsUser: 0`."
      },
      {
        "question_text": "Baseline, because `privileged: true` violates the principle of least privilege by granting excessive network access.",
        "misconception": "Targets scope confusion: Students might incorrectly associate `privileged: true` primarily with network access, rather than its true impact on host-level capabilities and device access, and misapply the Baseline standard which is less strict."
      },
      {
        "question_text": "Privileged, because `privileged: true` is explicitly allowed by this standard, making it a safe configuration.",
        "misconception": "Targets misinterpretation of standard names: Students might incorrectly assume that the &#39;Privileged&#39; standard *allows* privileged containers without restrictions, rather than being the standard that *describes* the most permissive (and dangerous) settings."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `privileged: true` setting in a container&#39;s security context grants the container all Linux capabilities and allows it to access host devices directly. This effectively removes the isolation between the container and the host, making it trivial for an attacker to escape the container and gain root access to the node. The Restricted Pod Security Standard explicitly prohibits `privileged: true` due to these severe security implications, aiming to enforce strong hardening best practices.",
      "distractor_analysis": "The Baseline standard does not explicitly prohibit `privileged: true`, though it would be flagged by other controls. `privileged: true` grants far more than just root user access; it grants all capabilities and host device access. While it does violate least privilege, its primary impact is on host compromise, not just network access. The &#39;Privileged&#39; Pod Security Standard is the most permissive and essentially allows any configuration, including `privileged: true`, but it does not make it a &#39;safe&#39; configuration; rather, it describes the least secure posture.",
      "analogy": "Running a container with `privileged: true` is like giving a guest in your house a master key to every room, including the basement where all your utilities and sensitive documents are stored. The Restricted Pod Security Standard is like a strict hotel policy that only gives guests a key to their own room and nothing else."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: privileged-pod\nspec:\n  containers:\n  - name: my-container\n    image: busybox\n    command: [&quot;sleep&quot;, &quot;3600&quot;]\n    securityContext:\n      privileged: true # This line violates the Restricted PSS\n",
        "context": "Kubernetes Pod manifest demonstrating a privileged container configuration."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "POD_SECURITY_STANDARDS"
    ]
  },
  {
    "question_text": "A Kubernetes application uses a PostgreSQL database for user data and an Elasticsearch instance for search indexing. An attacker successfully exploits a SQL injection vulnerability in the user data service. To prevent lateral movement to the Elasticsearch instance, which network policy configuration is most effective?",
    "correct_answer": "A NetworkPolicy that restricts egress from the PostgreSQL pod to only the application&#39;s backend service, and ingress to Elasticsearch only from the application&#39;s indexing service.",
    "distractors": [
      {
        "question_text": "A NetworkPolicy that denies all egress from the PostgreSQL pod.",
        "misconception": "Targets over-restriction: Students might think denying all egress is the most secure, but it would break legitimate application functionality, as the PostgreSQL pod still needs to communicate with its own application service."
      },
      {
        "question_text": "A NetworkPolicy that allows all egress from the PostgreSQL pod but denies all ingress to the Elasticsearch pod.",
        "misconception": "Targets incomplete protection: Students might focus on protecting the target (Elasticsearch) but neglect the compromised source (PostgreSQL). Allowing all egress from the compromised pod still permits lateral movement attempts."
      },
      {
        "question_text": "A NetworkPolicy that allows egress from the PostgreSQL pod to any IP address on port 9200 (Elasticsearch default port).",
        "misconception": "Targets port-based security without source restriction: Students might incorrectly assume that restricting by port is sufficient, failing to realize that allowing egress to *any* IP on the Elasticsearch port still enables a compromised PostgreSQL pod to connect to an attacker-controlled Elasticsearch or other services on that port."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The principle of least privilege in network segmentation dictates that pods should only be able to communicate with the specific services they require. In this scenario, the compromised PostgreSQL pod should only be able to communicate with its designated application backend. It has no legitimate reason to initiate connections to the Elasticsearch instance. By restricting egress from the PostgreSQL pod to only its necessary communication partners and restricting ingress to Elasticsearch to only its legitimate indexing service, we create a strong barrier against lateral movement, even if one database service is compromised.",
      "distractor_analysis": "Denying all egress from the PostgreSQL pod would prevent it from communicating with its own application service, breaking the application. Allowing all egress from the PostgreSQL pod, even with ingress restrictions on Elasticsearch, still leaves the PostgreSQL pod free to attempt connections to other services or external hosts. Allowing egress to any IP on port 9200 is dangerous because a compromised PostgreSQL pod could connect to an attacker&#39;s external Elasticsearch instance or other services listening on that port, exfiltrating data or launching further attacks.",
      "analogy": "Imagine a bank vault (PostgreSQL) and a separate data archive (Elasticsearch). If the vault is compromised, you don&#39;t just lock the archive&#39;s door. You also ensure the compromised vault can only send money to its intended recipient (the bank&#39;s main system) and cannot send money to the archive or any other unauthorized location."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: postgres-egress-policy\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: postgres\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - podSelector:\n            matchLabels:\n              app: backend-service # The service that legitimately communicates with PostgreSQL\n      ports:\n        - protocol: TCP\n          port: 5432 # PostgreSQL default port\n---\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: elasticsearch-ingress-policy\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: elasticsearch\n  policyTypes:\n    - Ingress\n  ingress:\n    - from:\n        - podSelector:\n            matchLabels:\n              app: indexing-service # The service that legitimately writes to Elasticsearch\n      ports:\n        - protocol: TCP\n          port: 9200 # Elasticsearch default port",
        "context": "Kubernetes NetworkPolicies to restrict egress from the PostgreSQL pod and ingress to the Elasticsearch pod, enforcing least privilege."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "LATERAL_MOVEMENT",
      "LEAST_PRIVILEGE_PRINCIPLE"
    ]
  },
  {
    "question_text": "A containerized web application is performing subdomain brute-forcing as part of its reconnaissance phase. Which Kubernetes NetworkPolicy configuration would effectively prevent this container from making outbound DNS queries to external domains, thus stopping the brute-force attempt?",
    "correct_answer": "An Egress NetworkPolicy that denies all outbound traffic from the pod, except to the cluster&#39;s internal DNS service.",
    "distractors": [
      {
        "question_text": "An Ingress NetworkPolicy that denies all inbound traffic to the pod.",
        "misconception": "Targets Ingress vs. Egress confusion: Students confuse inbound traffic control (Ingress) with outbound traffic control (Egress). Brute-forcing is an outbound activity."
      },
      {
        "question_text": "A NetworkPolicy that only allows traffic to other pods within the same namespace.",
        "misconception": "Targets scope misunderstanding: While this limits lateral movement, it doesn&#39;t explicitly block external DNS queries, which are often handled by a cluster-wide DNS service that might be outside the &#39;same namespace&#39; scope or directly external."
      },
      {
        "question_text": "Setting `dnsPolicy: None` in the Pod&#39;s `spec`.",
        "misconception": "Targets DNS configuration confusion: `dnsPolicy: None` requires `dnsConfig` to be specified, and without it, the pod won&#39;t resolve any names, but it doesn&#39;t prevent direct IP connections or outbound traffic if an attacker bypasses DNS resolution."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Subdomain brute-forcing relies on making numerous outbound DNS queries to resolve potential subdomains. An Egress NetworkPolicy controls outbound traffic from a pod. By default, if a NetworkPolicy selects a pod, all traffic not explicitly allowed is denied. Therefore, an Egress policy that denies all outbound traffic and then specifically allows only traffic to the internal cluster DNS service (typically on a specific port like 53 UDP/TCP) would prevent the container from resolving external domain names, effectively stopping the brute-force attempt.",
      "distractor_analysis": "An Ingress NetworkPolicy only controls traffic coming INTO the pod, not traffic leaving it, so it would not prevent outbound DNS queries. A NetworkPolicy allowing traffic only to other pods in the same namespace might still allow DNS queries if the cluster&#39;s DNS service is accessible from that namespace or if the policy isn&#39;t strict enough. Setting `dnsPolicy: None` would prevent the pod from using the cluster&#39;s DNS, but it doesn&#39;t prevent an attacker from attempting to make direct network connections if they have IP addresses, nor does it prevent other forms of outbound communication.",
      "analogy": "Imagine the container is a person trying to call many different phone numbers (subdomains) to find a specific contact. An Egress NetworkPolicy is like a phone company blocking all outgoing calls except to a specific internal directory assistance number. An Ingress policy would be blocking incoming calls, which doesn&#39;t stop the person from making outbound calls."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: deny-external-dns\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      app: recon-app\n  policyTypes:\n    - Egress\n  egress:\n    - to:\n        - namespaceSelector: {}\n          podSelector:\n            matchLabels:\n              k88s-app: kube-dns # Or whatever label your DNS service has\n      ports:\n        - protocol: UDP\n          port: 53\n        - protocol: TCP\n          port: 53",
        "context": "Kubernetes NetworkPolicy to restrict outbound DNS queries to only the internal cluster DNS service for pods labeled &#39;recon-app&#39;."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_NETWORK_POLICIES",
      "DNS_FUNDAMENTALS",
      "CONTAINER_RECONNAISSANCE"
    ]
  },
  {
    "question_text": "A Kubernetes application processes user-submitted messages, similar to the `appendToDOM` example. To prevent Cross-Site Scripting (XSS) vulnerabilities from user input being rendered in the UI, which security context setting or Pod Security Standard would directly prevent the execution of malicious scripts within the container&#39;s rendering process?",
    "correct_answer": "None of the above; Kubernetes security contexts and Pod Security Standards primarily control container runtime behavior and host interaction, not client-side rendering vulnerabilities like XSS.",
    "distractors": [
      {
        "question_text": "securityContext.runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students might incorrectly associate running as a non-root user with preventing client-side script execution, but this only affects the container&#39;s user ID, not how the application processes and renders data."
      },
      {
        "question_text": "Enforcing the Restricted Pod Security Standard",
        "misconception": "Targets control plane confusion: While Restricted PSS is the most secure, it focuses on preventing host access, privilege escalation, and dangerous capabilities, not on application-level input validation or client-side rendering issues like XSS."
      },
      {
        "question_text": "securityContext.readOnlyRootFilesystem: true",
        "misconception": "Targets irrelevant control: Students might think making the filesystem read-only would prevent script execution, but XSS occurs in the browser/client, not by writing to the container&#39;s filesystem during rendering."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Cross-Site Scripting (XSS) is a client-side web application vulnerability that occurs when an application includes untrusted data in a web page without proper validation or escaping. Kubernetes security contexts and Pod Security Standards operate at the container runtime level, controlling aspects like user IDs, capabilities, filesystem access, and host interaction. They are designed to secure the container and the underlying host, not to mitigate application-level vulnerabilities related to how data is processed and rendered by the application&#39;s front-end code. Preventing XSS requires application-level controls such as input validation, output encoding, and using secure rendering libraries (like DOMPurify as mentioned in the text).",
      "distractor_analysis": "runAsNonRoot: true ensures the container process does not run as UID 0, which is a good practice for container security but has no bearing on how the application handles user input for rendering. The Restricted Pod Security Standard enforces strict security policies like dropping capabilities and preventing privilege escalation, which are crucial for container runtime security but do not address client-side rendering flaws. readOnlyRootFilesystem: true prevents the container from writing to its root filesystem, which is a host-level protection, but XSS exploits client-side rendering logic, not filesystem writes within the container during rendering.",
      "analogy": "Imagine Kubernetes security contexts as the building&#39;s structural integrity and access control (e.g., who can enter, what tools they can bring in). XSS is like a flaw in the interior design of a specific room (the web application&#39;s UI) that allows a visitor to trick others into seeing misleading information. The building&#39;s security doesn&#39;t directly prevent the interior design flaw."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: xss-vulnerable-app\nspec:\n  containers:\n  - name: web-app\n    image: my-vulnerable-image:latest\n    securityContext:\n      # These settings do NOT prevent XSS, as XSS is an application-level flaw\n      runAsNonRoot: true\n      readOnlyRootFilesystem: true\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop: [&quot;ALL&quot;]\n    # ... other container configurations\n",
        "context": "Example Pod manifest showing security context settings that are irrelevant to preventing client-side XSS vulnerabilities."
      },
      {
        "language": "js",
        "code": "import { DOMPurify } from &#39;../utils/DOMPurify&#39;;\n\nconst appendToDOM = function(data, selector, unsafe = false) {\n  const element = document.querySelector(selector);\n\n  if (unsafe) {\n    element.innerHTML = DOMPurify.sanitize(data); // Application-level XSS prevention\n  } else {\n    element.innerText = data;\n  }\n};",
        "context": "Client-side JavaScript demonstrating an application-level countermeasure for XSS using DOMPurify for sanitization."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "POD_SECURITY_STANDARDS",
      "WEB_APPLICATION_SECURITY_BASICS",
      "XSS_VULNERABILITIES"
    ]
  },
  {
    "question_text": "Which container security control would prevent an XML External Entity (XXE) attack from reading sensitive host files like `/etc/shadow` if a vulnerable application is deployed in a Kubernetes pod?",
    "correct_answer": "Implementing a `securityContext` with `readOnlyRootFilesystem: true` and `seccompProfile: RuntimeDefault`",
    "distractors": [
      {
        "question_text": "Applying a `NetworkPolicy` to restrict egress traffic from the pod",
        "misconception": "Targets control plane confusion: Students confuse network-level controls with host-level file access. NetworkPolicy restricts network communication, but an XXE attack reading local files doesn&#39;t necessarily involve network egress from the container to the host."
      },
      {
        "question_text": "Configuring RBAC to limit the ServiceAccount&#39;s permissions within the cluster",
        "misconception": "Targets scope misunderstanding: RBAC controls access to Kubernetes API resources, not the underlying host filesystem or files accessible by the container runtime. An XXE vulnerability exploits the application&#39;s XML parser, not Kubernetes API permissions."
      },
      {
        "question_text": "Ensuring the container image is scanned for known CVEs related to XML parsers",
        "misconception": "Targets detection vs. prevention: While image scanning is crucial for detecting vulnerable XML parsers, it&#39;s a pre-deployment detection mechanism. This question asks for a *preventive control* that stops the attack from succeeding *if* a vulnerability exists and is exploited."
      }
    ],
    "detailed_explanation": {
      "core_logic": "An XXE attack exploits an XML parser to read local files on the server. To prevent this in a containerized environment, `readOnlyRootFilesystem: true` makes the container&#39;s root filesystem immutable, preventing an attacker from writing to or modifying files, but more importantly, it can limit the ability to read arbitrary files outside the container&#39;s intended scope if the application tries to access them via the XXE vulnerability. Additionally, `seccompProfile: RuntimeDefault` restricts the syscalls available to the container, which can prevent certain file system access operations that an XXE exploit might leverage to read host files. Together, these provide a strong defense-in-depth approach.",
      "distractor_analysis": "A `NetworkPolicy` restricts network traffic, but reading `/etc/shadow` via XXE is a local file access operation within the host&#39;s context, not necessarily an egress network call from the pod. RBAC limits access to the Kubernetes API, not the host filesystem. Image scanning detects the vulnerability but doesn&#39;t prevent the exploit if the vulnerable application is deployed; it&#39;s a pre-deployment measure, not a runtime prevention for the file access itself.",
      "analogy": "Imagine an XXE attack as someone tricking a librarian (the XML parser) into reading a secret document (host file) from a restricted shelf. `readOnlyRootFilesystem: true` is like making all the shelves locked and only allowing access to specific, pre-approved books. `seccompProfile: RuntimeDefault` is like giving the librarian a strict list of what types of documents they are allowed to handle, preventing them from accessing anything outside that list, even if tricked."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: vulnerable-app\nspec:\n  containers:\n  - name: app\n    image: vulnerable-xml-parser-image\n    securityContext:\n      readOnlyRootFilesystem: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Kubernetes Pod manifest demonstrating security context settings to mitigate XXE file disclosure"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_FILESYSTEM_SECURITY",
      "XXE_ATTACK_FUNDAMENTALS",
      "SECCOMP_PROFILES"
    ]
  },
  {
    "question_text": "A containerized web application is vulnerable to SQL injection. Which Kubernetes security context setting, if properly configured, would best mitigate the impact of a successful SQL injection by preventing the container from executing arbitrary commands on the host?",
    "correct_answer": "seccompProfile: type: RuntimeDefault",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope misunderstanding: Students confuse privilege escalation within the container with executing arbitrary commands on the host. allowPrivilegeEscalation prevents a non-root process from gaining root privileges, but doesn&#39;t restrict syscalls that could be used for host interaction if already privileged or if a vulnerability allows it."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only prevents all forms of host interaction. While it prevents writing to the container&#39;s root filesystem, it doesn&#39;t restrict syscalls that could interact with the host kernel or other mounted volumes."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets privilege level confusion: Students might believe running as a non-root user inherently prevents all host interaction. While it reduces the impact of many attacks, a non-root user can still execute syscalls that could be exploited for host interaction if not restricted by other means like seccomp."
      }
    ],
    "detailed_explanation": {
      "core_logic": "SQL injection primarily targets the database, but a successful exploitation can sometimes lead to command execution within the container. If an attacker can then leverage this to execute arbitrary commands on the host, it&#39;s a critical container escape. A `seccompProfile` set to `RuntimeDefault` (or a more restrictive custom profile) limits the syscalls a container can make. This directly prevents the container from making dangerous syscalls that could be used to interact with the host kernel or execute arbitrary commands outside its intended scope, thereby mitigating the impact of a successful injection leading to command execution.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but doesn&#39;t restrict the initial set of syscalls available. `readOnlyRootFilesystem: true` prevents modifications to the container&#39;s root filesystem, but doesn&#39;t stop syscalls that could interact with the host or other mounted volumes. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, which is good practice, but a non-root user can still make dangerous syscalls if not restricted by seccomp.",
      "analogy": "Think of SQL injection as an attacker finding a way to trick a librarian (the database interpreter) into giving them specific books. If the librarian also has a secret key to the building&#39;s control room (host access), `seccompProfile` is like putting a guard (seccomp) at the control room door, only allowing the librarian to perform approved actions, even if tricked into trying something else."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: web-app\nspec:\n  containers:\n  - name: my-webapp\n    image: my-vulnerable-app:latest\n    securityContext:\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Pod definition applying the RuntimeDefault seccomp profile to a container."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "SECCOMP",
      "CONTAINER_ESCAPE_TECHNIQUES",
      "SQL_INJECTION_BASICS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from executing arbitrary commands on the host by dropping all Linux capabilities?",
    "correct_answer": "capabilities.drop: [&quot;ALL&quot;]",
    "distractors": [
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete understanding of privileged mode: Students might think &#39;privileged: false&#39; removes all capabilities, but it only prevents the container from running with *all* host capabilities; default capabilities (which can still be dangerous) remain."
      },
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets confusion between initial capabilities and escalation: Students confuse preventing initial dangerous capabilities with preventing a process from gaining *more* privileges than it started with. This setting doesn&#39;t drop existing capabilities."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets scope misunderstanding: Students might associate &#39;root&#39; in the setting name with root privileges or command execution, but this only makes the container&#39;s root filesystem immutable, not preventing execution of commands within the container or capability abuse."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `capabilities.drop: [&quot;ALL&quot;]` security context setting explicitly removes all Linux capabilities from a container. This is a crucial defense against container escapes, as many escape techniques rely on exploiting dangerous capabilities (e.g., `CAP_SYS_ADMIN`, `CAP_NET_ADMIN`) to interact with or manipulate the host kernel. By dropping all capabilities, the container is severely restricted in what it can do, making it much harder to perform privileged operations that could lead to a host compromise.",
      "distractor_analysis": "`privileged: false` is a good practice, but it still leaves a set of default capabilities that can be exploited. `allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t drop the initial capabilities the container starts with. `readOnlyRootFilesystem: true` prevents writing to the container&#39;s root filesystem, which is good for integrity, but it doesn&#39;t directly prevent the execution of commands or the exploitation of capabilities if they are present.",
      "analogy": "Think of `capabilities.drop: [&quot;ALL&quot;]` as removing all the specialized tools from a worker&#39;s toolbox, leaving them with only basic, safe items. `privileged: false` is like giving them a standard toolbox, which might still contain some dangerous tools. `allowPrivilegeEscalation: false` is like preventing them from borrowing more tools from others, but they still have what they started with. `readOnlyRootFilesystem: true` is like making sure the workbench itself can&#39;t be carved into, but doesn&#39;t restrict the tools used on it."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: restricted-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Pod manifest demonstrating how to drop all capabilities for a container, along with other hardening measures."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_PREVENTION"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from executing arbitrary code from its writable filesystem, a common technique in web application attacks like XSS with data injection?",
    "correct_answer": "readOnlyRootFilesystem: true",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope confusion: Students confuse privilege escalation with filesystem write access; allowPrivilegeEscalation prevents gaining *additional* privileges, not writing to the filesystem."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets user vs. filesystem confusion: Students think running as non-root prevents all filesystem writes, but a non-root user can still write to allowed directories if the filesystem is not read-only."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets broad vs. specific control: Students believe disabling privileged mode covers all security aspects, but it primarily restricts host access and does not inherently make the container&#39;s filesystem read-only."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `readOnlyRootFilesystem: true` security context setting mounts the container&#39;s root filesystem as read-only. This is highly effective against attacks like XSS with data injection, where an attacker might try to write malicious scripts or binaries to the container&#39;s filesystem for later execution or persistence. By making the filesystem immutable, such write attempts will fail, preventing the attacker from establishing a foothold or modifying the application&#39;s code.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t restrict write access to the filesystem. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, but a non-root user can still write to writable parts of the filesystem. `privileged: false` removes broad host access but doesn&#39;t specifically enforce a read-only filesystem for the container itself.",
      "analogy": "Think of `readOnlyRootFilesystem: true` like sealing a book in a glass case. You can read it, but you can&#39;t write in it or tear out pages. This prevents anyone, even if they get inside the case, from altering the book&#39;s content."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: web-app-secure\nspec:\n  containers:\n  - name: web-app\n    image: my-secure-webapp:latest\n    securityContext:\n      readOnlyRootFilesystem: true\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      runAsUser: 1000",
        "context": "Pod definition demonstrating `readOnlyRootFilesystem: true` for enhanced security against write-based attacks."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "WEB_APPLICATION_ATTACKS",
      "CONTAINER_IMMUTABILITY"
    ]
  },
  {
    "question_text": "A Kubernetes pod running a web application needs to make cross-origin requests to a specific external API. Which security mechanism, if misconfigured, could allow unintended cross-origin data access, and how is it typically configured in a web server running within a container?",
    "correct_answer": "Cross-Origin Resource Sharing (CORS) configured via HTTP response headers like `Access-Control-Allow-Origin` in the web server (e.g., Nginx, Apache) or application code.",
    "distractors": [
      {
        "question_text": "Content Security Policy (CSP) configured via `Content-Security-Policy` HTTP header.",
        "misconception": "Targets mechanism confusion: Students confuse CORS with CSP. CSP controls script execution sources, while CORS controls cross-origin data access for `fetch` and `XMLHttpRequest`."
      },
      {
        "question_text": "Kubernetes NetworkPolicy allowing egress traffic to the external API.",
        "misconception": "Targets scope misunderstanding: Students confuse network-level access (NetworkPolicy) with browser-level security mechanisms (CORS). NetworkPolicy allows the connection, but CORS dictates if the browser will process the response."
      },
      {
        "question_text": "Pod Security Standard (PSS) Baseline profile applied to the pod.",
        "misconception": "Targets irrelevant control: Students incorrectly associate PSS with web application-level security. PSS governs container runtime security (e.g., root access, capabilities), not browser-enforced web security policies like CORS."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Cross-Origin Resource Sharing (CORS) is a browser-implemented security mechanism that allows web applications to make requests to a different origin than their own, provided the server explicitly permits it. If CORS is misconfigured (e.g., `Access-Control-Allow-Origin: *`), it can allow any origin to access resources, potentially leading to data leakage or unintended actions if combined with authenticated user sessions (CSRF). In a containerized web application, CORS is typically configured within the web server (like Nginx or Apache) or directly in the application&#39;s backend code by setting specific HTTP response headers.",
      "distractor_analysis": "Content Security Policy (CSP) is a different browser security mechanism that controls which resources (scripts, styles, images, etc.) a web page is allowed to load and execute, primarily preventing XSS, not cross-origin data access for `fetch` or `XMLHttpRequest`. Kubernetes NetworkPolicy controls network traffic at the IP/port level between pods and external services; it doesn&#39;t enforce browser-level security policies like CORS. Pod Security Standards (PSS) are Kubernetes-native controls for pod runtime security (e.g., preventing privileged containers, restricting capabilities) and are unrelated to web application-specific cross-origin communication policies.",
      "analogy": "Think of CORS like a bouncer at a club (the browser) checking an ID (the `Origin` header) against a guest list (the `Access-Control-Allow-Origin` header from the server). If the ID isn&#39;t on the list, the bouncer blocks entry, even if the person could physically walk through the door (NetworkPolicy). CSP, on the other hand, is like the club manager deciding which DJs (scripts) are allowed to play music."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-webapp\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: my-webapp\n  template:\n    metadata:\n      labels:\n        app: my-webapp\n    spec:\n      containers:\n      - name: nginx-container\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n        volumeMounts:\n        - name: nginx-config\n          mountPath: /etc/nginx/conf.d\n      volumes:\n      - name: nginx-config\n        configMap:\n          name: nginx-cors-config",
        "context": "Kubernetes Deployment for a web application using Nginx, where CORS would be configured via a ConfigMap."
      },
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: nginx-cors-config\ndata:\n  default.conf:\n    &quot;server {\\n&quot;\n    &quot;    listen 80;\\n&quot;\n    &quot;    location / {\\n&quot;\n    &quot;        add_header &#39;Access-Control-Allow-Origin&#39; &#39;https://trusted-frontend.example.com&#39;;\\n&quot;\n    &quot;        add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;\\n&quot;\n    &quot;        add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#39;;\\n&quot;\n    &quot;        if ($request_method = &#39;OPTIONS&#39;) {\\n&quot;\n    &quot;            add_header &#39;Access-Control-Max-Age&#39; 1728000;\\n&quot;\n    &quot;            add_header &#39;Content-Type&#39; &#39;text/plain charset=UTF-8&#39;;\\n&quot;\n    &quot;            add_header &#39;Content-Length&#39; 0;\\n&quot;\n    &quot;            return 204;\\n&quot;\n    &quot;        }\\n&quot;\n    &quot;        root   /usr/share/nginx/html;\\n&quot;\n    &quot;        index  index.html index.htm;\\n&quot;\n    &quot;    }\\n&quot;\n    &quot;}&quot;",
        "context": "Example Nginx configuration (via ConfigMap) demonstrating how CORS headers are set for a specific origin and methods."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "WEB_APPLICATION_SECURITY",
      "CORS_FUNDAMENTALS",
      "KUBERNETES_BASICS",
      "HTTP_HEADERS"
    ]
  },
  {
    "question_text": "A Kubernetes application exposes an API endpoint `/api/v1/users/&lt;user_id&gt;` where `&lt;user_id&gt;` is an iterable integer. An attacker repeatedly queries this endpoint with successive IDs to determine the total number of users. Which security control, if properly implemented, would directly prevent this enumeration vulnerability?",
    "correct_answer": "Implement API rate limiting on the `/api/v1/users/&lt;user_id&gt;` endpoint.",
    "distractors": [
      {
        "question_text": "Configure `readOnlyRootFilesystem: true` in the pod&#39;s security context.",
        "misconception": "Targets control plane confusion: Students confuse application-level API security with container runtime security; `readOnlyRootFilesystem` prevents writes to the container&#39;s root filesystem but has no impact on API enumeration."
      },
      {
        "question_text": "Apply a NetworkPolicy to restrict ingress traffic to the API service.",
        "misconception": "Targets scope misunderstanding: NetworkPolicy controls network access at the IP/port level, not application-level request patterns; it can&#39;t differentiate between legitimate and enumerating requests from an allowed source."
      },
      {
        "question_text": "Set `runAsNonRoot: true` and `allowPrivilegeEscalation: false` in the pod&#39;s security context.",
        "misconception": "Targets irrelevant security context: These settings prevent privilege escalation and root execution within the container, which are critical for container security but entirely unrelated to preventing API enumeration from external clients."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The enumeration vulnerability described is an application-level issue where repeated, legitimate-looking requests disclose information. Rate limiting directly addresses this by restricting the number of requests a client can make within a given timeframe, making it impractical for an attacker to iterate through a large number of IDs. This prevents the &#39;sum of queries&#39; from revealing unintended information.",
      "distractor_analysis": "`readOnlyRootFilesystem: true` prevents modifications to the container&#39;s filesystem, which is a good security practice but irrelevant to API enumeration. A NetworkPolicy restricts network access but cannot prevent enumeration if the attacker is already allowed to reach the API. `runAsNonRoot: true` and `allowPrivilegeEscalation: false` are crucial for container runtime security but do not address application-level API abuse.",
      "analogy": "Think of rate limiting like a bouncer at a club who only lets a certain number of people in per minute. Even if everyone has a valid ticket (legitimate API request), too many rapid attempts to enter (enumerate) will be blocked, preventing a crowd from forming and revealing the club&#39;s capacity (total users)."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: api-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/limit-rps: &quot;10&quot;\n    nginx.ingress.kubernetes.io/limit-burst: &quot;20&quot;\nspec:\n  rules:\n  - host: api.example.com\n    http:\n      paths:\n      - path: /api/v1/users\n        pathType: Prefix\n        backend:\n          service:\n            name: user-service\n            port:\n              number: 80",
        "context": "Example Ingress annotation for NGINX-based rate limiting on an API endpoint. Note that actual rate limiting implementation often occurs at the API Gateway or application layer."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "WEB_APPLICATION_SECURITY",
      "API_SECURITY",
      "KUBERNETES_NETWORKING",
      "CONTAINER_SECURITY_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "In a secure software development lifecycle, when is the most effective time to conduct a code security review to prevent high-impact bugs from reaching production?",
    "correct_answer": "During merge requests, after the feature&#39;s architecture has been reviewed and all systems are integrated.",
    "distractors": [
      {
        "question_text": "Before the architecture review, to catch early coding mistakes.",
        "misconception": "Targets process order error: Students might think earlier is always better, but reviewing code before architecture leads to wasted effort and missed architectural flaws."
      },
      {
        "question_text": "Continuously, with every single commit, using a pair-programming approach for all features.",
        "misconception": "Targets scope and practicality misunderstanding: While continuous review is good for critical features, applying it to *every* commit for *all* features is often impractical and inefficient for full scope review."
      },
      {
        "question_text": "After the application has been deployed to a staging environment, but before production release.",
        "misconception": "Targets late-stage detection: Students might confuse code review with later testing phases; code review is a preventive measure that should occur much earlier to avoid costly rework."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The most effective time for a comprehensive code security review is during merge requests (pull requests). At this stage, the full feature set has been developed, and all necessary system integrations are in place. This allows reviewers to assess the complete scope of the code and its interactions, ensuring that architectural security decisions have been correctly implemented and identifying any new vulnerabilities introduced during development. This approach is predicated on the architecture having been reviewed first.",
      "distractor_analysis": "Reviewing code before architecture is inefficient and can miss fundamental design flaws. While continuous review per commit or pair-programming is beneficial for mission-critical security features, it&#39;s often impractical for all features and doesn&#39;t provide a full, integrated view of the code. Reviewing only after deployment to staging is too late in the cycle, making remediation more expensive and increasing the risk of high-impact bugs reaching production.",
      "analogy": "Think of building a house: you wouldn&#39;t inspect the plumbing (code) before the blueprints (architecture) are approved. And while you might check individual pipes as they&#39;re laid (per commit), the most thorough inspection happens when all the plumbing is connected and ready for final review before the walls go up (merge request)."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "procedure",
    "prerequisites": [
      "SECURE_DEVELOPMENT_LIFECYCLE",
      "CODE_REVIEW_BEST_PRACTICES",
      "DEVOPS_FUNDAMENTALS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from executing arbitrary commands on the host by restricting its ability to make system calls?",
    "correct_answer": "seccompProfile: type: RuntimeDefault",
    "distractors": [
      {
        "question_text": "allowPrivilegeEscalation: false",
        "misconception": "Targets scope misunderstanding: Students confuse preventing privilege escalation (gaining more privileges) with restricting initial system call access. While related, `allowPrivilegeEscalation` doesn&#39;t directly control the syscalls a container can make from the start."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only prevents arbitrary command execution. While it limits writing to the filesystem, it doesn&#39;t prevent execution of existing binaries or syscalls if the container has the necessary permissions."
      },
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets user vs. syscall confusion: Students often associate &#39;non-root&#39; with general security, but running as a non-root user doesn&#39;t inherently restrict system calls. A non-root user can still make many dangerous syscalls if not further restricted by seccomp."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `seccompProfile: type: RuntimeDefault` setting applies a default seccomp profile to the container, which is provided by the container runtime (e.g., containerd, Docker). This profile typically blocks a large number of dangerous system calls that are not needed for most applications, significantly reducing the attack surface for container escapes and arbitrary command execution on the host. It&#39;s a powerful preventive control for syscall-based attacks.",
      "distractor_analysis": "`allowPrivilegeEscalation: false` prevents a process from gaining more privileges than its parent, but it doesn&#39;t restrict the initial set of system calls available. `readOnlyRootFilesystem: true` prevents modifications to the container&#39;s root filesystem, which is good for integrity, but doesn&#39;t stop a compromised process from executing existing binaries or making syscalls. `runAsNonRoot: true` ensures the container doesn&#39;t run as UID 0, but a non-root user can still make many system calls that could be exploited if not restricted by seccomp.",
      "analogy": "Think of `seccompProfile: type: RuntimeDefault` as a bouncer at a club who only allows specific, pre-approved actions (syscalls) inside. `allowPrivilegeEscalation: false` is like preventing a regular guest from getting a VIP pass. `readOnlyRootFilesystem: true` is like locking down the furniture so it can&#39;t be rearranged. `runAsNonRoot: true` is like ensuring no one wearing a &#39;manager&#39; badge is allowed in, but regular guests can still cause trouble if not monitored."
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: restricted-pod\nspec:\n  containers:\n  - name: my-container\n    image: my-image\n    securityContext:\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Pod definition applying the default seccomp profile to a container"
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_SYSTEM_CALLS",
      "CONTAINER_RUNTIME_SECURITY"
    ]
  },
  {
    "question_text": "A DevSecOps team is evaluating data formats for a new microservice API that will primarily exchange lightweight, structured data between services and a JavaScript-based frontend. The primary security concern is mitigating XML External Entity (XXE) vulnerabilities. Which data format is the most suitable alternative to XML for this use case?",
    "correct_answer": "JSON",
    "distractors": [
      {
        "question_text": "YAML",
        "misconception": "Targets partial knowledge of alternatives: While YAML is mentioned as an alternative, JSON is explicitly highlighted as the default and most practical for lightweight, JavaScript-compatible data, making it a &#39;more&#39; suitable answer in this specific context."
      },
      {
        "question_text": "SVG",
        "misconception": "Targets format type confusion: Students might incorrectly associate SVG with a general data format, not realizing it is an XML-derived image format and thus still susceptible to XML-based vulnerabilities, directly contradicting the goal of mitigating XXE."
      },
      {
        "question_text": "BSON",
        "misconception": "Targets unfamiliarity with common alternatives: BSON is a valid alternative but less common for direct API exchange with JavaScript frontends compared to JSON, and the text explicitly points to JSON as the &#39;default&#39; when looking at other formats for this type of payload."
      }
    ],
    "detailed_explanation": {
      "core_logic": "JSON is presented as the most suitable alternative to XML for lightweight, structured data, especially when interpreted by JavaScript. It is explicitly stated that JSON eliminates XXE risk because it is a simpler, string-based format that stores key/value pairs and does not incorporate external files or multimedia, unlike XML. This makes it inherently more secure against XXE.",
      "distractor_analysis": "YAML and BSON are mentioned as suitable alternatives to XML, but JSON is highlighted as the &#39;default&#39; and most practical choice for lightweight structured data to be interpreted by JavaScript. SVG is an XML-derived format, meaning it would still carry the inherent risks of XML, including XXE, which is precisely what the team wants to mitigate.",
      "analogy": "If XML is a complex, feature-rich blueprint that can accidentally include dangerous external links, JSON is a simple, secure shopping list that only contains items and quantities, making it much safer for quick, structured exchanges."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "WEB_APPLICATION_SECURITY",
      "XML_EXTERNAL_ENTITY_VULNERABILITIES",
      "DATA_FORMATS_COMPARISON"
    ]
  },
  {
    "question_text": "A Kubernetes application processes user-provided search queries by directly constructing database commands. Which security principle, when applied to the application&#39;s architecture, would best mitigate the risk of SQL injection from malicious user input?",
    "correct_answer": "Implementing allowlisting for server-side operations based on vetted, secure functionality.",
    "distractors": [
      {
        "question_text": "Using a Pod Security Standard to restrict container capabilities.",
        "misconception": "Targets control plane confusion: Students might confuse application-level security with infrastructure-level security; Pod Security Standards protect the host and container runtime, not application logic vulnerabilities like SQL injection."
      },
      {
        "question_text": "Applying a NetworkPolicy to isolate the application&#39;s database pod.",
        "misconception": "Targets blast radius vs. prevention: Students might think network isolation prevents the attack, but NetworkPolicy only limits lateral movement *after* a successful injection, not the injection itself."
      },
      {
        "question_text": "Configuring RBAC to limit the application&#39;s Service Account permissions.",
        "misconception": "Targets scope misunderstanding: RBAC controls what the application can do within Kubernetes (e.g., create pods, read secrets), not how it handles internal application logic or database interactions."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The core problem is direct execution of user-provided input as server-side commands, which is a classic injection vulnerability. The most effective architectural mitigation is to never allow client input to directly form executable commands. Instead, server-side operations should be explicitly allowlisted, meaning only a predefined, safe subset of functionality is available and executed based on user input, preventing arbitrary command execution.",
      "distractor_analysis": "Pod Security Standards (PSS) like Restricted or Baseline focus on container runtime security (e.g., dropping capabilities, preventing root execution) and do not address application-level input validation or command construction. NetworkPolicy isolates network traffic but does not prevent a vulnerable application from processing malicious input internally. RBAC governs what a Kubernetes Service Account can do within the cluster&#39;s API, not how the application itself handles user input or interacts with external services like a database.",
      "analogy": "Imagine a restaurant where customers write their own orders directly into the kitchen&#39;s recipe book. Allowlisting is like having a fixed menu where customers can only choose from pre-approved dishes, preventing them from writing a &#39;recipe&#39; that tells the chef to burn down the kitchen."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "WEB_APPLICATION_SECURITY",
      "SQL_INJECTION",
      "LEAST_PRIVILEGE_PRINCIPLE",
      "KUBERNETES_BASICS"
    ]
  },
  {
    "question_text": "Which image scanning technique is most effective at detecting &#39;evil regex&#39; vulnerabilities in containerized web applications before deployment?",
    "correct_answer": "Static Application Security Testing (SAST) with regex pattern analysis",
    "distractors": [
      {
        "question_text": "Dynamic Application Security Testing (DAST) during runtime",
        "misconception": "Targets timing and scope confusion: Students confuse DAST (runtime testing) with SAST (pre-deployment code analysis); DAST would only detect a Regex DoS if specific malicious inputs were provided during a live test, not by scanning the regex patterns themselves."
      },
      {
        "question_text": "Software Composition Analysis (SCA) for third-party libraries",
        "misconception": "Targets vulnerability type mismatch: Students conflate SCA (dependency scanning) with code-level vulnerability scanning; SCA identifies known vulnerabilities in libraries, but &#39;evil regex&#39; is typically custom code or configuration, not a library vulnerability."
      },
      {
        "question_text": "Container runtime security monitoring for anomalous syscalls",
        "misconception": "Targets control plane confusion: Students confuse runtime detection (syscall monitoring) with pre-deployment prevention; this technique would only detect the *effect* of a Regex DoS attack in progress, not prevent the vulnerable regex from being deployed."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Detecting &#39;evil regex&#39; (Regex DoS sinks) requires analyzing the application&#39;s source code or compiled binaries for specific patterns that lead to catastrophic backtracking. Static Application Security Testing (SAST) tools are designed for this purpose, as they can scan the codebase before deployment, identify regex patterns like `(a[ab]*)+`, and flag them as potential vulnerabilities. Some SAST tools specifically include regex performance testers or malicious segment scanners.",
      "distractor_analysis": "DAST operates at runtime and would only detect a Regex DoS if an actual attack was simulated with specific inputs, which is not a proactive detection of the regex pattern itself. SCA focuses on known vulnerabilities in third-party components, not custom-written regex. Container runtime security monitoring detects anomalous behavior during execution, which is a reactive measure, not a preventive one for code-level vulnerabilities like &#39;evil regex&#39; before deployment.",
      "analogy": "Think of SAST for regex as a building inspector reviewing blueprints for structural flaws before construction begins. DAST is like testing the building&#39;s resilience after it&#39;s built by shaking it. SCA is like checking if the bricks used are from a reputable, non-defective batch. Runtime security is like having an alarm system that goes off if the building starts to collapse."
    },
    "code_snippets": [
      {
        "language": "python",
        "code": "import re\n\ndef process_input(user_input):\n    # Example of a potentially &#39;evil regex&#39;\n    # This pattern can cause catastrophic backtracking with inputs like &#39;aaaaaaaaaaaaaaaaaaaaaaaa!&#39;\n    pattern = re.compile(r&#39;(a[ab]*)+$&#39;)\n    if pattern.match(user_input):\n        print(&quot;Match found!&quot;)\n    else:\n        print(&quot;No match.&quot;)",
        "context": "Python code snippet demonstrating a vulnerable regex pattern that SAST tools would flag."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "WEB_APPLICATION_SECURITY",
      "REGEX_DOS",
      "STATIC_ANALYSIS"
    ]
  },
  {
    "question_text": "Which Kubernetes security context setting is most effective at preventing a container from gaining additional privileges after it starts, thereby mitigating a common vector for container escape?",
    "correct_answer": "allowPrivilegeEscalation: false",
    "distractors": [
      {
        "question_text": "runAsNonRoot: true",
        "misconception": "Targets scope misunderstanding: Students confuse preventing initial root execution with preventing privilege escalation. runAsNonRoot prevents starting as root, but doesn&#39;t stop a non-root user from escalating privileges if other conditions allow it."
      },
      {
        "question_text": "readOnlyRootFilesystem: true",
        "misconception": "Targets control type confusion: Students might think making the filesystem read-only prevents all privilege-related actions. While it limits persistence and some attacks, it doesn&#39;t directly prevent a process from escalating its own privileges in memory or via other means."
      },
      {
        "question_text": "privileged: false",
        "misconception": "Targets incomplete mitigation: Students might believe disabling &#39;privileged&#39; mode is sufficient. While &#39;privileged: true&#39; grants ALL capabilities, &#39;privileged: false&#39; still leaves default capabilities that could be exploited for escalation, and doesn&#39;t explicitly block the escalation mechanism itself."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `allowPrivilegeEscalation: false` security context setting directly prevents a process from gaining more privileges than its parent process. Specifically, it prevents the `setuid` and `setgid` bits from being honored, and it prevents the `CAP_SETUID` and `CAP_SETGID` capabilities from being used to change user/group IDs. This is a critical control against privilege escalation, which is often a precursor to container escapes.",
      "distractor_analysis": "`runAsNonRoot: true` ensures the container doesn&#39;t start as UID 0, but doesn&#39;t prevent a non-root user from escalating if possible. `readOnlyRootFilesystem: true` prevents writes to the root filesystem, which is good for integrity, but doesn&#39;t directly block privilege escalation. `privileged: false` removes the most dangerous host access, but default capabilities can still be exploited, and it doesn&#39;t explicitly block the escalation mechanism that `allowPrivilegeEscalation: false` does.",
      "analogy": "Think of `allowPrivilegeEscalation: false` as a rule that says &#39;once you&#39;re in, you can&#39;t get a bigger key.&#39; `runAsNonRoot: true` is like saying &#39;only non-managers can enter this area.&#39; `readOnlyRootFilesystem: true` is like saying &#39;you can look at the files, but you can&#39;t change them.&#39; `privileged: false` is like saying &#39;you can&#39;t have the master key to the whole building.&#39;"
    },
    "code_snippets": [
      {
        "language": "yaml",
        "code": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: restricted-pod\nspec:\n  containers:\n  - name: my-container\n    image: nginx\n    securityContext:\n      allowPrivilegeEscalation: false\n      runAsNonRoot: true\n      capabilities:\n        drop: [&quot;ALL&quot;]\n      seccompProfile:\n        type: RuntimeDefault",
        "context": "Pod manifest demonstrating `allowPrivilegeEscalation: false` within a comprehensive security context."
      }
    ],
    "difficulty": "intermediate",
    "question_type": "defense",
    "prerequisites": [
      "KUBERNETES_SECURITY_CONTEXTS",
      "LINUX_CAPABILITIES",
      "CONTAINER_ESCAPE_TECHNIQUES"
    ]
  },
  {
    "question_text": "A containerized web application is suspected of being vulnerable to Cross-Site Scripting (XSS) attacks. Which image scanning technique would be most effective in identifying the underlying code vulnerabilities that enable XSS?",
    "correct_answer": "Static Application Security Testing (SAST)",
    "distractors": [
      {
        "question_text": "Dynamic Application Security Testing (DAST)",
        "misconception": "Targets testing phase confusion: Students might confuse DAST (runtime testing) with SAST (code analysis). While DAST can detect XSS, it&#39;s a runtime technique, not an image scanning technique for *underlying code vulnerabilities*."
      },
      {
        "question_text": "Software Composition Analysis (SCA)",
        "misconception": "Targets vulnerability type confusion: SCA focuses on known vulnerabilities in third-party libraries and dependencies, not custom code vulnerabilities like XSS in the application&#39;s own logic."
      },
      {
        "question_text": "Container runtime security monitoring",
        "misconception": "Targets control plane confusion: This is a runtime detection/prevention mechanism, not an image scanning technique. It monitors behavior during execution, not static code analysis within the image."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Cross-Site Scripting (XSS) vulnerabilities typically stem from insecure coding practices within the application&#39;s source code, such as improper input validation or output encoding. Static Application Security Testing (SAST) is designed to analyze an application&#39;s source code, bytecode, or binary code for security vulnerabilities without executing the application. This makes it highly effective for identifying XSS flaws at an early stage, directly within the container image&#39;s build process.",
      "distractor_analysis": "DAST (Dynamic Application Security Testing) would detect XSS by actively attacking a running application, but it&#39;s not an image scanning technique for static code. SCA (Software Composition Analysis) focuses on vulnerabilities in third-party components, not the custom application code where XSS often resides. Container runtime security monitoring observes behavior during execution and is not a static analysis method for image vulnerabilities.",
      "analogy": "Think of SAST as a meticulous code review performed by an automated tool before the application even runs, catching syntax errors or logical flaws that could lead to XSS. DAST would be like trying to break into a running application to see if it&#39;s vulnerable."
    },
    "code_snippets": [],
    "difficulty": "intermediate",
    "question_type": "analysis",
    "prerequisites": [
      "CONTAINER_IMAGE_SCANNING",
      "WEB_APPLICATION_VULNERABILITIES",
      "SAST_DAST_SCA_CONCEPTS"
    ]
  }
]