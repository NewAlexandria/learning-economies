[
  {
    "question_text": "Which statement accurately describes AMSI patching as an evasion technique?",
    "correct_answer": "It involves modifying the memory of an attacker&#39;s process to prevent AMSI functions from executing properly.",
    "distractors": [
      {
        "question_text": "It is a method to encrypt malicious code so that AMSI cannot scan its contents.",
        "misconception": "Targets function confusion: Students might incorrectly associate &#39;patching&#39; with encryption or obfuscation, rather than direct memory modification to alter behavior."
      },
      {
        "question_text": "It is a network-level bypass that prevents AMSI from receiving updates from Microsoft.",
        "misconception": "Targets scope confusion: Students might confuse endpoint-level evasion with network-level defenses or update mechanisms, misunderstanding where AMSI operates."
      },
      {
        "question_text": "It involves impersonating legitimate system processes to trick AMSI into ignoring malicious activity.",
        "misconception": "Targets technique confusion: Students might confuse AMSI patching with other evasion techniques like process injection or spoofing, which aim to hide malicious processes rather than disable the scanner itself."
      }
    ],
    "detailed_explanation": {
      "core_logic": "AMSI patching is an evasion technique where an attacker directly modifies the in-memory code of AMSI functions (like AmsiScanBuffer()) within their own process. By altering critical instructions, they force AMSI to return an error or bypass scanning, effectively disabling its protective capabilities for that process.",
      "distractor_analysis": "Encrypting code doesn&#39;t disable AMSI&#39;s scanning capability; it would still attempt to scan the encrypted content. AMSI operates at the endpoint process level, not as a network update mechanism. Impersonating processes is a different evasion technique that doesn&#39;t directly disable AMSI&#39;s scanning functionality.",
      "analogy": "AMSI patching is like physically breaking the lock on a door (AMSI) from the inside, so that even if you try to use the key, the lock no longer functions, allowing free passage."
    },
    "code_snippets": [],
    "difficulty": "advanced",
    "question_type": "definition",
    "prerequisites": [
      "SEC_BASICS",
      "NET_BASICS"
    ]
  },
  {
    "question_text": "Which statement accurately describes the purpose of &#39;normalization&#39; in the context of deobfuscation tools like VxStripper?",
    "correct_answer": "It involves generating an LLVM intermediate representation of translation blocks from a dynamically executed binary, then applying optimizations to simplify the code for analysis.",
    "distractors": [
      {
        "question_text": "It is the initial stage of removing a protection loader and rewritable code from a packed binary.",
        "misconception": "Targets process order error: Students might confuse normalization with the &#39;unpacking&#39; stage, which typically precedes normalization and deals with protection loaders."
      },
      {
        "question_text": "It is a technique used to make malware code more difficult to understand by flattening control flow and using VM-based transformations.",
        "misconception": "Targets reversal error: Students might confuse normalization (a deobfuscation technique) with obfuscation mechanisms themselves, which normalization aims to counter."
      },
      {
        "question_text": "It refers to the process of compiling the LLVM representation back into the original binary&#39;s architecture for re-execution.",
        "misconception": "Targets purpose confusion: Students might misunderstand the goal of normalization, which is to simplify for analysis, not necessarily to re-compile to the original architecture for execution, though that is a possibility for the LLVM output."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Normalization, in this context, is a deobfuscation step that takes the dynamically collected information from a running binary, converts it into an LLVM intermediate representation, and then applies various optimization passes. This process aims to simplify and reduce the complexity of the obfuscated code, making it more amenable to further analysis, especially after initial unpacking.",
      "distractor_analysis": "The first distractor describes unpacking, which is a prerequisite. The second describes obfuscation techniques that normalization aims to address. The third describes a potential *use* of the LLVM output, but not the primary purpose of the normalization *process* itself, which is simplification for analysis.",
      "analogy": "Normalization is like taking a very complex, jumbled instruction manual (obfuscated code), translating it into a standardized, easier-to-read format (LLVM IR), and then editing out all the unnecessary jargon and redundant steps (optimizations) so you can finally understand how the machine works."
    },
    "code_snippets": [],
    "difficulty": "advanced",
    "question_type": "definition",
    "prerequisites": [
      "Reverse Engineering Fundamentals",
      "Assembly Language and Architecture (x86, x64, ARM)",
      "Software Program Analysis"
    ]
  },
  {
    "question_text": "Which statement accurately describes the &#39;hollow process&#39; technique used by malware like Stuxnet?",
    "correct_answer": "Malware creates a legitimate process, then replaces its original code with malicious code while maintaining the appearance of the legitimate process.",
    "distractors": [
      {
        "question_text": "Malware injects code into an existing legitimate process without altering the original process&#39;s executable image.",
        "misconception": "Targets scope confusion: Students might confuse &#39;hollow process&#39; with general code injection, where the original process code remains intact alongside injected code."
      },
      {
        "question_text": "Malware creates a new process with a legitimate name but loads entirely malicious code from the start.",
        "misconception": "Targets process creation confusion: Students might think &#39;hollow process&#39; means simply spoofing a process name, rather than the specific technique of replacing an existing legitimate process&#39;s code."
      },
      {
        "question_text": "Malware encrypts its malicious code within a legitimate process&#39;s memory to evade detection.",
        "misconception": "Targets technique confusion: Students might associate &#39;hollow&#39; with hiding or encrypting, rather than the specific method of code replacement and memory unmapping."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The &#39;hollow process&#39; technique involves creating a legitimate process (e.g., lsass.exe), suspending it, unmapping its original executable code from memory, and then writing malicious code into the now &#39;hollowed&#39; memory space. The process is then resumed, executing the malicious code under the guise of the legitimate process.",
      "distractor_analysis": "Distractor 1 describes a more general code injection, not the specific &#39;hollowing&#39; where the original code is removed. Distractor 2 describes process spoofing, which is simpler than hollowing. Distractor 3 introduces encryption, which is not the primary characteristic of the hollow process technique.",
      "analogy": "Imagine a book where the cover and title are legitimate, but all the original pages inside have been replaced with a completely different, malicious story."
    },
    "code_snippets": [],
    "difficulty": "advanced",
    "question_type": "definition",
    "prerequisites": [
      "SEC_BASICS",
      "NET_BASICS"
    ]
  },
  {
    "question_text": "Which statement accurately describes a rootkit&#39;s method of hiding a kernel module by unlinking its entry?",
    "correct_answer": "A rootkit can hide its presence by removing its KLDR_DATA_TABLE_ENTRY from the PsLoadedModuleList, making it invisible to standard API enumeration.",
    "distractors": [
      {
        "question_text": "A rootkit encrypts its kernel module&#39;s metadata, preventing forensic tools from reading its details.",
        "misconception": "Targets mechanism confusion: Students might assume encryption is the primary hiding mechanism, rather than unlinking from a list."
      },
      {
        "question_text": "A rootkit overwrites the entire kernel module with zeros, making it undetectable by any memory scanning technique.",
        "misconception": "Targets scope misunderstanding: Students might believe the entire module is wiped, rather than just its metadata or PE header, and that it would still function if completely zeroed out."
      },
      {
        "question_text": "A rootkit modifies the system&#39;s clock to make its module appear to have been loaded at an earlier, legitimate time.",
        "misconception": "Targets irrelevant technique: Students might confuse hiding a module with timestamp manipulation, which is a different anti-forensic technique."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Rootkits can hide kernel modules by unlinking their KLDR_DATA_TABLE_ENTRY from the PsLoadedModuleList. This prevents standard operating system APIs and forensic tools that rely on these APIs from enumerating the module, even though the module&#39;s code and metadata might still be present in memory.",
      "distractor_analysis": "Encrypting metadata is not the described method; unlinking is a structural manipulation. Overwriting the entire module with zeros would render it non-functional, and the text explicitly states the code must remain. Modifying system clocks is a different anti-forensic technique unrelated to module unlinking.",
      "analogy": "Unlinking a kernel module entry is like removing a book from a library&#39;s catalog. The book is still on the shelf (in memory), but it&#39;s much harder to find if you only rely on the catalog (the PsLoadedModuleList)."
    },
    "code_snippets": [],
    "difficulty": "advanced",
    "question_type": "definition",
    "prerequisites": [
      "SEC_BASICS",
      "NET_BASICS"
    ]
  },
  {
    "question_text": "Which statement accurately describes the purpose of the `p2.ko` kernel module in the analyzed scenario?",
    "correct_answer": "It bypasses the `/dev/mem` restriction by patching the `devmem_is_allowed` function to always return true, making all physical memory accessible.",
    "distractors": [
      {
        "question_text": "It is a legitimate kernel module used for system diagnostics and performance monitoring.",
        "misconception": "Targets purpose misunderstanding: Students might assume any kernel module is legitimate without understanding its specific malicious function."
      },
      {
        "question_text": "It removes itself from the kernel&#39;s module list and `sysfs` to evade detection by `linux_lsmod`.",
        "misconception": "Targets anti-forensics confusion: While it evades detection, the mechanism is returning a negative value from its init function, not explicit self-removal from lists."
      },
      {
        "question_text": "It is designed to encrypt system memory to protect sensitive data from unauthorized access.",
        "misconception": "Targets function confusion: Students might confuse memory manipulation for malicious access with legitimate memory protection mechanisms like encryption."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The `p2.ko` module is specifically crafted to modify the kernel&#39;s behavior regarding `/dev/mem` access. It achieves this by overwriting the `devmem_is_allowed` function, forcing it to return a value that permits access to all physical memory addresses, thereby bypassing a critical security control.",
      "distractor_analysis": "The module&#39;s behavior is clearly malicious, not for legitimate diagnostics. While it evades detection, it does so by failing its `init` function, causing the kernel to unload it, rather than actively removing itself from module lists. Its purpose is to gain access to memory, not to encrypt it.",
      "analogy": "The `p2.ko` module acts like a master key that disables the security guard (devmem_is_allowed) at the entrance to a restricted area (physical memory), allowing unrestricted access."
    },
    "code_snippets": [
      {
        "language": "bash",
        "code": "insmod p2.ko 2&gt;&amp;1",
        "context": "Command used to load the p2.ko module into the kernel."
      },
      {
        "language": "assembly",
        "code": "mov eax, 0x1\nret",
        "context": "The simplified opcodes that overwrite devmem_is_allowed, making it always return true (0x1)."
      }
    ],
    "difficulty": "advanced",
    "question_type": "analysis",
    "prerequisites": [
      "SEC_BASICS",
      "NET_BASICS"
    ]
  }
]