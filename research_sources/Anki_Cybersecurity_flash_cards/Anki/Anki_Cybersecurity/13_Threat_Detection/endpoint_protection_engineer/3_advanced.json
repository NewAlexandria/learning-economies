[
  {
    "question_text": "Which EDR capability is specifically designed to detect an attacker performing handle theft to `lsass.exe` by monitoring attempts to duplicate existing handles to sensitive processes?",
    "correct_answer": "Object notification callbacks (ObCallbacks) monitoring `OB_OPERATION_HANDLE_DUPLICATE` for `PsProcessType` objects",
    "distractors": [
      {
        "question_text": "Monitoring `NtQuerySystemInformation` API calls for `SystemHandleInformation`",
        "misconception": "Targets pre-execution detection confusion: Student focuses on the discovery phase rather than the actual handle duplication event that the EDR would block or alert on."
      },
      {
        "question_text": "File integrity monitoring on `lsass.exe`",
        "misconception": "Targets file-based detection assumption: Student assumes handle theft involves modifying the `lsass.exe` file itself, rather than interacting with its process handle."
      },
      {
        "question_text": "Network traffic analysis for Mimikatz C2 activity",
        "misconception": "Targets post-exploitation detection: Student focuses on the subsequent use of the stolen credentials rather than the initial handle theft mechanism."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Handle theft involves duplicating an existing handle to a sensitive process like `lsass.exe`. EDRs can detect this by registering object notification callbacks (ObCallbacks) for `PsProcessType` objects. These callbacks are triggered before or after operations on process objects. By specifically monitoring the `OB_OPERATION_HANDLE_DUPLICATE` operation, the EDR driver can intercept and analyze attempts to duplicate handles, especially if the target is a sensitive process like `lsass.exe`.",
      "distractor_analysis": "Monitoring `NtQuerySystemInformation` calls would detect the enumeration of handles, which is a precursor, but not the actual handle duplication event itself. File integrity monitoring on `lsass.exe` is irrelevant as handle theft does not modify the `lsass.exe` executable. Network traffic analysis for Mimikatz C2 would detect post-exploitation activity, not the handle theft technique used to obtain credentials.",
      "analogy": "This EDR capability is like a security guard at a restricted area&#39;s entrance who not only checks who is trying to enter (new handle requests) but also monitors if someone is trying to sneak in by using another person&#39;s existing access badge (duplicating an existing handle)."
    },
    "code_snippets": [
      {
        "language": "c",
        "code": "if (Info-&gt;ObjectType == *PsProcessType)\n{\n    if (Info-&gt;Operation == OB_OPERATION_HANDLE_DUPLICATE)\n    {\n        // ... additional checks for target process name (e.g., lsass) ...\n    }\n}",
        "context": "Snippet from an EDR driver&#39;s object notification callback showing the check for process handle duplication."
      }
    ],
    "difficulty": "advanced",
    "question_type": "defense",
    "prerequisites": [
      "WINDOWS_KERNEL_OBJECTS",
      "EDR_ARCHITECTURE",
      "HANDLE_MANIPULATION",
      "LSASS_ATTACKS"
    ]
  },
  {
    "question_text": "A YARA rule uses the hexadecimal string `$pattern = {48 8B ?? (C0 | C1) E0}`. Which of the following byte sequences would *not* match this pattern?",
    "correct_answer": "48 8B 00 C2 E0",
    "distractors": [
      {
        "question_text": "48 8B 00 C0 E0",
        "misconception": "Targets wildcard and alternative understanding: Student correctly identifies a match, but the question asks for a non-match."
      },
      {
        "question_text": "48 8B FF C1 E0",
        "misconception": "Targets wildcard and alternative understanding: Student correctly identifies a match, but the question asks for a non-match."
      },
      {
        "question_text": "48 8B 1A C0 E0",
        "misconception": "Targets wildcard and alternative understanding: Student correctly identifies a match, but the question asks for a non-match."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The pattern `48 8B ?? (C0 | C1) E0` means: `48` followed by `8B`, followed by *any single byte* (`??`), followed by either `C0` OR `C1`, followed by `E0`. The sequence `48 8B 00 C2 E0` does not match because `C2` is neither `C0` nor `C1` in the alternative group.",
      "distractor_analysis": "All other options (`48 8B 00 C0 E0`, `48 8B FF C1 E0`, `48 8B 1A C0 E0`) correctly match the pattern. `??` matches any single byte (e.g., `00`, `FF`, `1A`), and the alternatives `(C0 | C1)` correctly match either `C0` or `C1`.",
      "analogy": "This is like a lock combination where you know the first two numbers, the third can be anything, the fourth must be one of two specific numbers, and the last is fixed. If you try a fourth number that isn&#39;t one of the two allowed, the lock won&#39;t open."
    },
    "code_snippets": [],
    "difficulty": "advanced",
    "question_type": "analysis",
    "prerequisites": [
      "YARA_HEX_STRINGS",
      "HEXADECIMAL_NOTATION"
    ]
  },
  {
    "question_text": "To prevent the execution of common scripting interpreters (like `powershell.exe` or `cmd.exe`) from user-writable directories, which application control policy configuration is most effective?",
    "correct_answer": "Path rules restricting execution from user profile directories and temporary folders",
    "distractors": [
      {
        "question_text": "Hash-based rules for all legitimate `powershell.exe` and `cmd.exe` binaries",
        "misconception": "Targets scalability and effectiveness misunderstanding: Student believes hash rules are practical for system binaries and would prevent their malicious use from unauthorized locations."
      },
      {
        "question_text": "Publisher rules allowing only Microsoft-signed executables",
        "misconception": "Targets scope limitation: Student overlooks that legitimate, signed binaries can still be abused if executed from restricted contexts or locations."
      },
      {
        "question_text": "Blocking all unsigned executables system-wide",
        "misconception": "Targets over-broadness and legitimate application impact: Student proposes a policy that is too restrictive and doesn&#39;t directly address the specific threat of legitimate tools from user-writable paths."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Attackers frequently leverage &#39;Living Off The Land Binaries&#39; (LOLBins) like `powershell.exe` or `cmd.exe` by executing them from user-writable locations (e.g., `%TEMP%`, user profile folders) where they can drop malicious scripts or tools. Path rules in application control policies are highly effective here because they specifically prevent execution from these high-risk directories, regardless of whether the binary itself is legitimate and signed. This prevents the abuse of trusted system tools from untrusted locations.",
      "distractor_analysis": "Hash-based rules for system binaries are impractical; their hashes change with every update, requiring constant maintenance. While publisher rules are good for ensuring software authenticity, they don&#39;t prevent a legitimately signed `powershell.exe` from being used maliciously if executed from a user-writable directory. Blocking all unsigned executables system-wide is often too disruptive for many environments and doesn&#39;t specifically address the threat of signed LOLBins being abused from specific paths.",
      "analogy": "Think of it like a bouncer at a club (application control). Publisher rules are like checking IDs to ensure people are who they say they are. Path rules are like saying, &#39;You&#39;re allowed in, but you can&#39;t bring your own drinks from outside and serve them from the coat check area.&#39; It restricts *where* legitimate tools can operate."
    },
    "code_snippets": [
      {
        "language": "powershell",
        "code": "New-CIPolicy -FilePath .\\AppControlPolicy.xml -Level Path -UserWriteablePaths Deny",
        "context": "Creating a Windows Defender Application Control policy that denies execution from user-writable paths."
      },
      {
        "language": "powershell",
        "code": "$Rule = New-CIPolicyRule -FilePath &#39;%TEMP%\\*&#39; -Deny -RuleType Path",
        "context": "Example of creating a specific path rule to deny execution from the temporary directory."
      }
    ],
    "difficulty": "advanced",
    "question_type": "defense",
    "prerequisites": [
      "APPLICATION_CONTROL_POLICIES",
      "LOLBIN_MITIGATION",
      "WINDOWS_SECURITY_HARDENING",
      "WDAC_CONFIGURATION"
    ]
  },
  {
    "question_text": "Which type of deep learning architecture is specifically designed to capture both spatial and temporal features in network traffic for improved intrusion detection, particularly for zero-day attacks in Software-Defined Networking (SDN) environments?",
    "correct_answer": "Hybrid model combining Convolutional Neural Networks (CNNs) and Long Short-Term Memory Networks (LSTMs)",
    "distractors": [
      {
        "question_text": "Fully Connected Deep Neural Networks (FCDNNs)",
        "misconception": "Targets architectural scope misunderstanding: Student might think any deep neural network is sufficient, not recognizing the specific need for spatial and temporal feature capture."
      },
      {
        "question_text": "Deep Belief Networks (DBNs) with probabilistic neural networks",
        "misconception": "Targets specific application confusion: Student might recall DBNs are used for anomaly detection but miss their primary strength is unsupervised feature learning, not combined spatial-temporal analysis."
      },
      {
        "question_text": "Autoencoders with simple Recurrent Neural Network (RNN) layers",
        "misconception": "Targets primary function confusion: Student might focus on autoencoders for anomaly detection and feature extraction, overlooking their primary role in dimensionality reduction and reconstruction rather than direct combined spatial-temporal classification."
      }
    ],
    "detailed_explanation": {
      "core_logic": "A hybrid model combining Convolutional Neural Networks (CNNs) and Long Short-Term Memory Networks (LSTMs) is specifically designed for this purpose. CNNs are effective at extracting spatial features (patterns within data at a given time), while LSTMs, a type of Recurrent Neural Network, excel at capturing temporal dependencies (patterns over time sequences). Their combination allows for a robust analysis of network traffic that considers both the immediate characteristics and the sequence of events, which is crucial for detecting novel, zero-day attacks.",
      "distractor_analysis": "Fully Connected Deep Neural Networks are general-purpose deep learning models but lack the specialized architectural components (like convolutional layers for spatial and recurrent layers for temporal) to efficiently capture both types of features simultaneously. Deep Belief Networks are powerful for unsupervised feature learning and anomaly detection but are not inherently designed to combine spatial and temporal analysis in the same way CNN-LSTMs are. Autoencoders are primarily used for dimensionality reduction and anomaly detection by learning to reconstruct inputs, and while they can be combined with RNNs, their core function isn&#39;t the direct combined spatial-temporal feature extraction for classification that CNN-LSTMs provide.",
      "analogy": "Imagine a security guard who not only recognizes suspicious faces (CNN for spatial patterns) but also remembers their past movements and behaviors over time (LSTM for temporal patterns). A hybrid CNN-LSTM model is like having such a guard who can piece together both &#39;what&#39; something looks like and &#39;how&#39; it behaves over time to spot an intruder."
    },
    "code_snippets": [],
    "difficulty": "advanced",
    "question_type": "defense",
    "prerequisites": [
      "DEEP_LEARNING_BASICS",
      "NEURAL_NETWORK_ARCHITECTURES",
      "INTRUSION_DETECTION_SYSTEMS",
      "SOFTWARE_DEFINED_NETWORKING"
    ]
  },
  {
    "question_text": "Which endpoint protection feature is specifically designed to reduce the attack surface of an application by compiling the application, its libraries, and kernel services into a single, specialized binary that runs within a virtual environment?",
    "correct_answer": "Unikernels",
    "distractors": [
      {
        "question_text": "Traditional hypervisors",
        "misconception": "Targets scope confusion: Student confuses the underlying virtualization technology with the specialized application deployment model."
      },
      {
        "question_text": "Partitioning hypervisors",
        "misconception": "Targets function confusion: Student conflates resource isolation for multiple OSes with single-application, reduced footprint deployment."
      },
      {
        "question_text": "Library operating systems (LibOS)",
        "misconception": "Targets component confusion: Student identifies a component used by unikernels but not the complete solution itself."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Unikernels are specialized machine images that compile an application, its necessary system libraries, and kernel services into a single, minimal binary. This approach significantly shrinks the attack surface and resource footprint compared to running an application on a full general-purpose OS within a VM, making them highly efficient and secure for specific deployments.",
      "distractor_analysis": "Traditional hypervisors manage multiple virtual machines, each typically running a full OS, which is the opposite of a unikernel&#39;s minimal approach. Partitioning hypervisors focus on securely isolating multiple guest OSes on shared hardware, not on optimizing a single application&#39;s footprint. Library operating systems are a foundational component that unikernels are built upon, but they are not the complete, specialized binary solution themselves.",
      "analogy": "If a traditional OS is a full-service restaurant with a huge menu, and a VM is a separate dining room, a unikernel is like a specialized food truck that only serves one specific dish, built with only the necessary equipment for that dish, making it very efficient and less prone to issues."
    },
    "code_snippets": [],
    "difficulty": "advanced",
    "question_type": "definition",
    "prerequisites": [
      "VIRTUALIZATION_CONCEPTS",
      "OPERATING_SYSTEM_ARCHITECTURES",
      "ATTACK_SURFACE_REDUCTION"
    ]
  },
  {
    "question_text": "To prevent the execution of malicious VBScript or JScript files by common Windows scripting hosts (e.g., `wscript.exe`, `cscript.exe`), which application control configuration is most effective?",
    "correct_answer": "Implementing application control rules to restrict or block `wscript.exe` and `cscript.exe` from executing scripts from user-writable locations or unknown publishers.",
    "distractors": [
      {
        "question_text": "Blocking all unsigned executables system-wide",
        "misconception": "Targets executable-only focus: Student incorrectly assumes that blocking unsigned executables will prevent script execution, but script interpreters themselves are signed."
      },
      {
        "question_text": "Implementing a host-based firewall to block outbound connections from scripting hosts",
        "misconception": "Targets network-based prevention: Student confuses network egress filtering with local execution prevention."
      },
      {
        "question_text": "Whitelisting all default Windows system binaries, including `wscript.exe` and `cscript.exe`, without further restrictions",
        "misconception": "Targets overly broad whitelisting: Student doesn&#39;t understand that whitelisting the interpreter without restricting its behavior allows malicious scripts to run."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Malicious VBScript and JScript files are often executed by legitimate Windows scripting hosts like `wscript.exe` and `cscript.exe`. Application control solutions (like Windows Defender Application Control or AppLocker) can be configured to restrict these interpreters. This can involve allowing them to run only from specific trusted paths, preventing them from executing scripts from user-writable directories (e.g., Downloads, Temp), or only allowing scripts signed by trusted publishers. This prevents the interpreters from being weaponized by attackers.",
      "distractor_analysis": "Blocking all unsigned executables is ineffective because `wscript.exe` and `cscript.exe` are signed Microsoft binaries. A host-based firewall blocks network connections but does not prevent the local execution of the script itself. Whitelisting the scripting hosts without additional restrictions on *what* they can execute or *where* they can execute from defeats the purpose, as it allows them to run any script, malicious or not.",
      "analogy": "This is like having a security guard (application control) at a tool shed (scripting host). Instead of just letting anyone with a uniform (signed binary) take any tool, the guard ensures they only take tools for approved jobs (trusted scripts) and only use them in designated work areas (non-user-writable paths)."
    },
    "code_snippets": [
      {
        "language": "powershell",
        "code": "New-AppLockerPolicy -RuleType Path -Filepath &#39;%OSDrive%\\Users\\*\\*.vbs&#39; -Action Deny -User Everyone -PolicyType Script",
        "context": "Example AppLocker rule to deny VBScript execution from any user&#39;s profile directory."
      },
      {
        "language": "powershell",
        "code": "New-AppLockerPolicy -RuleType Publisher -Filepath &#39;%SystemRoot%\\System32\\wscript.exe&#39; -Action Allow -User Everyone -Publisher &#39;O=MICROSOFT WINDOWS, L=REDMOND, S=WASHINGTON, C=US&#39; -Product &#39;Microsoft® Windows® Operating System&#39; -BinaryName &#39;Windows Script Host&#39; -MinimumVersion 5.8",
        "context": "Example AppLocker rule to allow wscript.exe based on its publisher, which would then be combined with other rules to restrict its behavior."
      }
    ],
    "difficulty": "advanced",
    "question_type": "defense",
    "prerequisites": [
      "APPLICATION_CONTROL_POLICIES",
      "WINDOWS_SCRIPTING_HOSTS",
      "ATTACK_VECTORS_SCRIPTING"
    ]
  },
  {
    "question_text": "Which host-based telemetry source provides the most granular detail for detecting lateral movement techniques involving remote service creation (e.g., PsExec) or WMI execution on Windows endpoints?",
    "correct_answer": "Sysmon (System Monitor) with a comprehensive configuration, specifically Event IDs for process creation, network connections, and WMI activity.",
    "distractors": [
      {
        "question_text": "Windows Application Event Log for application crashes",
        "misconception": "Targets wrong log type: Student confuses application-specific logs with security auditing and system activity."
      },
      {
        "question_text": "Network flow data (NetFlow/IPFIX) from network devices",
        "misconception": "Targets network-only detection: Student focuses on network-level data, which lacks the host-specific process and command-line details for lateral movement."
      },
      {
        "question_text": "Default Windows Security Event Log without advanced auditing or Sysmon",
        "misconception": "Targets insufficient logging: Student believes default security logs are enough, but they often lack the depth (e.g., full command lines, WMI activity) needed for advanced lateral movement detection."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Sysmon provides highly granular host-based telemetry that is critical for detecting lateral movement. For PsExec, Sysmon Event ID 1 (Process Creation) captures the service creation and execution of `PsExecSvc.exe` with full command-line arguments. Sysmon Event ID 3 (Network Connection) can show the connection to the target. For WMI execution, Sysmon Event ID 1 (Process Creation) captures `wmic.exe` or `powershell.exe` with WMI commands, and specific Sysmon WMI event types (e.g., Event ID 19, 20, 21 for WMI activity) provide direct visibility into WMI module loads and script executions.",
      "distractor_analysis": "The Windows Application Event Log primarily records application-specific events and errors, not detailed security-relevant system activity like lateral movement. Network flow data (NetFlow/IPFIX) provides network connection metadata but lacks the crucial process, command-line, and WMI execution details occurring on the endpoint itself. The default Windows Security Event Log, while important, often lacks the depth (e.g., full command lines for all processes, WMI event logging) that Sysmon provides, making it less effective for granular lateral movement detection without extensive advanced audit policy configuration.",
      "analogy": "Sysmon is like having a detailed security camera system with motion sensors and audio recording inside every room of a building, capturing every action and conversation. Default Windows logs are like a guestbook at the entrance, and network flow data is like watching traffic outside the building – they give some information, but not the critical internal details."
    },
    "code_snippets": [
      {
        "language": "xml",
        "code": "&lt;EventFiltering&gt;\n  &lt;RuleGroup name=&quot;Process Creation&quot; groupRelation=&quot;or&quot;&gt;\n    &lt;ProcessCreate onmatch=&quot;include&quot;&gt;\n      &lt;Image condition=&quot;contains&quot;&gt;PsExecSvc.exe&lt;/Image&gt;\n      &lt;Image condition=&quot;contains&quot;&gt;wmic.exe&lt;/Image&gt;\n      &lt;CommandLine condition=&quot;contains&quot;&gt;Win32_Process&lt;/CommandLine&gt;\n    &lt;/ProcessCreate&gt;\n  &lt;/RuleGroup&gt;\n  &lt;RuleGroup name=&quot;WMI Activity&quot; groupRelation=&quot;or&quot;&gt;\n    &lt;WmiEvent onmatch=&quot;include&quot;&gt;\n      &lt;EventID condition=&quot;is&quot;&gt;19&lt;/EventID&gt;\n      &lt;EventID condition=&quot;is&quot;&gt;20&lt;/EventID&gt;\n      &lt;EventID condition=&quot;is&quot;&gt;21&lt;/EventID&gt;\n    &lt;/WmiEvent&gt;\n  &lt;/RuleGroup&gt;\n&lt;/EventFiltering&gt;",
        "context": "Excerpt from a Sysmon configuration file showing rules to capture process creation related to PsExec and WMI, and specific WMI event IDs."
      },
      {
        "language": "powershell",
        "code": "Get-WinEvent -LogName &#39;Microsoft-Windows-Sysmon/Operational&#39; | Where-Object {$_.Id -eq 1 -or $_.Id -eq 3 -or ($_.Id -ge 19 -and $_.Id -le 21)}",
        "context": "PowerShell command to query Sysmon operational logs for process creation (1), network connections (3), and WMI activity (19-21)."
      }
    ],
    "difficulty": "advanced",
    "question_type": "analysis",
    "prerequisites": [
      "WINDOWS_EVENT_LOGGING",
      "SYSMON_CONFIGURATION",
      "LATERAL_MOVEMENT_TECHNIQUES"
    ]
  },
  {
    "question_text": "Which EDR capability, when integrated with memory forensics tools, would be most effective in detecting an attacker&#39;s command-line activity that bypasses standard process logging by executing directly within an existing process&#39;s memory space?",
    "correct_answer": "Memory scanning for command history structures and suspicious string patterns",
    "distractors": [
      {
        "question_text": "File integrity monitoring of system binaries",
        "misconception": "Targets file-based detection assumption: Student assumes all malicious activity involves modifying files, overlooking in-memory execution."
      },
      {
        "question_text": "Network flow analysis for unusual port activity",
        "misconception": "Targets detection layer confusion: Student focuses on network-level indicators, missing host-based memory compromise."
      },
      {
        "question_text": "Application whitelisting of approved executables",
        "misconception": "Targets execution prevention vs. post-execution detection: Student confuses preventing unauthorized programs with detecting in-memory command execution within an authorized process."
      }
    ],
    "detailed_explanation": {
      "core_logic": "Attackers can execute commands directly within the memory space of legitimate processes (e.g., `csrss.exe`) to evade traditional process creation logging. Memory forensics tools, often integrated into advanced EDR/XDR solutions, can scan the memory of running processes for specific data structures (like `_COMMAND_HISTORY`) or suspicious string patterns (e.g., command prompt strings, known malicious commands) to uncover this hidden activity.",
      "distractor_analysis": "File integrity monitoring only detects changes to files on disk, which is bypassed by in-memory execution. Network flow analysis might detect C2 traffic later, but not the initial command execution within memory. Application whitelisting prevents unauthorized executables from running, but doesn&#39;t detect commands executed within an already whitelisted process.",
      "analogy": "This is like checking a person&#39;s thoughts (memory) for suspicious plans, rather than just watching their physical actions (file changes) or who they talk to (network traffic)."
    },
    "code_snippets": [
      {
        "language": "bash",
        "code": "$ python vol.py -f mem.dmp yarascan --wide -Y &quot;/C:\\\\.\\.+&gt;&quot;",
        "context": "Example Volatility command using YARA to scan memory for command prompt-like strings, indicating potential command execution."
      }
    ],
    "difficulty": "advanced",
    "question_type": "defense",
    "prerequisites": [
      "MEMORY_FORENSICS_BASICS",
      "EDR_CAPABILITIES",
      "FILELESS_MALWARE_CONCEPTS",
      "WINDOWS_PROCESS_ARCHITECTURE"
    ]
  },
  {
    "question_text": "Which endpoint protection feature is most effective at detecting a web application attack where an attacker modifies a hidden field to access another user&#39;s data, given that the application&#39;s primary defenses should already be checking for such attacks?",
    "correct_answer": "Application-integrated real-time alerting based on tailored input validation logic",
    "distractors": [
      {
        "question_text": "Generic Web Application Firewall (WAF) signature-based rules",
        "misconception": "Targets WAF overestimation: Student believes WAFs are universally effective for all attack types, even subtle logic flaws."
      },
      {
        "question_text": "Host-based Intrusion Detection System (HIDS) monitoring for known attack strings in web server logs",
        "misconception": "Targets HIDS scope confusion: Student conflates HIDS&#39;s role in host security with application-specific logic detection."
      },
      {
        "question_text": "Network Intrusion Prevention System (NIPS) blocking large numbers of requests from a single IP address",
        "misconception": "Targets NIPS/DDoS confusion: Student focuses on volumetric attacks rather than subtle application logic manipulation."
      }
    ],
    "detailed_explanation": {
      "core_logic": "The most effective detection for subtle web application attacks, such as modifying hidden fields to access unauthorized data, comes from real-time alerting mechanisms tightly integrated with the application&#39;s specific input validation and business logic. Because these checks are tailored to the application&#39;s expected behavior, they can accurately identify malicious intent that bypasses generic defenses.",
      "distractor_analysis": "Generic WAF signature-based rules are often ineffective against subtle attacks that don&#39;t use standard attack strings or exploit application logic flaws. HIDS monitors host-level events and logs, but cannot inherently understand the context of web application business logic. NIPS blocking based on request volume addresses denial-of-service or brute-force attacks, not specific data manipulation within a legitimate-looking request.",
      "analogy": "This is like having a custom-built security system for a specific vault that knows exactly how the vault should be opened and what items are inside, rather than a generic alarm system that just detects loud noises at the entrance."
    },
    "code_snippets": [],
    "difficulty": "advanced",
    "question_type": "defense",
    "prerequisites": [
      "WEB_APPLICATION_SECURITY_CONCEPTS",
      "WAF_LIMITATIONS",
      "APPLICATION_LOGIC_ATTACKS"
    ]
  }
]